---
title: Nouveautés de Visual Basic
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: 5b1547f596a0ff1c52a402f90457dced6ef604a0
ms.sourcegitcommit: 438919211260bb415fc8f96ca3eabc33cf2d681d
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/16/2019
ms.locfileid: "59611794"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="71ab4-102">Nouveautés de Visual Basic</span><span class="sxs-lookup"><span data-stu-id="71ab4-102">What's new for Visual Basic</span></span>

<span data-ttu-id="71ab4-103">Cette rubrique liste les noms des principales fonctionnalités de chaque version de Visual Basic et décrit en détail les fonctionnalités nouvelles et améliorées des dernières versions du langage.</span><span class="sxs-lookup"><span data-stu-id="71ab4-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="71ab4-104">Version actuelle</span><span class="sxs-lookup"><span data-stu-id="71ab4-104">Current version</span></span>

<span data-ttu-id="71ab4-105">Visual Basic 15.8 / Visual Studio 2017 version 15.8. Pour les nouvelles fonctionnalités, consultez [Visual Basic 15.8](#visual-basic-158)</span><span class="sxs-lookup"><span data-stu-id="71ab4-105">Visual Basic 15.8 / Visual Studio 2017 Version 15.8 For new features, see [Visual Basic 15.8](#visual-basic-158)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="71ab4-106">Versions antérieures</span><span class="sxs-lookup"><span data-stu-id="71ab4-106">Previous versions</span></span>

<span data-ttu-id="71ab4-107">Visual Basic 15.5 / Visual Studio 2017 version 15.5. Pour les nouvelles fonctionnalités, consultez [Visual Basic 15.5](#visual-basic-155)</span><span class="sxs-lookup"><span data-stu-id="71ab4-107">Visual Basic 15.5 / Visual Studio 2017 Version 15.5 For new features, see [Visual Basic 15.5](#visual-basic-155)</span></span>

<span data-ttu-id="71ab4-108">Visual Basic 15.3 / Visual Studio 2017 version 15.3. Pour les nouvelles fonctionnalités, consultez [Visual Basic 15.3](#visual-basic-153)</span><span class="sxs-lookup"><span data-stu-id="71ab4-108">Visual Basic 15.3 / Visual Studio 2017 Version 15.3 For new features, see [Visual Basic 15.3](#visual-basic-153)</span></span>

<span data-ttu-id="71ab4-109">Visual Basic 2017 / Visual Studio 2017. Pour les nouvelles fonctionnalités, consultez [Visual Basic 2017](#visual-basic-2017)</span><span class="sxs-lookup"><span data-stu-id="71ab4-109">Visual Basic 2017 / Visual Studio 2017 For new features, see [Visual Basic 2017](#visual-basic-2017)</span></span>

<span data-ttu-id="71ab4-110">Visual Basic / Visual Studio 2015. Pour les nouvelles fonctionnalités, consultez [Visual Basic 14](#visual-basic-14)</span><span class="sxs-lookup"><span data-stu-id="71ab4-110">Visual Basic / Visual Studio 2015 For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="71ab4-111">Visual Basic / Visual Studio 2013. Aperçus des technologies de la plateforme de compilateur .NET (« Roslyn »)</span><span class="sxs-lookup"><span data-stu-id="71ab4-111">Visual Basic / Visual Studio 2013 Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="71ab4-112">Visual Basic / Visual Studio 2012. Mots clés `Async` et `await`, itérateurs, attributs des informations de l’appelant</span><span class="sxs-lookup"><span data-stu-id="71ab4-112">Visual Basic / Visual Studio 2012 `Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="71ab4-113">Visual Basic, Visual Studio 2010. Propriétés implémentées automatiquement, initialiseurs de collection, continuation de ligne implicite, variance co/contra générique, dynamique, accès à l’espace de noms global</span><span class="sxs-lookup"><span data-stu-id="71ab4-113">Visual Basic, Visual Studio 2010 Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="71ab4-114">Visual Basic / Visual Studio 2008. LINQ (Language Integrated Query), littéraux XML, inférence de type local, initialiseurs d’objet, types anonymes, méthodes d’extension, inférence de type `var` local, expressions lambda, opérateur `if`, méthodes partielles, types de valeur nullable</span><span class="sxs-lookup"><span data-stu-id="71ab4-114">Visual Basic / Visual Studio 2008 Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="71ab4-115">Visual Basic / Visual Studio 2005. Type `My` et types helper (accès à l’application, ordinateur, système de fichiers, réseau)</span><span class="sxs-lookup"><span data-stu-id="71ab4-115">Visual Basic / Visual Studio 2005 The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="71ab4-116">Visual Basic / Visual Studio .NET 2003. Opérateurs de décalage de bits, déclaration de variable de boucle</span><span class="sxs-lookup"><span data-stu-id="71ab4-116">Visual Basic / Visual Studio .NET 2003 Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="71ab4-117">Visual Basic / Visual Studio .NET 2002. Première version de Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="71ab4-117">Visual Basic / Visual Studio .NET 2002 The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-158"></a><span data-ttu-id="71ab4-118">Visual Basic 15.8</span><span class="sxs-lookup"><span data-stu-id="71ab4-118">Visual Basic 15.8</span></span>

<span data-ttu-id="71ab4-119">**Conversion optimisée de valeurs à virgule flottante en valeurs entières**</span><span class="sxs-lookup"><span data-stu-id="71ab4-119">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="71ab4-120">Dans les versions précédentes de Visual Basic, la conversion de valeurs [Double](../language-reference/data-types/double-data-type.md) et [Single](../language-reference/data-types/single-data-type.md) en entiers offrait des performances relativement médiocres.</span><span class="sxs-lookup"><span data-stu-id="71ab4-120">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="71ab4-121">Visual Basic 15.8 améliore considérablement les performances des conversions de valeurs à virgule flottante en entiers quand vous passez la valeur retournée par n’importe laquelle des méthodes suivantes à l’une des [fonctions de conversion d’entiers Visual Basic intrinsèques](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), ou si la valeur retournée par n’importe laquelle des méthodes suivantes est implicitement castée en un type intégral type quand [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) est défini sur `Off` :</span><span class="sxs-lookup"><span data-stu-id="71ab4-121">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="71ab4-122">Cette optimisation permet au code de s’exécuter plus rapidement (jusqu’à deux fois plus rapidement pour le code qui effectue un grand nombre de conversions en types d’entier).</span><span class="sxs-lookup"><span data-stu-id="71ab4-122">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="71ab4-123">L’exemple suivant illustre certains appels de méthode simples qui sont affectés par cette optimisation :</span><span class="sxs-lookup"><span data-stu-id="71ab4-123">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174

```

<span data-ttu-id="71ab4-124">Notez que cette opération tronque les valeurs à virgule flottante au lieu de les arrondir.</span><span class="sxs-lookup"><span data-stu-id="71ab4-124">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="71ab4-125">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="71ab4-125">Visual Basic 15.5</span></span>

[<span data-ttu-id="71ab4-126">Arguments nommés non placés en position de fin</span><span class="sxs-lookup"><span data-stu-id="71ab4-126">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="71ab4-127">Dans Visual Basic 15.3 et antérieur, lorsqu’un appel de méthode incluait des arguments par position et par nom, les arguments positionnels devaient précéder les arguments nommés.</span><span class="sxs-lookup"><span data-stu-id="71ab4-127">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="71ab4-128">À compter de Visual Basic 15.5, les arguments nommés et positionnels peuvent apparaître dans n’importe quel ordre, pourvu que tous les arguments jusqu'au dernier argument positionnel soient dans la position correcte.</span><span class="sxs-lookup"><span data-stu-id="71ab4-128">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="71ab4-129">C’est particulièrement utile lorsque des arguments nommés sont utilisés pour rendre le code plus lisible.</span><span class="sxs-lookup"><span data-stu-id="71ab4-129">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="71ab4-130">Par exemple, dans l’appel de méthode suivant un argument nommé est entouré de deux arguments positionnels.</span><span class="sxs-lookup"><span data-stu-id="71ab4-130">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="71ab4-131">L’argument nommé indique clairement que la valeur 19 représente un âge.</span><span class="sxs-lookup"><span data-stu-id="71ab4-131">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="71ab4-132">`Private Protected` modificateur d’accès de membre</span><span class="sxs-lookup"><span data-stu-id="71ab4-132">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="71ab4-133">Cette nouvelle combinaison de mots clés définit un membre qui est accessible par tous les membres de sa classe conteneur ainsi que par des types dérivés de la classe conteneur, mais uniquement s’ils se trouvent également dans l’assembly conteneur.</span><span class="sxs-lookup"><span data-stu-id="71ab4-133">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="71ab4-134">Étant donné que les structures ne peuvent pas être héritées, `Private Protected` peut uniquement être appliqué aux membres d’une classe.</span><span class="sxs-lookup"><span data-stu-id="71ab4-134">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="71ab4-135">**Séparateur hex/binaire/octal de début**</span><span class="sxs-lookup"><span data-stu-id="71ab4-135">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="71ab4-136">Dans Visual Basic 2017, la prise en charge du caractère de soulignement (`_`) comme séparateur numérique a été ajoutée.</span><span class="sxs-lookup"><span data-stu-id="71ab4-136">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="71ab4-137">Depuis Visual Basic 15.5, vous pouvez utiliser le caractère de soulignement comme séparateur de début entre le préfixe et les chiffres hexadécimaux, binaires ou octaux.</span><span class="sxs-lookup"><span data-stu-id="71ab4-137">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="71ab4-138">L’exemple suivant utilise un séparateur numérique de début pour définir 3,271,948,384 comme un nombre hexadécimal :</span><span class="sxs-lookup"><span data-stu-id="71ab4-138">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="71ab4-139">Pour utiliser le trait de soulignement comme séparateur de début, vous devez ajouter l’élément suivant à votre fichier projet Visual Basic (\*.vbproj) :</span><span class="sxs-lookup"><span data-stu-id="71ab4-139">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="71ab4-140">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="71ab4-140">Visual Basic 15.3</span></span>

[<span data-ttu-id="71ab4-141">**Inférence de tuple nommée**</span><span class="sxs-lookup"><span data-stu-id="71ab4-141">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="71ab4-142">Lorsque vous affectez la valeur des éléments de tuple à partir de variables, Visual Basic déduit le nom de ces éléments des noms de variables correspondants ; vous n’avez donc pas besoin de nommer explicitement un élément de tuple.</span><span class="sxs-lookup"><span data-stu-id="71ab4-142">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="71ab4-143">L’exemple suivant utilise l’inférence pour créer un tuple de trois éléments nommés, `state`, `stateName` et `capital`.</span><span class="sxs-lookup"><span data-stu-id="71ab4-143">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="71ab4-144">**Commutateurs de compilation supplémentaires**</span><span class="sxs-lookup"><span data-stu-id="71ab4-144">**Additional compiler switches**</span></span>

<span data-ttu-id="71ab4-145">Le compilateur de ligne de commande de Visual Basic prend à présent en charge les options de compilation [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) et [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) pour contrôler la sortie des assemblys de référence.</span><span class="sxs-lookup"><span data-stu-id="71ab4-145">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="71ab4-146">**-refout** définit le répertoire de sortie de l’assembly de référence, tandis que **-refonly** spécifie que la compilation doit générer uniquement un assembly de référence.</span><span class="sxs-lookup"><span data-stu-id="71ab4-146">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="71ab4-147">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="71ab4-147">Visual Basic 2017</span></span>

[<span data-ttu-id="71ab4-148">**Tuples**</span><span class="sxs-lookup"><span data-stu-id="71ab4-148">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="71ab4-149">Les tuples sont une structure de données légère qui est le plus souvent utilisée pour retourner plusieurs valeurs à partir d’un seul appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="71ab4-149">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="71ab4-150">En règle générale, pour retourner plusieurs valeurs à partir d’une méthode, vous devez effectuer l’une des opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="71ab4-150">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="71ab4-151">Définir un type personnalisé (`Class` ou `Structure`).</span><span class="sxs-lookup"><span data-stu-id="71ab4-151">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="71ab4-152">Il s’agit d’une solution lourde.</span><span class="sxs-lookup"><span data-stu-id="71ab4-152">This is a heavyweight solution.</span></span>

- <span data-ttu-id="71ab4-153">Définir un ou plusieurs paramètres `ByRef`, en plus de retourner une valeur à partir de la méthode.</span><span class="sxs-lookup"><span data-stu-id="71ab4-153">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="71ab4-154">La prise en charge des tuples par Visual Basic vous permet de définir rapidement un tuple, d’affecter éventuellement des noms de sémantique à ses valeurs et de récupérer rapidement ses valeurs.</span><span class="sxs-lookup"><span data-stu-id="71ab4-154">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="71ab4-155">L’exemple suivant encapsule un appel à la méthode <xref:System.Int32.TryParse%2A> et retourne un tuple.</span><span class="sxs-lookup"><span data-stu-id="71ab4-155">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="71ab4-156">Vous pouvez ensuite appeler la méthode et gérer le tuple retourné avec du code comme celui-ci.</span><span class="sxs-lookup"><span data-stu-id="71ab4-156">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="71ab4-157">**Littéraux binaires et séparateurs numériques**</span><span class="sxs-lookup"><span data-stu-id="71ab4-157">**Binary literals and digit separators**</span></span>

<span data-ttu-id="71ab4-158">Vous pouvez définir un littéral binaire à l’aide du préfixe `&B` ou `&b`.</span><span class="sxs-lookup"><span data-stu-id="71ab4-158">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="71ab4-159">Vous pouvez aussi utiliser le trait de soulignement, `_`, comme séparateur numérique pour améliorer la lisibilité.</span><span class="sxs-lookup"><span data-stu-id="71ab4-159">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="71ab4-160">L’exemple suivant utilise les deux fonctionnalités pour affecter une valeur `Byte` et l’afficher sous la forme d’un nombre décimal, hexadécimal et binaire.</span><span class="sxs-lookup"><span data-stu-id="71ab4-160">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="71ab4-161">Pour plus d’informations, consultez la section « Affectations de littéraux » des types de données [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) et [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments).</span><span class="sxs-lookup"><span data-stu-id="71ab4-161">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="71ab4-162">**Prise en charge des valeurs de retour de référence C#**</span><span class="sxs-lookup"><span data-stu-id="71ab4-162">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="71ab4-163">À compter de C# 7.0, C# prend en charge les valeurs de retour de référence.</span><span class="sxs-lookup"><span data-stu-id="71ab4-163">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="71ab4-164">Autrement dit, quand la méthode d’appel reçoit une valeur retournée par référence, elle peut modifier la valeur de la référence.</span><span class="sxs-lookup"><span data-stu-id="71ab4-164">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="71ab4-165">Visual Basic ne vous autorise pas à créer des méthodes avec des valeurs de retour de référence, mais vous permet d’utiliser et de modifier ces valeurs.</span><span class="sxs-lookup"><span data-stu-id="71ab4-165">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="71ab4-166">Par exemple, la classe `Sentence` suivante écrite en C# inclut une méthode `FindNext` qui recherche le mot suivant dans une phrase qui commence par une sous-chaîne spécifiée.</span><span class="sxs-lookup"><span data-stu-id="71ab4-166">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="71ab4-167">La chaîne est retournée comme valeur de retour de référence et une variable `Boolean` passée par référence à la méthode indique si la recherche a réussi.</span><span class="sxs-lookup"><span data-stu-id="71ab4-167">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="71ab4-168">Cela signifie que l’appelant peut non seulement lire la valeur retournée, mais il peut également la modifier et cette modification est répercutée dans la classe `Sentence`.</span><span class="sxs-lookup"><span data-stu-id="71ab4-168">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="71ab4-169">Sous sa forme la plus simple, vous pouvez modifier le mot trouvé dans la phrase à l’aide de code semblable au suivant.</span><span class="sxs-lookup"><span data-stu-id="71ab4-169">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="71ab4-170">Notez que vous n’affectez pas de valeur à la méthode, mais plutôt à l’expression retournée par la méthode, qui est la valeur de retour de référence.</span><span class="sxs-lookup"><span data-stu-id="71ab4-170">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="71ab4-171">Ce code pose cependant un problème : si aucune correspondance n’est trouvée, la méthode retourne le premier mot.</span><span class="sxs-lookup"><span data-stu-id="71ab4-171">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="71ab4-172">Comme l’exemple n’examine pas la valeur de l’argument `Boolean` pour déterminer si une correspondance est trouvée, il modifie le premier mot en l’absence de correspondance.</span><span class="sxs-lookup"><span data-stu-id="71ab4-172">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="71ab4-173">L’exemple suivant corrige ce comportement en remplaçant le premier mot par lui-même en l’absence de correspondance.</span><span class="sxs-lookup"><span data-stu-id="71ab4-173">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="71ab4-174">Une meilleure solution consiste à utiliser une méthode d’assistance à laquelle la valeur de retour de référence est passée par référence.</span><span class="sxs-lookup"><span data-stu-id="71ab4-174">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="71ab4-175">La méthode d’assistance peut ensuite modifier l’argument qui lui est passé par référence.</span><span class="sxs-lookup"><span data-stu-id="71ab4-175">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="71ab4-176">L’exemple suivant effectue cette opération.</span><span class="sxs-lookup"><span data-stu-id="71ab4-176">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="71ab4-177">Pour plus d’informations, consultez [Valeurs de retour de référence](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="71ab4-177">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="71ab4-178">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="71ab4-178">Visual Basic 14</span></span>

[<span data-ttu-id="71ab4-179">Nameof</span><span class="sxs-lookup"><span data-stu-id="71ab4-179">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)

<span data-ttu-id="71ab4-180">Vous pouvez obtenir le nom de chaîne non qualifié d’un type ou membre et l’utiliser dans un message d’erreur sans effectuer de codage irréversible de chaîne.</span><span class="sxs-lookup"><span data-stu-id="71ab4-180">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="71ab4-181">Votre code reste alors correct lors de la refactorisation.</span><span class="sxs-lookup"><span data-stu-id="71ab4-181">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="71ab4-182">Cette fonctionnalité est également utile pour placer des liens MVC modèle-vue-contrôleur et activer des événements de modification de propriété.</span><span class="sxs-lookup"><span data-stu-id="71ab4-182">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="71ab4-183">Interpolation de chaîne</span><span class="sxs-lookup"><span data-stu-id="71ab4-183">String interpolation</span></span>](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="71ab4-184">Vous pouvez utiliser des expressions d’interpolation de chaîne pour construire des chaînes.</span><span class="sxs-lookup"><span data-stu-id="71ab4-184">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="71ab4-185">Une expression de chaîne interpolée s’apparente à une chaîne de modèle contenant des expressions.</span><span class="sxs-lookup"><span data-stu-id="71ab4-185">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="71ab4-186">Les arguments d’une chaîne interpolée sont plus compréhensibles que dans une [Mise en forme composite](../../standard/base-types/composite-format.md).</span><span class="sxs-lookup"><span data-stu-id="71ab4-186">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>

[<span data-ttu-id="71ab4-187">Indexation et accès aux membres conditionnels Null</span><span class="sxs-lookup"><span data-stu-id="71ab4-187">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="71ab4-188">Vous pouvez rechercher les valeurs Null à l’aide d’une syntaxe très légère avant d’effectuer une opération d’accès aux membres (`?.`) ou d’indexation (`?[]`).</span><span class="sxs-lookup"><span data-stu-id="71ab4-188">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="71ab4-189">Ces opérateurs permettent d’écrire moins de code pour gérer les vérifications Null, notamment pour l’exploration des structures de données.</span><span class="sxs-lookup"><span data-stu-id="71ab4-189">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="71ab4-190">Si la référence objet ou l’opérande gauche est Null, l’opération retourne la valeur Null.</span><span class="sxs-lookup"><span data-stu-id="71ab4-190">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="71ab4-191">Littéraux de chaîne multiligne</span><span class="sxs-lookup"><span data-stu-id="71ab4-191">Multi-line string literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="71ab4-192">Les littéraux de chaîne peuvent contenir des séquences de saut de ligne.</span><span class="sxs-lookup"><span data-stu-id="71ab4-192">String literals can contain newline sequences.</span></span>  <span data-ttu-id="71ab4-193">Il n’est plus nécessaire de passer par la méthode `<xml><![CDATA[...text with newlines...]]></xml>.Value`.</span><span class="sxs-lookup"><span data-stu-id="71ab4-193">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="71ab4-194">**Commentaires**</span><span class="sxs-lookup"><span data-stu-id="71ab4-194">**Comments**</span></span>

<span data-ttu-id="71ab4-195">Vous pouvez placer des commentaires après les continuations de lignes implicites, dans les expressions d’initialiseur et dans les termes d’expression LINQ.</span><span class="sxs-lookup"><span data-stu-id="71ab4-195">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="71ab4-196">**Résolution de nom qualifié complet plus intelligente**</span><span class="sxs-lookup"><span data-stu-id="71ab4-196">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="71ab4-197">En présence de code tel que `Threading.Thread.Sleep(1000)`, Visual Basic recherchait l’espace de noms « Threading », détectait l’ambiguïté entre System.Threading et System.Windows.Threading, et signalait une erreur.</span><span class="sxs-lookup"><span data-stu-id="71ab4-197">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="71ab4-198">Visual Basic prend désormais en compte les deux espaces de noms possibles.</span><span class="sxs-lookup"><span data-stu-id="71ab4-198">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="71ab4-199">Lorsque vous affichez la liste de saisie semi-automatique, les membres de ces deux types y sont recensés par l’éditeur Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="71ab4-199">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="71ab4-200">**Littéraux de date avec année en premier**</span><span class="sxs-lookup"><span data-stu-id="71ab4-200">**Year-first date literals**</span></span>

<span data-ttu-id="71ab4-201">Vous pouvez avoir des littéraux de date au format aaaa-mm-jj, `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="71ab4-201">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="71ab4-202">**Propriétés d’interface en lecture seule**</span><span class="sxs-lookup"><span data-stu-id="71ab4-202">**Readonly interface properties**</span></span>

<span data-ttu-id="71ab4-203">Vous pouvez implémenter des propriétés d’interface en lecture seule à l’aide d’une propriété readwrite.</span><span class="sxs-lookup"><span data-stu-id="71ab4-203">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="71ab4-204">L’interface garantit les fonctionnalités minimales et n’empêche pas une classe d’implémentation d’autoriser la définition de la propriété.</span><span class="sxs-lookup"><span data-stu-id="71ab4-204">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="71ab4-205">TypeOf \<expr> IsNot \<type></span><span class="sxs-lookup"><span data-stu-id="71ab4-205">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)

<span data-ttu-id="71ab4-206">Pour une meilleure lisibilité du code, vous pouvez maintenant utiliser `TypeOf` avec `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="71ab4-206">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="71ab4-207">#Disable Warning \<ID> et #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="71ab4-207">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/index.md)

<span data-ttu-id="71ab4-208">Vous pouvez désactiver et activer des avertissements spécifiques pour les zones d’un fichier source.</span><span class="sxs-lookup"><span data-stu-id="71ab4-208">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="71ab4-209">**Améliorations de la fonctionnalité de commentaires de document XML**</span><span class="sxs-lookup"><span data-stu-id="71ab4-209">**XML doc comment improvements**</span></span>

<span data-ttu-id="71ab4-210">Lorsque vous écrivez des commentaires de document, vous bénéficiez d’un éditeur intelligent et de la prise en charge de version pour la validation des noms de paramètres, le gestion appropriée des `crefs` (génériques, opérateurs, etc.), la colorisation et la refactorisation.</span><span class="sxs-lookup"><span data-stu-id="71ab4-210">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="71ab4-211">Définitions d’interface et de module partielles</span><span class="sxs-lookup"><span data-stu-id="71ab4-211">Partial module and interface definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)

<span data-ttu-id="71ab4-212">En plus des classes et structures, vous pouvez déclarer des interfaces et des modules partiels.</span><span class="sxs-lookup"><span data-stu-id="71ab4-212">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="71ab4-213">Directives #Region dans le corps de la méthode</span><span class="sxs-lookup"><span data-stu-id="71ab4-213">#Region directives inside method bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)

<span data-ttu-id="71ab4-214">Vous pouvez placer des délimiteurs #Region…#End Region n’importe où dans un fichier, dans des fonctions, ou encore répartis à différents endroits du corps d’une fonction.</span><span class="sxs-lookup"><span data-stu-id="71ab4-214">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="71ab4-215">Les définitions de substitutions sont implicitement des surcharges</span><span class="sxs-lookup"><span data-stu-id="71ab4-215">Overrides definitions are implicitly overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)

<span data-ttu-id="71ab4-216">Si vous ajoutez le modificateur `Overrides` à une définition, le compilateur ajoute `Overloads` de manière implicite, de sorte que vous pouvez taper moins de code dans les situations courantes.</span><span class="sxs-lookup"><span data-stu-id="71ab4-216">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="71ab4-217">**CObj autorisé dans les arguments d’attributs**</span><span class="sxs-lookup"><span data-stu-id="71ab4-217">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="71ab4-218">Le compilateur signalait l’erreur indiquant que CObj(...) n’est pas une constante lorsqu’il est utilisé dans les constructions d’attribut.</span><span class="sxs-lookup"><span data-stu-id="71ab4-218">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="71ab4-219">**Déclaration et utilisation de méthodes ambiguës issues d’interfaces différentes**</span><span class="sxs-lookup"><span data-stu-id="71ab4-219">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="71ab4-220">Auparavant, le code suivant générait des erreurs qui vous empêchaient de déclarer `IMock` ou d’appeler `GetDetails` (s’ils avaient été déclarés en C#) :</span><span class="sxs-lookup"><span data-stu-id="71ab4-220">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="71ab4-221">À présent, le compilateur utilise les règles de résolution de surcharge normales pour choisir le `GetDetails` à appeler le plus approprié, et vous pouvez déclarer des relations d’interface dans Visual Basic comme indiqué dans l’exemple.</span><span class="sxs-lookup"><span data-stu-id="71ab4-221">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="71ab4-222">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="71ab4-222">See also</span></span>

- [<span data-ttu-id="71ab4-223">Nouveautés de Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="71ab4-223">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)
