---
title: Tuples dans Visual Basic
ms.date: 04/23/2017
helpviewer_keywords:
- tuples [Visual Basic]
ms.assetid: 3e66cd1b-3432-4e1d-8c37-5ebacae8f53f
ms.openlocfilehash: 146e9c2360cea153d2f487769d5b983516861e8d
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54694725"
---
# <a name="tuples-visual-basic"></a><span data-ttu-id="d7607-102">Tuples (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="d7607-102">Tuples (Visual Basic)</span></span>

<span data-ttu-id="d7607-103">À partir de Visual Basic 2017, le langage Visual Basic offre une prise en charge intégrée pour les tuples qui permet de créer des tuples et accéder aux éléments de tuples plus facile.</span><span class="sxs-lookup"><span data-stu-id="d7607-103">Starting with Visual Basic 2017, the Visual Basic language offers built-in support for tuples that makes creating tuples and accessing the elements of tuples easier.</span></span> <span data-ttu-id="d7607-104">Un tuple est une structure de données de légers qui possède un nombre spécifique et une séquence de valeurs.</span><span class="sxs-lookup"><span data-stu-id="d7607-104">A tuple is a light-weight data structure that has a specific number and sequence of values.</span></span> <span data-ttu-id="d7607-105">Lorsque vous instanciez le tuple, vous définissez le nombre et le type de données de chaque valeur (ou élément).</span><span class="sxs-lookup"><span data-stu-id="d7607-105">When you instantiate the tuple, you define the number and the data type of each value (or element).</span></span> <span data-ttu-id="d7607-106">Par exemple, un tuple de 2 (ou paire) a deux éléments.</span><span class="sxs-lookup"><span data-stu-id="d7607-106">For example, a 2-tuple (or pair) has two elements.</span></span> <span data-ttu-id="d7607-107">Le premier peut être un `Boolean` valeur, tandis que la deuxième est un `String`.</span><span class="sxs-lookup"><span data-stu-id="d7607-107">The first might be a `Boolean` value, while the second is a `String`.</span></span> <span data-ttu-id="d7607-108">Étant donné que les tuples facilitent la stocker plusieurs valeurs dans un seul objet, ils sont souvent utilisés comme un moyen léger pour retourner plusieurs valeurs à partir d’une méthode.</span><span class="sxs-lookup"><span data-stu-id="d7607-108">Because tuples make it easy to store multiple values in a single object, they are often used as a lightweight way to return multiple values from a method.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="d7607-109">Prise en charge de tuple nécessite le <xref:System.ValueTuple> type.</span><span class="sxs-lookup"><span data-stu-id="d7607-109">Tuple support requires the <xref:System.ValueTuple> type.</span></span> <span data-ttu-id="d7607-110">Si le .NET Framework 4.7 n’est pas installé, vous devez ajouter le package NuGet `System.ValueTuple`, qui est disponible dans la galerie NuGet.</span><span class="sxs-lookup"><span data-stu-id="d7607-110">If the .NET Framework 4.7 is not installed, you must add the NuGet package `System.ValueTuple`, which is available on the NuGet Gallery.</span></span> <span data-ttu-id="d7607-111">Sans ce package, vous pouvez obtenir une erreur de compilation semblable à « Type prédéfini 'ValueTuple(Of,,,)' n’est pas défini ou importé. »</span><span class="sxs-lookup"><span data-stu-id="d7607-111">Without this package, you may get a compilation error similar to, "Predefined type 'ValueTuple(Of,,,)' is not defined or imported."</span></span>

## <a name="instantiating-and-using-a-tuple"></a><span data-ttu-id="d7607-112">L’instanciation et l’utilisation d’un tuple</span><span class="sxs-lookup"><span data-stu-id="d7607-112">Instantiating and using a tuple</span></span>

<span data-ttu-id="d7607-113">Vous instanciez un tuple en plaçant ses parenthèses de messagerie instantanée de valeurs délimitée par des virgules.</span><span class="sxs-lookup"><span data-stu-id="d7607-113">You instantiate a tuple by enclosing its comma-delimited values im parentheses.</span></span> <span data-ttu-id="d7607-114">Chacune de ces valeurs devient alors un champ de tuple.</span><span class="sxs-lookup"><span data-stu-id="d7607-114">Each of those values then becomes a field of the tuple.</span></span> <span data-ttu-id="d7607-115">Par exemple, le code suivant définit un triple (ou un tuple de 3) avec un `Date` comme première valeur, un `String` en tant que le second et un `Boolean` en tant que son troisième.</span><span class="sxs-lookup"><span data-stu-id="d7607-115">For example, the following code defines a triple (or 3-tuple) with a `Date` as its first value, a `String` as its second, and a `Boolean` as its third.</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#1)]

<span data-ttu-id="d7607-116">Par défaut, le nom de chaque champ dans un tuple se compose de la chaîne `Item` , ainsi que la basée sur une position dans le tuple.</span><span class="sxs-lookup"><span data-stu-id="d7607-116">By default, the name of each field in a tuple consists of the string `Item` along with the field's one-based position in the tuple.</span></span> <span data-ttu-id="d7607-117">Pour cet élément à 3 tuples, les `Date` champ est `Item1`, le `String` champ est `Item2`et le `Boolean` champ est `Item3`.</span><span class="sxs-lookup"><span data-stu-id="d7607-117">For this 3-tuple, the `Date` field is `Item1`, the `String` field is `Item2`, and the `Boolean` field is `Item3`.</span></span> <span data-ttu-id="d7607-118">L’exemple suivant affiche les valeurs des champs du tuple instancié dans la ligne de code précédente</span><span class="sxs-lookup"><span data-stu-id="d7607-118">The following example displays the values of fields of the tuple instantiated in the previous line of code</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#2)]

<span data-ttu-id="d7607-119">Les champs d’un tuple de Visual Basic sont en lecture-écriture ; une fois que vous avez instancié un tuple, vous pouvez modifier ses valeurs.</span><span class="sxs-lookup"><span data-stu-id="d7607-119">The fields of a Visual Basic tuple are read-write; after you've instantiated a tuple, you can modify its values.</span></span> <span data-ttu-id="d7607-120">L’exemple suivant modifie deux des trois champs du tuple créé dans l’exemple précédent et affiche le résultat.</span><span class="sxs-lookup"><span data-stu-id="d7607-120">The following example modifies two of the three fields of the tuple created in the previous example and displays the result.</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#3)]

## <a name="instantiating-and-using-a-named-tuple"></a><span data-ttu-id="d7607-121">Instanciation et l’utilisation d’un tuple nommé</span><span class="sxs-lookup"><span data-stu-id="d7607-121">Instantiating and using a named tuple</span></span>

<span data-ttu-id="d7607-122">Au lieu d’utiliser des noms par défaut pour les champs d’un tuple, vous pouvez instancier un *tuple nommé* en attribuant vos propres noms aux éléments du tuple.</span><span class="sxs-lookup"><span data-stu-id="d7607-122">Rather than using default names for a tuple's fields, you can instantiate a *named tuple* by assigning your own names to the tuple's elements.</span></span> <span data-ttu-id="d7607-123">Les champs du tuple sont ensuite accessible par leurs noms assignés *ou* par leurs noms par défaut.</span><span class="sxs-lookup"><span data-stu-id="d7607-123">The tuple's fields can then be accessed by their assigned names *or* by their default names.</span></span> <span data-ttu-id="d7607-124">L’exemple suivant instancie le tuple de 3 même que précédemment, à ceci près qu’il nomme explicitement le premier champ `EventDate`, le deuxième `Name`et le troisième `IsHoliday`.</span><span class="sxs-lookup"><span data-stu-id="d7607-124">The following example instantiates the same 3-tuple as previously, except that it explicitly names the first field `EventDate`, the second `Name`, and the third `IsHoliday`.</span></span> <span data-ttu-id="d7607-125">Il affiche les valeurs de champ, les modifie et affiche les valeurs de champ à nouveau.</span><span class="sxs-lookup"><span data-stu-id="d7607-125">It then displays the field values, modifies them, and displays the field values again.</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#4)]

## <a name="inferred-tuple-element-names"></a><span data-ttu-id="d7607-126">Noms des éléments de tuple inférés</span><span class="sxs-lookup"><span data-stu-id="d7607-126">Inferred tuple element names</span></span>

<span data-ttu-id="d7607-127">À partir de Visual Basic 15.3, Visual Basic peut déduire les noms d’éléments de tuple ; Il est inutile de les affecter explicitement.</span><span class="sxs-lookup"><span data-stu-id="d7607-127">Starting with Visual Basic 15.3, Visual Basic can infer the names of tuple elements; you do not have to assign them explicitly.</span></span> <span data-ttu-id="d7607-128">Noms de tuple déduits sont utiles lorsque vous initialisez un tuple à partir d’un ensemble de variables, et vous souhaitez que le nom d’élément de tuple pour être le même que le nom de variable.</span><span class="sxs-lookup"><span data-stu-id="d7607-128">Inferred tuple names are useful when you initialize a tuple from a set of variables, and you want the tuple element name to be the same as the variable name.</span></span> 

<span data-ttu-id="d7607-129">L’exemple suivant crée un `stateInfo` tuple qui contient trois explicitement des éléments, nommés `state`, `stateName`, et `capital`.</span><span class="sxs-lookup"><span data-stu-id="d7607-129">The following example creates a `stateInfo` tuple that contains three explicitly named elements, `state`, `stateName`, and `capital`.</span></span> <span data-ttu-id="d7607-130">Notez que, pour nommer les éléments, l’instruction d’initialisation de tuple attribue simplement les éléments nommés les valeurs des variables portant le même nommés.</span><span class="sxs-lookup"><span data-stu-id="d7607-130">Note that, in naming the elements, the tuple initialization statement simply assigns the named elements the values of the identically named variables.</span></span>

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#1)]
 
<span data-ttu-id="d7607-131">Étant donné que les éléments et les variables ont le même nom, le compilateur Visual Basic peut déduire les noms des champs, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="d7607-131">Because elements and variables have the same name, the Visual Basic compiler can infer the names of the fields, as the following example shows.</span></span>

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="d7607-132">Pour activer les noms d’éléments de tuple déduits, vous devez définir la version du compilateur Visual Basic à utiliser dans votre projet Visual Basic (\*.vbproj) fichier :</span><span class="sxs-lookup"><span data-stu-id="d7607-132">To enable inferred tuple element names, you must define the version of the Visual Basic compiler to use in your Visual Basic project (\*.vbproj) file:</span></span> 

```xml 
<PropertyGroup> 
  <LangVersion>15.3</LangVersion> 
</PropertyGroup> 
```

<span data-ttu-id="d7607-133">Le numéro de version peut être n’importe quelle version du compilateur Visual Basic 15.3 à compter.</span><span class="sxs-lookup"><span data-stu-id="d7607-133">The version number can be any version of the Visual Basic compiler starting with 15.3.</span></span> <span data-ttu-id="d7607-134">Au lieu de coder en dur une version de compilateur spécifique, vous pouvez également spécifier « Latest » comme valeur de `LangVersion` compiler avec la version la plus récente du compilateur Visual Basic installé sur votre système.</span><span class="sxs-lookup"><span data-stu-id="d7607-134">Rather than hard-coding a specific compiler version, you can also specify "Latest" as the value of `LangVersion` to compile with the most recent version of the Visual Basic compiler installed on your system.</span></span>

<span data-ttu-id="d7607-135">Pour plus d’informations, consultez [définition de la version de langage Visual Basic](../../../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="d7607-135">For more information, see [setting the Visual Basic language version](../../../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="d7607-136">Dans certains cas, le compilateur Visual Basic ne peut pas déduire le nom d’élément de tuple à partir du nom de candidat, et le champ de tuple ne peut être référencé à l’aide de son nom par défaut, tel que `Item1`, `Item2`, etc. Elles incluent notamment :</span><span class="sxs-lookup"><span data-stu-id="d7607-136">In some cases, the Visual Basic compiler cannot infer the tuple element name from the candidate name, and the tuple field can only be referenced using its default name, such as `Item1`, `Item2`, etc. These include:</span></span>

- <span data-ttu-id="d7607-137">Le nom du candidat est le même que le nom d’un membre de tuple, tel que `Item3`, `Rest`, ou `ToString`.</span><span class="sxs-lookup"><span data-stu-id="d7607-137">The candidate name is the same as the name of a tuple member, such as `Item3`, `Rest`, or `ToString`.</span></span>

- <span data-ttu-id="d7607-138">Le nom du candidat est dupliqué dans le tuple.</span><span class="sxs-lookup"><span data-stu-id="d7607-138">The candidate name is duplicated in the tuple.</span></span>
 
<span data-ttu-id="d7607-139">En cas d’échec de l’inférence de nom de champ, Visual Basic ne génère pas d’une erreur du compilateur ni est une exception levée lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="d7607-139">When field name inference fails, Visual Basic does not generate a compiler error, nor is an exception thrown at runtime.</span></span> <span data-ttu-id="d7607-140">Au lieu de cela, les champs de tuple doivent être référencées par leurs noms prédéfinis, tels que `Item1` et `Item2`.</span><span class="sxs-lookup"><span data-stu-id="d7607-140">Instead, tuple fields must be referenced by their predefined names, such as `Item1` and `Item2`.</span></span> 
  
## <a name="tuples-versus-structures"></a><span data-ttu-id="d7607-141">Tuples et structures</span><span class="sxs-lookup"><span data-stu-id="d7607-141">Tuples versus structures</span></span>

<span data-ttu-id="d7607-142">Un tuple de Visual Basic est un type valeur qui est une instance de l’un de l’un **System.ValueTuple** types génériques.</span><span class="sxs-lookup"><span data-stu-id="d7607-142">A Visual Basic tuple is a value type that is an instance of one of the a **System.ValueTuple** generic types.</span></span> <span data-ttu-id="d7607-143">Par exemple, le `holiday` tuple défini dans l’exemple précédent est une instance de la <xref:System.ValueTuple%603> structure.</span><span class="sxs-lookup"><span data-stu-id="d7607-143">For example, the `holiday` tuple defined in the previous example is an instance of the <xref:System.ValueTuple%603> structure.</span></span> <span data-ttu-id="d7607-144">Il est conçu pour être un conteneur léger pour les données.</span><span class="sxs-lookup"><span data-stu-id="d7607-144">It is designed to be a lightweight container for data.</span></span> <span data-ttu-id="d7607-145">Étant donné que le tuple vise à rendre facile de créer un objet avec plusieurs éléments de données, il lui manque certaines fonctionnalités susceptibles de présenter une structure personnalisée.</span><span class="sxs-lookup"><span data-stu-id="d7607-145">Since the tuple aims to make it easy to create an object with multiple data items, it lacks some of the features that a custom structure might have.</span></span> <span data-ttu-id="d7607-146">Elles incluent notamment :</span><span class="sxs-lookup"><span data-stu-id="d7607-146">These include:</span></span>

- <span data-ttu-id="d7607-147">Membres personnalisés.</span><span class="sxs-lookup"><span data-stu-id="d7607-147">Custom members.</span></span> <span data-ttu-id="d7607-148">Vous ne pouvez pas définir vos propres propriétés, des méthodes ou événements d’un tuple.</span><span class="sxs-lookup"><span data-stu-id="d7607-148">You cannot define your own properties, methods, or events for a tuple.</span></span>

- <span data-ttu-id="d7607-149">Validation.</span><span class="sxs-lookup"><span data-stu-id="d7607-149">Validation.</span></span> <span data-ttu-id="d7607-150">Vous ne pouvez pas valider les données assignées aux champs.</span><span class="sxs-lookup"><span data-stu-id="d7607-150">You cannot validate the data assigned to fields.</span></span>

- <span data-ttu-id="d7607-151">Immuabilité.</span><span class="sxs-lookup"><span data-stu-id="d7607-151">Immutability.</span></span> <span data-ttu-id="d7607-152">Les tuples de Visual Basic sont mutables.</span><span class="sxs-lookup"><span data-stu-id="d7607-152">Visual Basic tuples are mutable.</span></span> <span data-ttu-id="d7607-153">En revanche, une structure personnalisée permet de contrôler si une instance est mutable ou immuable.</span><span class="sxs-lookup"><span data-stu-id="d7607-153">In contrast, a custom structure allows you to control whether an instance is mutable or immutable.</span></span>

<span data-ttu-id="d7607-154">Si des membres personnalisés, la propriété et la validation de champ ou immuabilité est importante, vous devez utiliser Visual Basic [Structure](../../../language-reference/statements/structure-statement.md) instruction pour définir un type de valeur personnalisée.</span><span class="sxs-lookup"><span data-stu-id="d7607-154">If custom members, property and field validation, or immutability are important, you should use the Visual Basic [Structure](../../../language-reference/statements/structure-statement.md) statement to define a custom value type.</span></span>

<span data-ttu-id="d7607-155">Un tuple de Visual Basic n’hérite pas les membres de son **ValueTuple** type.</span><span class="sxs-lookup"><span data-stu-id="d7607-155">A Visual Basic tuple does inherit the members of its **ValueTuple** type.</span></span> <span data-ttu-id="d7607-156">En plus de ses champs, citons notamment les méthodes suivantes :</span><span class="sxs-lookup"><span data-stu-id="d7607-156">In addition to its fields, these include the following methods:</span></span>

| <span data-ttu-id="d7607-157">Membre</span><span class="sxs-lookup"><span data-stu-id="d7607-157">Member</span></span> | <span data-ttu-id="d7607-158">Description</span><span class="sxs-lookup"><span data-stu-id="d7607-158">Description</span></span> |
| ---|---|
| <span data-ttu-id="d7607-159">CompareTo</span><span class="sxs-lookup"><span data-stu-id="d7607-159">CompareTo</span></span> | <span data-ttu-id="d7607-160">Compare le tuple actuel à un autre tuple avec le même nombre d’éléments.</span><span class="sxs-lookup"><span data-stu-id="d7607-160">Compares the current tuple to another tuple with the same number of elements.</span></span> |
| <span data-ttu-id="d7607-161">Equals</span><span class="sxs-lookup"><span data-stu-id="d7607-161">Equals</span></span> | <span data-ttu-id="d7607-162">Détermine si le tuple actuel est égal à un autre objet ou de tuple.</span><span class="sxs-lookup"><span data-stu-id="d7607-162">Determines whether the current tuple is equal to another tuple or object.</span></span> |
| <span data-ttu-id="d7607-163">GetHashCode</span><span class="sxs-lookup"><span data-stu-id="d7607-163">GetHashCode</span></span> | <span data-ttu-id="d7607-164">Calcule le code de hachage pour l’instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="d7607-164">Calculates the hash code for the current instance.</span></span> |
| <span data-ttu-id="d7607-165">ToString</span><span class="sxs-lookup"><span data-stu-id="d7607-165">ToString</span></span> | <span data-ttu-id="d7607-166">Retourne la représentation sous forme de chaîne de ce tuple, qui prend la forme `(Item1, Item2...)`, où `Item1` et `Item2` représentent les valeurs des champs du tuple.</span><span class="sxs-lookup"><span data-stu-id="d7607-166">Returns the string representation of this tuple, which takes the form `(Item1, Item2...)`, where `Item1` and `Item2` represent the values of the tuple's fields.</span></span> |

<span data-ttu-id="d7607-167">En outre, le **ValueTuple** types implémentent <xref:System.Collections.IStructuralComparable> et <xref:System.Collections.IStructuralEquatable> interfaces, ce qui vous permet de définir des comparateurs de client.</span><span class="sxs-lookup"><span data-stu-id="d7607-167">In addition, the **ValueTuple** types implement <xref:System.Collections.IStructuralComparable> and <xref:System.Collections.IStructuralEquatable> interfaces, which allow you to define customer comparers.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="d7607-168">Affectation et tuples</span><span class="sxs-lookup"><span data-stu-id="d7607-168">Assignment and tuples</span></span>

<span data-ttu-id="d7607-169">Visual Basic prend en charge l’assignation entre types tuple qui ont le même nombre de champs.</span><span class="sxs-lookup"><span data-stu-id="d7607-169">Visual Basic supports assignment between tuple types that have the same number of fields.</span></span> <span data-ttu-id="d7607-170">Les types de champs peuvent être converties si une des opérations suivantes est vraie :</span><span class="sxs-lookup"><span data-stu-id="d7607-170">The field types can be converted if one of the following is true:</span></span>

- <span data-ttu-id="d7607-171">Le champ source et cible sont du même type.</span><span class="sxs-lookup"><span data-stu-id="d7607-171">The source and target field are of the same type.</span></span>

- <span data-ttu-id="d7607-172">Une conversion étendue (ou implicite) du type source vers le type cible est définie.</span><span class="sxs-lookup"><span data-stu-id="d7607-172">A widening (or implicit) conversion of the source type to the target type is defined.</span></span> 

- <span data-ttu-id="d7607-173">`Option Strict` est `On`, et une conversion restrictive (ou explicite) du type source vers le type cible est définie.</span><span class="sxs-lookup"><span data-stu-id="d7607-173">`Option Strict` is `On`, and a narrowing (or explicit) conversion of the source type to the target type is defined.</span></span> <span data-ttu-id="d7607-174">Cette conversion peut lever une exception si la valeur source est en dehors de la plage du type cible.</span><span class="sxs-lookup"><span data-stu-id="d7607-174">This conversion can throw an exception if the source value is outside the range of the target type.</span></span>

<span data-ttu-id="d7607-175">Les autres conversions ne sont pas prises en compte pour les affectations.</span><span class="sxs-lookup"><span data-stu-id="d7607-175">Other conversions are not considered for assignments.</span></span> <span data-ttu-id="d7607-176">Examinons les types d’affectation qui sont autorisés entre les types tuple.</span><span class="sxs-lookup"><span data-stu-id="d7607-176">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="d7607-177">Prenez en compte les variables utilisées dans les exemples suivants :</span><span class="sxs-lookup"><span data-stu-id="d7607-177">Consider these variables used in the following examples:</span></span>

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#1)]

<span data-ttu-id="d7607-178">Les deux premières variables, `unnamed` et `anonymous`, n’ont pas de noms sémantiques fournis pour les champs.</span><span class="sxs-lookup"><span data-stu-id="d7607-178">The first two variables, `unnamed` and `anonymous`, do not have semantic names provided for the fields.</span></span> <span data-ttu-id="d7607-179">Leurs noms de champ sont la valeur par défaut `Item1` et `Item2`.</span><span class="sxs-lookup"><span data-stu-id="d7607-179">Their field names are the default `Item1` and `Item2`.</span></span> <span data-ttu-id="d7607-180">Les deux dernières variables, `named` et `differentName` ont des noms de champ sémantique.</span><span class="sxs-lookup"><span data-stu-id="d7607-180">The last two variables, `named` and `differentName` have semantic field names.</span></span> <span data-ttu-id="d7607-181">Notez que ces deux tuples ont des noms différents pour les champs.</span><span class="sxs-lookup"><span data-stu-id="d7607-181">Note that these two tuples have different names for the fields.</span></span>

<span data-ttu-id="d7607-182">Ces quatre tuples ont le même nombre de champs (également appelé « arité »), et les types de ces champs sont identiques.</span><span class="sxs-lookup"><span data-stu-id="d7607-182">All four of these tuples have the same number of fields (referred to as 'arity'), and the types of those fields are identical.</span></span> <span data-ttu-id="d7607-183">Par conséquent, toutes ces affectations fonctionnent :</span><span class="sxs-lookup"><span data-stu-id="d7607-183">Therefore, all of these assignments work:</span></span>

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#2)]

<span data-ttu-id="d7607-184">Notez que les noms des tuples ne sont pas affectés.</span><span class="sxs-lookup"><span data-stu-id="d7607-184">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="d7607-185">Les valeurs des champs sont affectées suivant l’ordre des champs dans le tuple.</span><span class="sxs-lookup"><span data-stu-id="d7607-185">The values of the fields are assigned following the order of the fields in the tuple.</span></span>

<span data-ttu-id="d7607-186">Enfin, notez que nous pouvons attribuer le `named` tuple à la `conversion` tuple, même si le premier champ de `named` est un `Integer`et le premier champ de `conversion` est un `Long`.</span><span class="sxs-lookup"><span data-stu-id="d7607-186">Finally, notice that we can assign the `named` tuple to the `conversion` tuple, even though the first field of `named` is an `Integer`, and the first field of `conversion` is a `Long`.</span></span> <span data-ttu-id="d7607-187">Cette assignation réussit, car la conversion d’un `Integer` à un `Long` est une conversion étendue.</span><span class="sxs-lookup"><span data-stu-id="d7607-187">This assignment succeeds because converting an `Integer` to a `Long` is a widening conversion.</span></span>

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#3)]

<span data-ttu-id="d7607-188">Tuples avec différents nombres de champs ne sont pas attribuables :</span><span class="sxs-lookup"><span data-stu-id="d7607-188">Tuples with different numbers of fields are not assignable:</span></span>

```vb
' Does not compile.
' VB30311: Value of type '(Integer, Integer, Integer)' cannot be converted
'          to '(Answer As Integer, Message As String)'
var differentShape = (1, 2, 3)
named = differentShape
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="d7607-189">Tuples comme valeurs de retour de méthode</span><span class="sxs-lookup"><span data-stu-id="d7607-189">Tuples as method return values</span></span>

<span data-ttu-id="d7607-190">Une méthode peut retourner une seule valeur.</span><span class="sxs-lookup"><span data-stu-id="d7607-190">A method can return only a single value.</span></span> <span data-ttu-id="d7607-191">Fréquemment, cependant, vous souhaitez un appel de méthode pour retourner plusieurs valeurs.</span><span class="sxs-lookup"><span data-stu-id="d7607-191">Frequently, though, you'd like a method call to return multiple values.</span></span> <span data-ttu-id="d7607-192">Il existe plusieurs façons de contourner cette limitation :</span><span class="sxs-lookup"><span data-stu-id="d7607-192">There are several ways to work around this limitation:</span></span>

- <span data-ttu-id="d7607-193">Vous pouvez créer une classe personnalisée ou une structure dont les propriétés ou champs représentent les valeurs retournées par la méthode.</span><span class="sxs-lookup"><span data-stu-id="d7607-193">You can create a custom class or structure whose properties or fields represent values returned by the method.</span></span> <span data-ttu-id="d7607-194">Par conséquent, est une solution lourde ; elle nécessite que vous définissez un type personnalisé dont le seul but est de récupérer des valeurs à partir d’un appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="d7607-194">Thus is a heavyweight solution; it requires that you define a custom type whose only purpose is to retrieve values from a method call.</span></span>

- <span data-ttu-id="d7607-195">Vous pouvez retourner une valeur unique à partir de la méthode et renvoyer les valeurs restantes en les passant par référence à la méthode.</span><span class="sxs-lookup"><span data-stu-id="d7607-195">You can return a single value from the method, and return the remaining values by passing them by reference to the method.</span></span> <span data-ttu-id="d7607-196">Cela implique le traitement de l’instanciation d’une variable et des risques par inadvertance en remplaçant la valeur de la variable que vous passez par référence.</span><span class="sxs-lookup"><span data-stu-id="d7607-196">This involves the overhead of instantiating a variable and risks inadvertently overwriting the value of the variable that you pass by reference.</span></span>

- <span data-ttu-id="d7607-197">Vous pouvez utiliser un tuple, qui fournit une solution légère à la récupération de plusieurs valeurs de retour.</span><span class="sxs-lookup"><span data-stu-id="d7607-197">You can use a tuple, which provides a lightweight solution to retrieving multiple return values.</span></span>

<span data-ttu-id="d7607-198">Par exemple, le **TryParse** méthodes de retour de .NET un `Boolean` valeur qui indique si l’opération d’analyse a réussi.</span><span class="sxs-lookup"><span data-stu-id="d7607-198">For example, the **TryParse** methods in .NET return a `Boolean` value that indicates whether the parsing operation succeeded.</span></span> <span data-ttu-id="d7607-199">Le résultat de l’opération d’analyse est retourné dans une variable passée par référence à la méthode.</span><span class="sxs-lookup"><span data-stu-id="d7607-199">The result of the parsing operation is returned in a variable passed by reference to the method.</span></span> <span data-ttu-id="d7607-200">Normalement, un appel à la méthode d’analyse comme <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> ressemble à ceci :</span><span class="sxs-lookup"><span data-stu-id="d7607-200">Normally, a call to the a parsing method such as <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> looks like the following:</span></span>

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#1)]

<span data-ttu-id="d7607-201">Nous pouvons retourner un tuple à partir de l’opération d’analyse, si nous encapsuler l’appel à la <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> méthode dans notre propre méthode.</span><span class="sxs-lookup"><span data-stu-id="d7607-201">We can return a tuple from the parsing operation if we wrap the call to the <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> method in our own method.</span></span> <span data-ttu-id="d7607-202">Dans l’exemple suivant, `NumericLibrary.ParseInteger` appelle le <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> méthode et retourne un tuple nommé avec deux éléments.</span><span class="sxs-lookup"><span data-stu-id="d7607-202">In the following example, `NumericLibrary.ParseInteger` calls the <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> method and returns a named tuple with two elements.</span></span> 

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="d7607-203">Vous pouvez ensuite appeler la méthode avec un code semblable au suivant :</span><span class="sxs-lookup"><span data-stu-id="d7607-203">You can then call the method with code like the following:</span></span>

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

## <a name="visual-basic-tuples-and-tuples-in-the-net-framework"></a><span data-ttu-id="d7607-204">Les tuples de Visual Basic et les tuples dans le .NET Framework</span><span class="sxs-lookup"><span data-stu-id="d7607-204">Visual Basic tuples and tuples in the .NET Framework</span></span>

<span data-ttu-id="d7607-205">Un tuple de Visual Basic est une instance de l’un de le **System.ValueTuple** des types génériques, qui ont été introduits dans le .NET Framework 4.7.</span><span class="sxs-lookup"><span data-stu-id="d7607-205">A Visual Basic tuple is an instance of one of the **System.ValueTuple** generic types, which were introduced in the .NET Framework 4.7.</span></span> <span data-ttu-id="d7607-206">Le .NET Framework inclut également un ensemble de génériques **System.Tuple** classes.</span><span class="sxs-lookup"><span data-stu-id="d7607-206">The .NET Framework also includes a set of generic **System.Tuple** classes.</span></span> <span data-ttu-id="d7607-207">Ces classes, toutefois, diffèrent des tuples de Visual Basic et le **System.ValueTuple** des types génériques dans une de plusieurs façons :</span><span class="sxs-lookup"><span data-stu-id="d7607-207">These classes, however, differ from Visual Basic tuples and the **System.ValueTuple** generic types in a number of ways:</span></span>

- <span data-ttu-id="d7607-208">Les éléments de la **Tuple** classes sont des propriétés nommées `Item1`, `Item2`, et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="d7607-208">The elements of the **Tuple** classes are properties named `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="d7607-209">Dans Visual Basic tuples et les **ValueTuple** types, les éléments de tuple sont des champs.</span><span class="sxs-lookup"><span data-stu-id="d7607-209">In Visual Basic tuples and the **ValueTuple** types, tuple elements are fields.</span></span>

- <span data-ttu-id="d7607-210">Impossible d’assigner des noms significatifs pour les éléments d’un **Tuple** instance ou d’un **ValueTuple** instance.</span><span class="sxs-lookup"><span data-stu-id="d7607-210">You cannot assign meaningful names to the elements of a **Tuple** instance or of a **ValueTuple** instance.</span></span> <span data-ttu-id="d7607-211">Visual Basic vous permet d’attribuer des noms qui communiquent la signification des champs.</span><span class="sxs-lookup"><span data-stu-id="d7607-211">Visual Basic allows you to assign names that communicate the meaning of the fields.</span></span>

- <span data-ttu-id="d7607-212">Les propriétés d’un **Tuple** instance sont en lecture seule ; les tuples sont immuables.</span><span class="sxs-lookup"><span data-stu-id="d7607-212">The properties of a **Tuple** instance are read-only; the tuples are immutable.</span></span> <span data-ttu-id="d7607-213">Dans Visual Basic tuples et les **ValueTuple** , types de champs de tuple sont en lecture-écriture ; les tuples sont mutables.</span><span class="sxs-lookup"><span data-stu-id="d7607-213">In Visual Basic tuples and the **ValueTuple** types, tuple fields are read-write; the tuples are mutable.</span></span>

- <span data-ttu-id="d7607-214">Le modèle générique **Tuple** types sont des types référence.</span><span class="sxs-lookup"><span data-stu-id="d7607-214">The generic **Tuple** types are reference types.</span></span> <span data-ttu-id="d7607-215">L’utilisation de ces **Tuple** signifie allouer des objets de types.</span><span class="sxs-lookup"><span data-stu-id="d7607-215">Using these **Tuple** types means allocating objects.</span></span> <span data-ttu-id="d7607-216">Sur des chemins réactifs, cela peut avoir un impact mesurable sur les performances de votre application.</span><span class="sxs-lookup"><span data-stu-id="d7607-216">On hot paths, this can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="d7607-217">Les tuples de Visual Basic et le **ValueTuple** types sont des types valeur.</span><span class="sxs-lookup"><span data-stu-id="d7607-217">Visual Basic tuples and the **ValueTuple** types are value types.</span></span>

<span data-ttu-id="d7607-218">Méthodes d’extension dans le <xref:System.TupleExtensions> classe facilitent la conversion entre des tuples de Visual Basic et .NET **Tuple** objets.</span><span class="sxs-lookup"><span data-stu-id="d7607-218">Extension methods in the <xref:System.TupleExtensions> class make it easy to convert between Visual Basic tuples and .NET **Tuple** objects.</span></span> <span data-ttu-id="d7607-219">Le **ToTuple** méthode convertit un tuple de Visual Basic .NET **Tuple** objet et le **ToValueTuple** méthode convertit un .NET **Tuple** objet à un tuple de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="d7607-219">The **ToTuple** method converts a Visual Basic tuple to a .NET **Tuple** object, and the **ToValueTuple** method converts a .NET **Tuple** object to a Visual Basic tuple.</span></span>

<span data-ttu-id="d7607-220">L’exemple suivant crée un tuple, le convertit en un .NET **Tuple** objet et convertit refaites-le en un tuple de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="d7607-220">The following example creates a tuple, converts it to a .NET **Tuple** object, and converts it back to a Visual Basic tuple.</span></span> <span data-ttu-id="d7607-221">L’exemple compare ensuite ce tuple avec celui d’origine pour vous assurer qu’ils sont égaux.</span><span class="sxs-lookup"><span data-stu-id="d7607-221">The example then compares this tuple with the original one to ensure that they are equal.</span></span>

[!code-vb[Convert](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple2.vb#1)]

## <a name="see-also"></a><span data-ttu-id="d7607-222">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="d7607-222">See also</span></span>

- [<span data-ttu-id="d7607-223">Informations de référence sur le langage Visual Basic</span><span class="sxs-lookup"><span data-stu-id="d7607-223">Visual Basic Language Reference</span></span>](index.md)
