---
title: Mappage entre JSON et XML
ms.date: 03/30/2017
ms.assetid: 22ee1f52-c708-4024-bbf0-572e0dae64af
ms.openlocfilehash: ef5eaac8fc75149ac518ce322808a84bbab5506b
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/15/2019
ms.locfileid: "65636433"
---
# <a name="mapping-between-json-and-xml"></a><span data-ttu-id="9cdcd-102">Mappage entre JSON et XML</span><span class="sxs-lookup"><span data-stu-id="9cdcd-102">Mapping Between JSON and XML</span></span>
<span data-ttu-id="9cdcd-103">Les lecteurs et writers produits par le <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> fournissent une API XML sur le contenu de JavaScript Objet Notation (JSON).</span><span class="sxs-lookup"><span data-stu-id="9cdcd-103">The readers and writers produced by the <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> provide an XML API over JavaScript Object Notation (JSON) content.</span></span> <span data-ttu-id="9cdcd-104">JSON encode des données à l'aide d'un sous-ensemble de littéraux d'objet JavaScript.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-104">JSON encodes data using a subset of the object literals of JavaScript.</span></span> <span data-ttu-id="9cdcd-105">Les lecteurs et writers produits par cette fabrique sont également utilisés lorsque le contenu JSON est envoyé ou reçu par les applications Windows Communication Foundation (WCF) à l’aide de la <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> ou le <xref:System.ServiceModel.WebHttpBinding>.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-105">The readers and writers produced by this factory are also used when JSON content is being sent or received by Windows Communication Foundation (WCF) applications using the <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> or the <xref:System.ServiceModel.WebHttpBinding>.</span></span>

<span data-ttu-id="9cdcd-106">En cas d'initialisation avec le contenu JSON, le lecteur JSON se comporte de la même façon qu'un lecteur XML textuel sur une instance de XML.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-106">When initialized with JSON content, the JSON reader behaves in the same way that a textual XML reader does over an instance of XML.</span></span> <span data-ttu-id="9cdcd-107">Le writer JSON, lorsqu'il reçoit une séquence d'appels qui sur un lecteur XML textuel produit une certaine instance XML, écrit un contenu JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-107">The JSON writer, when given a sequence of calls that on a textual XML reader produces a certain XML instance, writes out JSON content.</span></span> <span data-ttu-id="9cdcd-108">Le mappage entre cette instance de XML et le contenu JSON est décrit dans cette rubrique pour une utilisation dans des scénarios avancés.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-108">The mapping between this instance of XML and the JSON content is described in this topic for use in advanced scenarios.</span></span>

<span data-ttu-id="9cdcd-109">En interne, JSON est représenté comme un infoset XML lors du traitement par WCF.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-109">Internally, JSON is represented as an XML infoset when processed by WCF.</span></span> <span data-ttu-id="9cdcd-110">Normalement vous n’êtes pas obligé de se préoccuper de cette représentation interne, car le mappage n’est seulement une logique : JSON est normalement pas physiquement converti au format XML en mémoire ou converti au format JSON à partir de XML.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-110">Normally you do not have to be concerned with this internal representation as the mapping is only a logical one: JSON is normally not physically converted to XML in memory or converted to JSON from XML.</span></span> <span data-ttu-id="9cdcd-111">Le mappage signifie que les API XML sont utilisées pour accéder au contenu JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-111">The mapping means that XML APIs are used to access JSON content.</span></span>

<span data-ttu-id="9cdcd-112">Lorsque WCF utilise JSON, le scénario habituel est que le <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> est branché automatiquement par le <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> comportement, ou par le <xref:System.ServiceModel.Description.WebHttpBehavior> comportement lorsque cela est approprié.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-112">When WCF uses JSON, the usual scenario is that the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> is automatically plugged in by the <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> behavior, or by the <xref:System.ServiceModel.Description.WebHttpBehavior> behavior when appropriate.</span></span> <span data-ttu-id="9cdcd-113">Le <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> comprend le mappage entre JSON et les jeux d'informations XML et fonctionne comme s'il traite directement avec JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-113">The <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly.</span></span> <span data-ttu-id="9cdcd-114">(Il est possible d'utiliser le <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> avec tout lecteur ou writer XML à condition que le XML se conforme au mappage suivant).</span><span class="sxs-lookup"><span data-stu-id="9cdcd-114">(It is possible to use the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)</span></span>

<span data-ttu-id="9cdcd-115">Dans les scénarios avancés, il peut devenir nécessaire d'accéder directement au mappage suivant.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-115">In advanced scenarios, it may become necessary to directly access the following mapping.</span></span> <span data-ttu-id="9cdcd-116">Ces scénarios se produisent lorsque vous souhaitez sérialiser et désérialiser JSON de manières personnalisées, sans avoir à compter sur le <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, ou lors d'un traitement direct avec le type <xref:System.ServiceModel.Channels.Message> pour les messages qui contiennent JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-116">These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, or when dealing with the <xref:System.ServiceModel.Channels.Message> type directly for messages containing JSON.</span></span> <span data-ttu-id="9cdcd-117">Le mappage JSON-XML est également utilisé pour l'enregistrement des messages.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-117">The JSON-XML mapping is also used for message logging.</span></span> <span data-ttu-id="9cdcd-118">Lorsque vous utilisez la fonctionnalité de journalisation des messages dans WCF, les messages JSON sont enregistrés au format XML selon le mappage décrit dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-118">When using the message logging feature in WCF, JSON messages is logged as XML according to the mapping described in the next section.</span></span>

<span data-ttu-id="9cdcd-119">Pour clarifier le concept d'un mappage, l'exemple suivant est celui d'un document JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-119">To clarify the concept of a mapping, the following example is of a JSON document.</span></span>

```json
{"product":"pencil","price":12}
```

<span data-ttu-id="9cdcd-120">Pour lire ce document JSON à l'aide de l'un des lecteurs évoqués précédemment, utilisez la même séquence d'appels <xref:System.Xml.XmlDictionaryReader> que pour lire le document XML suivant.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-120">To read this JSON document using one of the readers previously mentioned, use the same sequence of <xref:System.Xml.XmlDictionaryReader> calls as you would to read the following XML document.</span></span>

```xml
<root type="object">
    <product type="string">pencil</product>
    <price type="number">12</price>
</root>
```

<span data-ttu-id="9cdcd-121">En outre, si le message JSON dans l’exemple est reçu par WCF et connecté, vous voyez le fragment XML dans le journal précédent.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-121">Furthermore, if the JSON message in the example is received by WCF and logged, you would see the XML fragment in the preceding log.</span></span>

## <a name="mapping-between-json-and-the-xml-infoset"></a><span data-ttu-id="9cdcd-122">Mappage entre JSON et le jeu d'informations XML</span><span class="sxs-lookup"><span data-stu-id="9cdcd-122">Mapping Between JSON and the XML Infoset</span></span>
<span data-ttu-id="9cdcd-123">Formellement, le mappage se fait entre JSON comme décrit dans [RFC 4627](https://go.microsoft.com/fwlink/?LinkId=98808) (sauf avec certaines restrictions assouplies et autres restrictions ajoutées) et le code XML infoset (et pas XML textuel) comme décrit dans [informations XML Définir](https://go.microsoft.com/fwlink/?LinkId=98809) .</span><span class="sxs-lookup"><span data-stu-id="9cdcd-123">Formally, the mapping is between JSON as described in [RFC 4627](https://go.microsoft.com/fwlink/?LinkId=98808) (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in [XML Information Set](https://go.microsoft.com/fwlink/?LinkId=98809) .</span></span> <span data-ttu-id="9cdcd-124">Consultez cette rubrique pour les définitions des *éléments d’information* et champs entre [crochets].</span><span class="sxs-lookup"><span data-stu-id="9cdcd-124">See this topic for the definitions of *information items* and fields in [square brackets].</span></span>

<span data-ttu-id="9cdcd-125">Un document JSON vierge est mappé à un document XML vide, et un document XML vierge est mappé à un document JSON vierge.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-125">A blank JSON document maps to a blank XML document, and a blank XML document maps to a blank JSON document.</span></span> <span data-ttu-id="9cdcd-126">Sur le mappage XML à JSON, qui précède un espace blanc et d’espace blanc de fin après le document ne sont pas autorisés.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-126">On the XML to JSON mapping, preceding white space and trailing white space after the document are not allowed.</span></span>

<span data-ttu-id="9cdcd-127">Le mappage est défini entre un élément DII (Document Information Item) ou un élément EII (Element Information Item) et JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-127">The mapping is defined between either a Document Information Item (DII) or an Element Information Item (EII) and JSON.</span></span> <span data-ttu-id="9cdcd-128">L'élément EII, ou la propriété de l'élément DII [élément de document] est appelé l'élément JSON racine.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-128">The EII, or the DII’s [document element] property, is referred to as the Root JSON Element.</span></span> <span data-ttu-id="9cdcd-129">Notez que les fragments de document (XML avec plusieurs éléments racine) ne sont pas pris en charge dans ce mappage.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-129">Note that document fragments (XML with multiple root elements) are not supported in this mapping.</span></span>

<span data-ttu-id="9cdcd-130">Exemple : le document suivant :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-130">Example: The following document:</span></span>

```xml
<?xml version="1.0"?>
<root type="number">42</root>`
```

<span data-ttu-id="9cdcd-131">Et les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-131">And the following element:</span></span>

```xml
<root type="number">42</root>
```

<span data-ttu-id="9cdcd-132">Ces deux éléments ont un mappage à JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-132">Both have a mapping to JSON.</span></span> <span data-ttu-id="9cdcd-133">Le <`root`> élément est l’élément JSON racine dans les deux cas.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-133">The <`root`> element is the Root JSON Element in both cases.</span></span>

<span data-ttu-id="9cdcd-134">De plus, les éléments suivants doivent être pris en compte dans le cas d'un élément DII :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-134">Furthermore, in the case of a DII, the following should be considered:</span></span>

- <span data-ttu-id="9cdcd-135">Certains éléments dans la liste [enfants] ne doivent pas être présents.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-135">Some items in the [children] list must not be present.</span></span> <span data-ttu-id="9cdcd-136">Ne comptez pas sur ce fait pour la lecture du XML mappé à partir de JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-136">Do not rely on this fact when reading XML mapped from JSON.</span></span>

- <span data-ttu-id="9cdcd-137">La liste [enfants] ne contient aucun élément d'informations de commentaire.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-137">The [children] list holds no comment information items.</span></span>

- <span data-ttu-id="9cdcd-138">La liste [enfants] ne contient aucun élément d'informations DTD.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-138">The [children] list holds no DTD information items.</span></span>

- <span data-ttu-id="9cdcd-139">La liste [enfants] ne contient aucun élément d’informations personnelles des informations (PI) (le `<?xml…>` déclaration n’est pas considéré comme un élément d’informations PI)</span><span class="sxs-lookup"><span data-stu-id="9cdcd-139">The [children] list holds no personal Information (PI) information items (the `<?xml…>` declaration is not considered a PI information item)</span></span>

- <span data-ttu-id="9cdcd-140">Le jeu [notations] est vide.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-140">The [notations] set is empty.</span></span>

- <span data-ttu-id="9cdcd-141">Le jeu [entités non analysées] est vide.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-141">The [unparsed entities] set is empty.</span></span>

<span data-ttu-id="9cdcd-142">Exemple : Le document suivant n’a aucun mappage à JSON parce que [enfants] contient un PI et un commentaire.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-142">Example: The following document has no mapping to JSON because [children] holds a PI and a comment.</span></span>

```xml
<?xml version="1.0"?>
<!--comment--><?pi?>
<root type="number">42</root>
```

<span data-ttu-id="9cdcd-143">L'EII pour l'élément JSON racine a les caractéristiques suivantes :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-143">The EII for the Root JSON Element has the following characteristics:</span></span>

- <span data-ttu-id="9cdcd-144">[nom local] a la valeur "racine".</span><span class="sxs-lookup"><span data-stu-id="9cdcd-144">[local name] has the value "root".</span></span>

- <span data-ttu-id="9cdcd-145">[nom d'espace de noms] n'a aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-145">[namespace name] has no value.</span></span>

- <span data-ttu-id="9cdcd-146">[préfixe] n'a aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-146">[prefix] has no value.</span></span>

- <span data-ttu-id="9cdcd-147">[enfants] peut contenir des éléments EII (qui représentent des éléments internes décrits plus loin) ou des éléments CII (éléments d'informations de caractère décrits plus loin) ou aucun d'entre eux, mais pas les deux.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-147">[children] may either contain EIIs (which represent Inner Elements as described further) or CIIs (Character Information Items as described further) or none of these, but not both.</span></span>

- <span data-ttu-id="9cdcd-148">[attributs] peut contenir les éléments AII (Attribute Information Items) facultatifs suivants</span><span class="sxs-lookup"><span data-stu-id="9cdcd-148">[attributes] may contain the following optional attribute information items (AIIs)</span></span>

- <span data-ttu-id="9cdcd-149">L'attribut de type JSON ("type") décrit plus loin.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-149">The JSON Type Attribute ("type") as described further.</span></span> <span data-ttu-id="9cdcd-150">Cet attribut est utilisé pour conserver le type JSON (chaîne, nombre, booléen, objet, tableau ou null) dans le XML mappé.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-150">This attribute is used to preserve the JSON type (string, number, boolean, object, array or null) in the mapped XML.</span></span>

- <span data-ttu-id="9cdcd-151">L’attribut de nom de contrat de données («\_\_type ») comme décrit plus loin.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-151">The Data Contract Name Attribute ("\_\_type") as described further.</span></span> <span data-ttu-id="9cdcd-152">Cet attribut peut être présent uniquement si l'attribut de type JSON est aussi présent et sa [valeur normalisée] est "objet."</span><span class="sxs-lookup"><span data-stu-id="9cdcd-152">This attribute is can only be present if the JSON type attribute is also present and its [normalized value] is "object".</span></span> <span data-ttu-id="9cdcd-153">Cet attribut est utilisé par le `DataContractJsonSerializer` pour conserver des informations de type de contrat de données - par exemple, dans les cas polymorphes où un type dérivé est sérialisé et où un type de base est attendu.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-153">This attribute is used by the `DataContractJsonSerializer` to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected.</span></span> <span data-ttu-id="9cdcd-154">Si vous n'utilisez le `DataContractJsonSerializer`, dans la plupart des cas, cet attribut est ignoré.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-154">If you are not working with the `DataContractJsonSerializer`, in most cases, this attribute is ignored.</span></span>

- <span data-ttu-id="9cdcd-155">[espaces de noms dans l’étendue] contient la liaison de « xml » à `http://www.w3.org/XML/1998/namespace` comme mandaté par la spécification infoset.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-155">[in-scope namespaces] contains the binding of "xml" to `http://www.w3.org/XML/1998/namespace` as mandated by the infoset specification.</span></span>

- <span data-ttu-id="9cdcd-156">[enfants], [attributs] et [espaces de noms dans l'étendue] ne doivent pas avoir d'éléments autres que ceux spécifiés précédemment et [attributs d'espace de noms] ne doit pas avoir de membres, mais ne compte pas sur ces faits pour la lecture du XML mappé à partir de JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-156">[children], [attributes] and [in-scope namespaces] must not have any items other than as specified previously and [namespace attributes] must have no members, but do not rely on these facts when reading XML mapped from JSON.</span></span>

<span data-ttu-id="9cdcd-157">Exemple : Le document suivant n’a aucun mappage à JSON parce que [attributs d’espace de noms] n’est pas vide.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-157">Example: The following document has no mapping to JSON because [namespace attributes] is not empty.</span></span>

```xml
<?xml version="1.0"?>
<root xmlns:a="myattributevalue">42</root>
```

<span data-ttu-id="9cdcd-158">L'élément AII pour l'attribut de type JSON a les caractéristiques suivantes :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-158">The AII for the JSON Type Attribute has the following characteristics:</span></span>

- <span data-ttu-id="9cdcd-159">[nom d'espace de noms] n'a aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-159">[namespace name] has no value.</span></span>
- <span data-ttu-id="9cdcd-160">[préfixe] n'a aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-160">[prefix] has no value.</span></span>
- <span data-ttu-id="9cdcd-161">[nom local] est "type".</span><span class="sxs-lookup"><span data-stu-id="9cdcd-161">[local name] is "type".</span></span>
- <span data-ttu-id="9cdcd-162">[valeur normalisée] est une des valeurs de type possibles décrite dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-162">[normalized value] is one of the possible type values described in the following section.</span></span>
- <span data-ttu-id="9cdcd-163">[spécifié] a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-163">[specified] is `true`.</span></span>
- <span data-ttu-id="9cdcd-164">[type d'attribut] n'a aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-164">[attribute type] has no value.</span></span>
- <span data-ttu-id="9cdcd-165">[références] n'a aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-165">[references] has no value.</span></span>

<span data-ttu-id="9cdcd-166">L'élément AII pour l'attribut de nom de contrat de données a les caractéristiques suivantes :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-166">The AII for the Data Contract Name Attribute has the following characteristics:</span></span>

- <span data-ttu-id="9cdcd-167">[nom d'espace de noms] n'a aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-167">[namespace name] has no value.</span></span>
- <span data-ttu-id="9cdcd-168">[préfixe] n'a aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-168">[prefix] has no value.</span></span>
- <span data-ttu-id="9cdcd-169">[nom local] est «\_\_type » (deux traits de soulignement et ensuite « type »).</span><span class="sxs-lookup"><span data-stu-id="9cdcd-169">[local name] is "\_\_type" (two underscores and then "type").</span></span>
- <span data-ttu-id="9cdcd-170">[valeur normalisée] est toute chaîne Unicode valide. Le mappage de cette chaîne à JSON est décrit dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-170">[normalized value] is any valid Unicode string – the mapping of this string to JSON is described in the following section.</span></span>
- <span data-ttu-id="9cdcd-171">[spécifié] a la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-171">[specified] is `true`.</span></span>
- <span data-ttu-id="9cdcd-172">[type d'attribut] n'a aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-172">[attribute type] has no value.</span></span>
- <span data-ttu-id="9cdcd-173">[références] n'a aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-173">[references] has no value.</span></span>

<span data-ttu-id="9cdcd-174">Les éléments internes contenus dans l'élément JSON racine ou d'autres éléments internes ont les caractéristiques suivantes :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-174">Inner elements contained within the Root JSON Element or other inner elements have the following characteristics:</span></span>

- <span data-ttu-id="9cdcd-175">[nom local] peut avoir n’importe quelle valeur décrit plus loin.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-175">[local name] may have any value as described further.</span></span>
- <span data-ttu-id="9cdcd-176">[nom d'espace de noms], [préfixe], [enfants], [attributs], [attributs d'espace de noms], et [espaces de noms dans l'étendue] sont soumis aux mêmes règles que l'élément JSON racine.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-176">[namespace name], [prefix], [children], [attributes], [namespace attributes], and [in-scope namespaces] are subject to the same rules as the Root JSON Element.</span></span>

<span data-ttu-id="9cdcd-177">Dans l'élément JSON racine et les éléments internes, l'attribut de type JSON définit le mappage à JSON et les [enfants] possibles et leur interprétation.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-177">In both the Root JSON Element and the inner elements, the JSON Type Attribute defines the mapping to JSON and the possible [children] and their interpretation.</span></span> <span data-ttu-id="9cdcd-178">[Valeur normalisée] de l’attribut respecte la casse et doit être en minuscule et ne peut pas contenir d’espace blanc.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-178">The attribute’s [normalized value] is case-sensitive and must be lowercase, and cannot contain white space.</span></span>

|<span data-ttu-id="9cdcd-179">[valeur normalisée] de l’élément AII de l’attribut de Type JSON</span><span class="sxs-lookup"><span data-stu-id="9cdcd-179">[normalized value] of JSON Type Attribute’s AII</span></span>|<span data-ttu-id="9cdcd-180">[enfants] autorisés de l'élément EII correspondant</span><span class="sxs-lookup"><span data-stu-id="9cdcd-180">Allowed [children] of the corresponding EII</span></span>|<span data-ttu-id="9cdcd-181">Mappage à JSON</span><span class="sxs-lookup"><span data-stu-id="9cdcd-181">Mapping to JSON</span></span>|
|---------------------------------------------------------|---------------------------------------------------|---------------------|
|<span data-ttu-id="9cdcd-182">`string` (ou absence de l'élément AII de type JSON)</span><span class="sxs-lookup"><span data-stu-id="9cdcd-182">`string` (or absence of the JSON type AII)</span></span><br /><br /> <span data-ttu-id="9cdcd-183">Un `string` et l'absence de l'élément AII de type JSON sont les mêmes que la valeur par défaut `string`.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-183">A `string` and the absence of the JSON type AII are the same makes `string` the default.</span></span><br /><br /> <span data-ttu-id="9cdcd-184">Ainsi, `<root> string1</root>` mappe à "string1" `string` JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-184">So, `<root> string1</root>` maps to the JSON `string` "string1".</span></span>|<span data-ttu-id="9cdcd-185">0 ou plusieurs éléments CII</span><span class="sxs-lookup"><span data-stu-id="9cdcd-185">0 or more CIIs</span></span>|<span data-ttu-id="9cdcd-186">JSON `string` (JSON RFC, section 2.5).</span><span class="sxs-lookup"><span data-stu-id="9cdcd-186">A JSON `string` (JSON RFC, section 2.5).</span></span> <span data-ttu-id="9cdcd-187">Chaque `char` est un caractère qui correspond au [code de caractère] du CII.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-187">Each `char` is a character that corresponds to the [character code] from the CII.</span></span> <span data-ttu-id="9cdcd-188">En l'absence d'élément CII, il mappe à un `string` JSON vide.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-188">If there are no CIIs, it maps to an empty JSON `string`.</span></span><br /><br /> <span data-ttu-id="9cdcd-189">Exemple : L’élément suivant mappe à un fragment JSON :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-189">Example: The following element maps to a JSON fragment:</span></span><br /><br /> `<root type="string">42</root>`<br /><br /> <span data-ttu-id="9cdcd-190">Le fragment JSON est "42".</span><span class="sxs-lookup"><span data-stu-id="9cdcd-190">The JSON fragment is "42".</span></span><br /><br /> <span data-ttu-id="9cdcd-191">Sur le mappage XML à JSON, les caractères qui doivent faire l'objet d'une séquence d'échappement sont mappés aux caractères d'échappement, tous les autres sont mappés aux caractères de non échappement.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-191">On XML to JSON mapping, characters that must be escaped map to escaped characters, all others map to characters that are not escaped.</span></span> <span data-ttu-id="9cdcd-192">Le caractère « / » est spécial : il est ignoré même s’il n’a pas à être (écrit comme «\\/ »).</span><span class="sxs-lookup"><span data-stu-id="9cdcd-192">The "/" character is special – it is escaped even though it does not have to be (written out as "\\/").</span></span><br /><br /> <span data-ttu-id="9cdcd-193">Exemple : L’élément suivant mappe à un fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-193">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">the "da/ta"</root>`<br /><br /> <span data-ttu-id="9cdcd-194">Le fragment JSON est « le \\» da\\/ta\\» ».</span><span class="sxs-lookup"><span data-stu-id="9cdcd-194">The JSON fragment is "the \\"da\\/ta\\"".</span></span><br /><br /> <span data-ttu-id="9cdcd-195">Sur le mappage JSON à XML, les caractères échappés et les caractères non échappés ne sont pas correctement mappés au [code de caractère] correspondant.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-195">On JSON to XML mapping, any escaped characters and characters that are not escaped map correctly to the corresponding [character code].</span></span><br /><br /> <span data-ttu-id="9cdcd-196">Exemple : Le fragment JSON « \u0041BC » mappe à l’élément XML suivant.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-196">Example: The JSON fragment "\u0041BC", maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="9cdcd-197">La chaîne peut être entourée par un espace blanc ('ws' dans la section 2 de la RFC JSON) qui ne sont pas mappé au XML.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-197">The string can be surrounded by white space ('ws' in section 2 of the JSON RFC) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="9cdcd-198">Exemple : Le JSON fragmente « ABC », (il existe des espaces avant le premier guillemet double), mappe à l’élément XML suivant.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-198">Example: The JSON fragment           "ABC", (there are spaces before the first double quote), maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="9cdcd-199">Tout espace blanc dans XML mappe à un espace blanc dans JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-199">Any white space in XML maps to white space in JSON.</span></span><br /><br /> <span data-ttu-id="9cdcd-200">Exemple : L’élément XML suivant mappe à un fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-200">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">  A BC      </root>`<br /><br /> <span data-ttu-id="9cdcd-201">Le fragment JSON est " A BC ".</span><span class="sxs-lookup"><span data-stu-id="9cdcd-201">The JSON fragment is " A BC ".</span></span>|
|`number`|<span data-ttu-id="9cdcd-202">1 ou plusieurs éléments CII</span><span class="sxs-lookup"><span data-stu-id="9cdcd-202">1 or more CIIs</span></span>|<span data-ttu-id="9cdcd-203">JSON `number` (JSON RFC, section 2.4), peut-être entouré par un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-203">A JSON `number` (JSON RFC, section 2.4), possibly surrounded by white space.</span></span> <span data-ttu-id="9cdcd-204">Chaque caractère dans la combinaison nombre/espace est un caractère qui correspond au [code de caractère] du CII.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-204">Each character in the number/white space combination is a character that corresponds to the [character code] from the CII.</span></span><br /><br /> <span data-ttu-id="9cdcd-205">Exemple : L’élément suivant mappe à un fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-205">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="number">    42</root>`<br /><br /> <span data-ttu-id="9cdcd-206">Le fragment JSON est    42.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-206">The JSON fragment is    42</span></span><br /><br /> <span data-ttu-id="9cdcd-207">(L’espace blanc est conservé).</span><span class="sxs-lookup"><span data-stu-id="9cdcd-207">(White space is preserved).</span></span>|
|`boolean`|<span data-ttu-id="9cdcd-208">4 ou 5 éléments CII (qui correspond à `true` ou `false`), peuvent être entourés par des éléments CII de blancs supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-208">4 or 5 CIIs (which corresponds to `true` or `false`), possibly surrounded by additional white-space CIIs.</span></span>|<span data-ttu-id="9cdcd-209">Une séquence CII qui correspond à la chaîne "true" est mappée au littéral `true`, et une séquence CII qui correspond à la chaîne "false" est mappée au littéral `false`.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-209">A CII sequence that corresponds to the string "true" is mapped to the literal `true`, and a CII sequence that corresponds to the string "false" is mapped to the literal `false`.</span></span> <span data-ttu-id="9cdcd-210">Entourant l’espace blanc est conservé.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-210">Surrounding white space is preserved.</span></span><br /><br /> <span data-ttu-id="9cdcd-211">Exemple : L’élément suivant mappe à un fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-211">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="boolean"> false</root>`<br /><br /> <span data-ttu-id="9cdcd-212">Le fragment JSON is `false`.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-212">The JSON fragment is `false`.</span></span>|
|`null`|<span data-ttu-id="9cdcd-213">Aucun autorisé.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-213">None allowed.</span></span>|<span data-ttu-id="9cdcd-214">Littéral `null`.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-214">The literal `null`.</span></span> <span data-ttu-id="9cdcd-215">Sur le mappage JSON à XML, le `null` peut être entouré par un espace blanc ('ws' dans section 2) qui ne sont pas mappé au XML.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-215">On JSON to XML mapping, the `null` may be surrounded by white space (‘ws’ in section 2) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="9cdcd-216">Exemple : L’élément suivant mappe à un fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-216">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="null"/>`<br /><br /> <span data-ttu-id="9cdcd-217">ou</span><span class="sxs-lookup"><span data-stu-id="9cdcd-217">or</span></span><br /><br /> `<root type="null"></root>`<br /><br /> <span data-ttu-id="9cdcd-218">:</span><span class="sxs-lookup"><span data-stu-id="9cdcd-218">:</span></span><br /><br /> <span data-ttu-id="9cdcd-219">Le fragment JSON dans les deux cas est `Null`.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-219">The JSON fragment in both cases is `Null`.</span></span>|
|`object`|<span data-ttu-id="9cdcd-220">0 ou plusieurs éléments EII.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-220">0 or more EIIs.</span></span>|<span data-ttu-id="9cdcd-221">Un `begin-object` (accolade ouvrante) comme dans la section 2.2 de la FRC JSON, suivi d'un enregistrement membre pour chaque élément EII décrit plus loin.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-221">A `begin-object` (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further.</span></span> <span data-ttu-id="9cdcd-222">En présence de plusieurs éléments EII, il y a des séparateurs de valeur (virgules) entre les enregistrements membre.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-222">If there is more than one EII, there are value-separators (commas) between the member records.</span></span> <span data-ttu-id="9cdcd-223">Cet ensemble est suivi par un objet de fin (accolade fermante).</span><span class="sxs-lookup"><span data-stu-id="9cdcd-223">All this is followed by an end-object (right curly brace).</span></span><br /><br /> <span data-ttu-id="9cdcd-224">Exemple : L’élément suivant mappe au fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-224">Example: The following element maps to the JSON fragment.</span></span><br /><br /> `<root type="object">`<br /><br /> `<type1 type="string">aaa\</type1>`<br /><br /> `<type2 type="string">bbb\</type2>`<br /><br /> `</root >`<br /><br /> <span data-ttu-id="9cdcd-225">Le fragment JSON is `{"type1":"aaa","type2":"bbb"}`.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-225">The JSON fragment is `{"type1":"aaa","type2":"bbb"}`.</span></span><br /><br /> <span data-ttu-id="9cdcd-226">Si l'attribut de type de contrat de données est présent sur le mappage XML à JSON, tout membre supplémentaire est inséré au début.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-226">If the Data Contract Type Attribute is present on XML to JSON mapping, then an additional Member Record is inserted at the beginning.</span></span> <span data-ttu-id="9cdcd-227">Son nom est le [nom local] de l’attribut de Type de contrat de données («\_\_type »), et sa valeur est l’attribut [valeur normalisée].</span><span class="sxs-lookup"><span data-stu-id="9cdcd-227">Its name is the [local name] of the Data Contract Type Attribute ("\_\_type"), and its value is the attribute's [normalized value].</span></span> <span data-ttu-id="9cdcd-228">Inversement, sur le mappage JSON à XML, si le premier nom de l’enregistrement-membre est le [nom local] de l’attribut de Type de contrat de données (autrement dit, «\_\_type »), un attribut de Type de contrat de données correspondante est présent dans le XML mappé, mais un élément EII correspondant n’est pas présent.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-228">Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, "\_\_type"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present.</span></span> <span data-ttu-id="9cdcd-229">Notez que cet enregistrement membre doit se produire en premier dans l'objet JSON pour que ce mappage spécial s'applique.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-229">Note that this member record must occur first in the JSON object for this special mapping to apply.</span></span> <span data-ttu-id="9cdcd-230">Il s'agit d'une nouveauté par rapport au traitement JSON habituel dans lequel l'ordre des enregistrements membres n'est pas significatif.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-230">This represents a departure from usual JSON processing, where the order of member records is not significant.</span></span><br /><br /> <span data-ttu-id="9cdcd-231">Exemple :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-231">Example:</span></span><br /><br /> <span data-ttu-id="9cdcd-232">Le fragment JSON suivant mappe au XML.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-232">The following JSON fragment maps to XML.</span></span><br /><br /> `{"__type":"Person","name":"John"}`<br /><br /> <span data-ttu-id="9cdcd-233">Le XML est le code suivant.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-233">The XML is the following code.</span></span><br /><br /> `<root type="object" __type="Person">   <name type="string">John</name> </root>`<br /><br /> <span data-ttu-id="9cdcd-234">Notez que le \_ \_élément AII de type est présent, mais il existe aucune \_ \_type élément EII.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-234">Notice that the \_\_type AII is present, but there is no \_\_type EII.</span></span><br /><br /> <span data-ttu-id="9cdcd-235">Toutefois, si l'ordre dans le JSON est inversé comme indiqué dans l'exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-235">However, if the order in the JSON is reversed as shown in the following example.</span></span><br /><br /> <span data-ttu-id="9cdcd-236">{"name":"John","\_\_type":"Person"}</span><span class="sxs-lookup"><span data-stu-id="9cdcd-236">{"name":"John","\_\_type":"Person"}</span></span><br /><br /> <span data-ttu-id="9cdcd-237">Le XML correspondant est indiqué.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-237">The corresponding XML is shown.</span></span><br /><br /> `<root type="object">   <name type="string">John</name>   <__type type="string">Person</__type> </root>`<br /><br /> <span data-ttu-id="9cdcd-238">Autrement dit, \__type cesse d’avoir une signification spéciale et mappe à un élément EII comme d’habitude, pas un élément AII.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-238">That is, \__type ceases to have special meaning and maps to an EII as usual, not AII.</span></span><br /><br /> <span data-ttu-id="9cdcd-239">Les règles d'échappement ou de non échappement pour l'élément AII [valeur normalisée] en cas de mappage à une valeur JSON sont les mêmes que pour les chaînes JSON spécifiées dans la ligne "chaîne" de ce tableau.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-239">Escaping/unescaping rules for the AII’s [normalized value] when mapped to a JSON value are the same as for JSON strings, specified in the "string" row of this table.</span></span><br /><br /> <span data-ttu-id="9cdcd-240">Exemple :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-240">Example:</span></span><br /><br /> `<root type="object" __type="\abc" />`<br /><br /> <span data-ttu-id="9cdcd-241">à l'exemple précédent peut être mappé au JSON suivant.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-241">to the previous example can be mapped to the following JSON.</span></span><br /><br /> `{"__type":"\\abc"}`<br /><br /> <span data-ttu-id="9cdcd-242">Sur un mappage XML à JSON, le premier élément EII [nom local] ne doit pas être «\_\_type ».</span><span class="sxs-lookup"><span data-stu-id="9cdcd-242">On an XML to JSON mapping, the first EII’s [local name] must not be "\_\_type".</span></span><br /><br /> <span data-ttu-id="9cdcd-243">Espace blanc (`ws`) n’est jamais généré sur XML pour le mappage JSON pour les objets et est ignoré sur JSON à mappage XML.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-243">White space (`ws`) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="9cdcd-244">Exemple : Le fragment JSON suivant mappe à un élément XML.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-244">Example: The following JSON fragment maps to an XML element.</span></span><br /><br /> `{ "ccc" : "aaa", "ddd" :"bbb"}`<br /><br /> <span data-ttu-id="9cdcd-245">L'élément XML est indiqué dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-245">The XML element is shown in the following code.</span></span><br /><br /> `<root type="object">    <ccc type="string">aaa</ccc>    <ddd type="string">bbb</bar> </root >`|
|<span data-ttu-id="9cdcd-246">array</span><span class="sxs-lookup"><span data-stu-id="9cdcd-246">array</span></span>|<span data-ttu-id="9cdcd-247">0 ou plusieurs éléments EII</span><span class="sxs-lookup"><span data-stu-id="9cdcd-247">0 or more EIIs</span></span>|<span data-ttu-id="9cdcd-248">Un tableau ouvrant (crochet ouvrant) comme dans la section 2.3 de la RFC JSON suivi d'un enregistrement de tableau pour chaque élément EII comme cela est décrit plus loin.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-248">A begin-array (left square bracket) as in section 2.3 of the JSON RFC, followed by an array record for each EII as described further.</span></span> <span data-ttu-id="9cdcd-249">En présence de plusieurs éléments EII, il y a des séparateurs de valeur (virgules) entre les enregistrements de tableau.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-249">If there is more than one EII, there are value-separators (commas) between the array records.</span></span> <span data-ttu-id="9cdcd-250">L'ensemble est suivi d'un tableau fermant.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-250">All this is followed by an end-array.</span></span><br /><br /> <span data-ttu-id="9cdcd-251">Exemple : L’élément XML suivant mappe à un fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-251">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`<br /><br /> <span data-ttu-id="9cdcd-252">Le fragment JSON est ["aaa", "bbb"]</span><span class="sxs-lookup"><span data-stu-id="9cdcd-252">The JSON fragment is ["aaa","bbb"]</span></span><br /><br /> <span data-ttu-id="9cdcd-253">Espace blanc (`ws`) n’est jamais généré sur XML pour le mappage JSON pour les tableaux et est ignoré sur JSON à mappage XML.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-253">White space (`ws`) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="9cdcd-254">Exemple : Un fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-254">Example: A JSON fragment.</span></span><br /><br />`["aaa", "bbb"]`<br /><br /> <span data-ttu-id="9cdcd-255">L'élément XML auquel il mappe.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-255">The XML element that it maps to.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`|

<span data-ttu-id="9cdcd-256">Les enregistrements membres fonctionnent comme suit :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-256">Member Records work as follows:</span></span>

- <span data-ttu-id="9cdcd-257">Le [nom local] de l'élément interne mappe à la partie `string` du `member` défini dans la section 2.2 de la RFC JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-257">Inner element’s [local name] maps to the `string` part of the `member` as defined in section 2.2 of the JSON RFC.</span></span>

<span data-ttu-id="9cdcd-258">Exemple : L’élément suivant mappe à un fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-258">Example: The following element maps to a JSON fragment.</span></span>

`<root type="object"/>`

`<myLocalName type="string">aaa</myLocalName>`

`</root >`

<span data-ttu-id="9cdcd-259">Le fragment JSON suivant est affiché.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-259">The following JSON fragment is displayed.</span></span>

`{"myLocalName":"aaa"}`

- <span data-ttu-id="9cdcd-260">Sur le mappage XML à JSON, les caractères qui doivent faire l'objet d'une séquence d'échappement dans JSON le sont, et tous les autres ne le sont pas.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-260">On the XML to JSON mapping, the characters that must be escaped in JSON are escaped, and the others are not escaped.</span></span> <span data-ttu-id="9cdcd-261">Le caractère "/", même s'il ne s'agit pas d'un caractère qui doit faire l'objet d'une séquence d'échappement, est néanmoins échappé (ce qui n'est pas nécessaire sur le mappage JSON à XML).</span><span class="sxs-lookup"><span data-stu-id="9cdcd-261">The "/" character, even though it is not a character that must be escaped, is escaped nevertheless (it does not have to be escaped on JSON to XML mapping).</span></span> <span data-ttu-id="9cdcd-262">Cela est requis pour prendre en charge le format ASP.NET AJAX pour les données `DateTime` dans JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-262">This is required to support the ASP.NET AJAX format for `DateTime` data in JSON.</span></span>

- <span data-ttu-id="9cdcd-263">Sur le mappage JSON au XML, tous les caractères (y compris les caractères non échappés, si nécessaire) sont acceptés pour former un `string` qui produit un [nom local].</span><span class="sxs-lookup"><span data-stu-id="9cdcd-263">On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a `string` that produces a [local name].</span></span>

- <span data-ttu-id="9cdcd-264">Les éléments internes [enfants] mappent à la valeur dans section 2.2, selon `JSON Type Attribute` comme pour `Root JSON Element`.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-264">Inner elements [children] map to the value in section 2.2, according to the `JSON Type Attribute` just like for the `Root JSON Element`.</span></span> <span data-ttu-id="9cdcd-265">Plusieurs niveaux d'imbrication des éléments EII (y compris l'imbrication dans des tableaux) sont autorisés.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-265">Multiple levels of nesting of EIIs (including nesting within arrays) are allowed.</span></span>

<span data-ttu-id="9cdcd-266">Exemple : L’élément suivant mappe à un fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-266">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="object">
    <myLocalName1 type="string">myValue1</myLocalName1>
    <myLocalName2 type="number">2</myLocalName2>
    <myLocalName3 type="object">
        <myNestedName1 type="boolean">true</myNestedName1>
        <myNestedName2 type="null"/>
    </myLocalName3>
</root >
```

<span data-ttu-id="9cdcd-267">Le fragment JSON suivant est celui auquel il est mappé.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-267">The following JSON fragment is what it maps to.</span></span>

`{"myLocalName1":"myValue1","myLocalName2":2,"myLocalName3":{"myNestedName1":true,"myNestedName2":null}}`

> [!NOTE]
> <span data-ttu-id="9cdcd-268">Il n'y a aucune étape d'encodage XML dans le mappage précédent.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-268">There is no XML encoding step in the preceding mapping.</span></span> <span data-ttu-id="9cdcd-269">Par conséquent, WCF prend uniquement en charge les documents JSON où tous les caractères dans les noms de clé sont les caractères valides dans les noms d’élément XML.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-269">Therefore, WCF only supports JSON documents where all characters in key names are valid characters in XML element names.</span></span> <span data-ttu-id="9cdcd-270">Par exemple, le document JSON {« < » : « a »} n’est pas pris en charge, car < n’est pas un nom valide pour un élément XML.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-270">For example, the JSON document {"<":"a"} is not supported because < is not a valid name for an XML element.</span></span>

<span data-ttu-id="9cdcd-271">La situation inverse (caractères valide dans XML mais pas dans JSON) ne provoque pas de problèmes étant donné que le mappage précédent inclut des étapes d'échappement et de non échappement JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-271">The reverse situation (characters valid in XML but not in JSON) does not cause any problems because the preceding mapping includes JSON escaping/unescaping steps.</span></span>

<span data-ttu-id="9cdcd-272">Les enregistrements du tableau fonctionnent comme suit :</span><span class="sxs-lookup"><span data-stu-id="9cdcd-272">Array Records work as follows:</span></span>

- <span data-ttu-id="9cdcd-273">Le [nom local] de l'élément interne est "élément."</span><span class="sxs-lookup"><span data-stu-id="9cdcd-273">Inner element’s [local name] is "item".</span></span>

- <span data-ttu-id="9cdcd-274">[enfants] de l'élément interne mappe à la valeur dans la section 2.3, selon l'attribut de type JSON comme pour l'élément JSON racine.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-274">Inner element’s [children] map to the value in section 2.3, according to the JSON Type Attribute as is does for the Root JSON Element.</span></span> <span data-ttu-id="9cdcd-275">Plusieurs niveaux d'imbrication des éléments EII (y compris l'imbrication dans des objets) sont autorisés.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-275">Multiple levels of nesting of EIIs (including nesting within objects) are allowed.</span></span>

<span data-ttu-id="9cdcd-276">Exemple : L’élément suivant mappe à un fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-276">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="array"/>
    <item type="string">myValue1</item>
    <item type="number">2</item>
    <item type="array">
    <item type="boolean">true</item>
    <item type="null"/></item>
</root >
```

<span data-ttu-id="9cdcd-277">Les éléments suivants sont le fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="9cdcd-277">The following is the JSON fragment.</span></span>

`["myValue1",2,[true,null]]`

## <a name="see-also"></a><span data-ttu-id="9cdcd-278">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="9cdcd-278">See also</span></span>

- <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory>
- <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>
- [<span data-ttu-id="9cdcd-279">Sérialisation JSON autonome</span><span class="sxs-lookup"><span data-stu-id="9cdcd-279">Stand-Alone JSON Serialization</span></span>](stand-alone-json-serialization.md)
