---
title: Weakly-typed JSON Serialization, exemple
ms.date: 03/30/2017
ms.assetid: 0b30e501-4ef5-474d-9fad-a9d559cf9c52
ms.openlocfilehash: b0e9617ad5d616e8921fbf142085f2758f3e0cd4
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/23/2019
ms.locfileid: "62006354"
---
# <a name="weakly-typed-json-serialization-sample"></a><span data-ttu-id="fa3b6-102">Weakly-typed JSON Serialization, exemple</span><span class="sxs-lookup"><span data-stu-id="fa3b6-102">Weakly-typed JSON Serialization Sample</span></span>
<span data-ttu-id="fa3b6-103">Lors de la sérialisation d'un type défini par l'utilisateur dans un format de transmission donné, ou de la désérialisation d'un format de transmission dans un type défini par l'utilisateur, le type défini par l'utilisateur donné doit être disponible à la fois sur le service et sur le client.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-103">When serializing a user-defined type to a given wire format, or deserializing a wire format back into a user-defined type, the given user-defined type must be available on both the service and the client.</span></span> <span data-ttu-id="fa3b6-104">En général, l'attribut <xref:System.Runtime.Serialization.DataContractAttribute> est alors appliqué à ces types définis par l'utilisateur, et l'attribut <xref:System.Runtime.Serialization.DataMemberAttribute> est appliqué à leurs membres.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-104">Usually to accomplish this, the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to these user-defined types and the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute is applied to their members.</span></span> <span data-ttu-id="fa3b6-105">Ce mécanisme s’applique également lorsque vous travaillez avec des objets JavaScript Objet Notation (JSON), comme décrit dans la rubrique [Comment : Sérialiser et désérialiser des données JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="fa3b6-105">This mechanism also applies when working with JavaScript Object Notation (JSON) objects, as described in the topic [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>  
  
 <span data-ttu-id="fa3b6-106">Dans certains scénarios, un service Windows Communication Foundation (WCF) ou un client doit accéder aux objets JSON générés par un service ou d’un client qui se trouve en dehors du contrôle du développeur.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-106">In some scenarios, a Windows Communication Foundation (WCF) service or client must access JSON objects generated by a service or client that is outside of the control of the developer.</span></span> <span data-ttu-id="fa3b6-107">Comme plus de services Web exposent publiquement des API JSON, il peut devenir difficile pour les développeurs WCF construire des types définis par l’utilisateur locales dans lesquels désérialiser des objets JSON arbitraires.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-107">As more Web services publicly expose JSON APIs, it can become impractical for the WCF developer to construct local user-defined types into which to deserialize arbitrary JSON objects.</span></span> <span data-ttu-id="fa3b6-108">Cet exemple fournit un mécanisme qui permet aux développeurs WCF travailler avec des objets JSON désérialisés et arbitraires, sans créer de types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-108">This sample provides a mechanism that enables WCF developers to work with deserialized, arbitrary JSON objects, without creating user-defined types.</span></span> <span data-ttu-id="fa3b6-109">C'est ce que l'on appelle la *sérialisation faiblement typée* d'objets JSON, parce que le type dans lequel un objet JSON est désérialisé n'est pas connu au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-109">This is known as *weakly-typed serialization* of JSON objects, because the type into which a JSON object deserializes is not known at compile time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fa3b6-110">La procédure d'installation ainsi que les instructions de génération relatives à cet exemple figurent à la fin de cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-110">The setup procedure and build instructions for this sample are located at the end of this topic.</span></span>  
  
 <span data-ttu-id="fa3b6-111">Par exemple, une API de service Web publique retourne l'objet JSON suivant, qui contient des informations à propos d'un utilisateur du service.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-111">For example, a public Web service API returns the following JSON object, which describes some information about a user of the service.</span></span>  
  
```json  
{"personal": {"name": "Paul", "age": 23, "height": 1.7, "isSingle": true, "luckyNumbers": [5,17,21]}, "favoriteBands": ["Band ABC", "Band XYZ"]}  
```  
  
 <span data-ttu-id="fa3b6-112">Pour désérialiser cet objet, un client WCF doit implémenter les types définis par l’utilisateur suivants.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-112">To deserialize this object, a WCF client must implement the following user-defined types.</span></span>  
  
```  
[DataContract]  
 public class MemberProfile  
 {  
     [DataMember]  
     public PersonalInfo personal;  
  
     [DataMember]  
     public string[] favoriteBands;  
 }  
  
 [DataContract]  
 public class PersonalInfo  
 {  
     [DataMember]  
     public string name;  
  
     [DataMember]  
     public int age;  
  
     [DataMember]  
     public double height;  
  
     [DataMember]  
     public bool isSingle;  
  
     [DataMember]  
     public int[] luckyNumbers;  
 }  
```  
  
 <span data-ttu-id="fa3b6-113">Cela peut être gênant, surtout si le client doit gérer plusieurs types d'objets JSON.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-113">This can be cumbersome, especially if the client has to handle more than one type of JSON object.</span></span>  
  
 <span data-ttu-id="fa3b6-114">Le type `JsonObject` introduit une représentation faiblement typée de l'objet JSON désérialisé.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-114">The `JsonObject` type provided by this sample introduces a weakly-typed representation of the deserialized JSON object.</span></span> <span data-ttu-id="fa3b6-115">`JsonObject` repose sur le mappage naturel entre les objets JSON et les dictionnaires [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] , et le mappage entre les tableaux JSON et les tableaux [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="fa3b6-115">`JsonObject` relies on the natural mapping between JSON objects and [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] dictionaries, and the mapping between JSON arrays and [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] arrays.</span></span> <span data-ttu-id="fa3b6-116">Le code suivant illustre le type `JsonObject` .</span><span class="sxs-lookup"><span data-stu-id="fa3b6-116">The following code shows the `JsonObject` type.</span></span>  
  
```  
// Instantiation of JsonObject json omitted  
  
string name = json["root"]["personal"]["name"];  
int age = json["root"]["personal"]["age"];  
double height = json["root"]["personal"]["height"];  
bool isSingle = json["root"]["personal"]["isSingle"];  
int[] luckyNumbers = {  
                                     json["root"]["personal"]["luckyNumbers"][0],  
                                     json["root"]["personal"]["luckyNumbers"][1],  
                                     json["root"]["personal"]["luckyNumbers"][2]   
                                 };  
string[] favoriteBands = {  
                                        json["root"]["favoriteBands"][0],  
                                        json["root"]["favoriteBands"][1]  
                                    };  
```  
  
 <span data-ttu-id="fa3b6-117">Notez que vous pouvez « parcourir » des objets et tableaux JSON sans avoir besoin de déclarer leur type au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-117">Note that you can "browse" JSON objects and arrays without the need to declare their type at compile time.</span></span> <span data-ttu-id="fa3b6-118">Pour obtenir une explication de la spécification requise pour l’objet `["root"]` de niveau supérieur, consultez le rubrique [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="fa3b6-118">For an explanation of the requirement for the top-level `["root"]` object, see the topic [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fa3b6-119">La classe `JsonObject` est fournie uniquement à titre d'exemple.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-119">The `JsonObject` class is provided as an example only.</span></span> <span data-ttu-id="fa3b6-120">Elle n'a pas été testée entièrement et ne doit pas être utilisée dans les environnements de production.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-120">It has not been thoroughly tested, and should not be used in production environments.</span></span> <span data-ttu-id="fa3b6-121">L'une des conséquences évidentes de la sérialisation JSON faiblement typée est le manque de sécurité du type lors de l'utilisation de `JsonObject`.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-121">An obvious implication of weakly-typed JSON serialization is the lack of type-safety when working with `JsonObject`.</span></span>  
  
 <span data-ttu-id="fa3b6-122">Pour utiliser le type `JsonObject` , le contrat d'opération cliente doit utiliser <xref:System.ServiceModel.Channels.Message> comme type de retour.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-122">To use the `JsonObject` type, the client operation contract must use <xref:System.ServiceModel.Channels.Message> as its return type.</span></span>  
  
```  
[ServiceContract]  
    interface IClientSideProfileService  
    {  
        // There is no need to write a DataContract for the complex type returned by the service.  
        // The client will use a JsonObject to browse the JSON in the received message.  
  
        [OperationContract]  
        [WebGet(ResponseFormat = WebMessageFormat.Json)]  
        Message GetMemberProfile();  
    }  
```  
  
 <span data-ttu-id="fa3b6-123">Le `JsonObject` est ensuite instancié comme le montre le code suivant.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-123">The `JsonObject` is then instantiated as shown in the following code.</span></span>  
  
```  
// Code to instantiate IClientSideProfileService channel omitted…  
  
// Make a request to the service and obtain the Json response  
XmlDictionaryReader reader = channel.GetMemberProfile().GetReaderAtBodyContents();  
  
// Go through the Json as though it is a dictionary. There is no need to map it to a .NET CLR type.  
JsonObject json = new JsonObject(reader);  
```  
  
 <span data-ttu-id="fa3b6-124">Le constructeur `JsonObject` prend un <xref:System.Xml.XmlDictionaryReader>, obtenu par l'intermédiaire de la méthode <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> .</span><span class="sxs-lookup"><span data-stu-id="fa3b6-124">The `JsonObject` constructor takes a <xref:System.Xml.XmlDictionaryReader>, which is obtained through the <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> method.</span></span> <span data-ttu-id="fa3b6-125">Le lecteur contient une représentation XML du message JSON reçu par le client.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-125">The reader contains an XML representation of the JSON message received by the client.</span></span> <span data-ttu-id="fa3b6-126">Pour plus d’informations, consultez la rubrique [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="fa3b6-126">For more information, see the topic [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
 <span data-ttu-id="fa3b6-127">Le programme génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="fa3b6-127">The program produces the following output:</span></span>  
  
```  
Service listening at http://localhost:8000/.  
To view the JSON output from the sample, navigate to http://localhost:8000/GetMemberProfile  
This is Paul's page. I am 23 years old and I am 1.7 meters tall.  
I am single.  
My lucky numbers are 5, 17, and 21.  
My favorite bands are Band ABC and Band XYZ.  
```  
  
### <a name="to-set-up-build-and-run-the-sample"></a><span data-ttu-id="fa3b6-128">Pour configurer, générer et exécuter l'exemple</span><span class="sxs-lookup"><span data-stu-id="fa3b6-128">To set up, build, and run the sample</span></span>  
  
1. <span data-ttu-id="fa3b6-129">Vérifiez que vous avez effectué la [procédure d’installation unique pour les exemples Windows Communication Foundation](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).</span><span class="sxs-lookup"><span data-stu-id="fa3b6-129">Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).</span></span>  
  
2. <span data-ttu-id="fa3b6-130">Générez la solution WeaklyTypedJson.sln telle que décrite dans la section [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).</span><span class="sxs-lookup"><span data-stu-id="fa3b6-130">Build the solution WeaklyTypedJson.sln as described in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).</span></span>  
  
3. <span data-ttu-id="fa3b6-131">Exécutez la solution.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-131">Run the solution.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="fa3b6-132">Les exemples peuvent déjà être installés sur votre ordinateur.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-132">The samples may already be installed on your machine.</span></span> <span data-ttu-id="fa3b6-133">Recherchez le répertoire (par défaut) suivant avant de continuer.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-133">Check for the following (default) directory before continuing.</span></span>  
>   
>  `<InstallDrive>:\WF_WCF_Samples`  
>   
>  <span data-ttu-id="fa3b6-134">Si ce répertoire n’existe pas, accédez à [Windows Communication Foundation (WCF) et des exemples de Windows Workflow Foundation (WF) pour .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) pour télécharger tous les Windows Communication Foundation (WCF) et [!INCLUDE[wf1](../../../../includes/wf1-md.md)] exemples.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-134">If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples.</span></span> <span data-ttu-id="fa3b6-135">Cet exemple se trouve dans le répertoire suivant.</span><span class="sxs-lookup"><span data-stu-id="fa3b6-135">This sample is located in the following directory.</span></span>  
>   
>  `<InstallDrive>:\WF_WCF_Samples\WCF\Scenario\Ajax\WeaklyTypedJson`  
