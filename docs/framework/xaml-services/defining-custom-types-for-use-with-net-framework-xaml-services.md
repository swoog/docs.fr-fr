---
title: Définition de types personnalisés pour une utilisation avec les services XAML .NET Framework
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: be9c0e26574a15279ce89af2c7862abaa8713360
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/08/2019
ms.locfileid: "59164435"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="aaa90-102">Définition de types personnalisés pour une utilisation avec les services XAML .NET Framework</span><span class="sxs-lookup"><span data-stu-id="aaa90-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="aaa90-103">Lorsque vous définissez des types personnalisés qui sont des objets métier ou sont des types qui n’ont pas d’une dépendance sur des infrastructures spécifiques, il existe certaines meilleures pratiques pour XAML, vous pouvez suivre.</span><span class="sxs-lookup"><span data-stu-id="aaa90-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="aaa90-104">Si vous respectez ces pratiques, les Services XAML .NET Framework et ses lecteurs XAML et les writers XAML peuvent découvrir les caractéristiques XAML de votre type et lui donner une représentation appropriée dans un flux de nœud XAML à l’aide du système de type XAML.</span><span class="sxs-lookup"><span data-stu-id="aaa90-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="aaa90-105">Cette rubrique décrit les meilleures pratiques pour les définitions de type, définitions de membre et aux attributs CLR des types ou membres.</span><span class="sxs-lookup"><span data-stu-id="aaa90-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="aaa90-106">Modèles de constructeur et définitions de Type pour XAML</span><span class="sxs-lookup"><span data-stu-id="aaa90-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="aaa90-107">Pour être instancié en tant qu’objet élément dans XAML, une classe personnalisée doit remplir les conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="aaa90-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="aaa90-108">La classe personnalisée doit être publique et doit exposer un constructeur public (sans paramètre) par défaut.</span><span class="sxs-lookup"><span data-stu-id="aaa90-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="aaa90-109">(Consultez la section suivante pour des remarques concernant les structures.)</span><span class="sxs-lookup"><span data-stu-id="aaa90-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="aaa90-110">La classe personnalisée ne doit pas être une classe imbriquée.</span><span class="sxs-lookup"><span data-stu-id="aaa90-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="aaa90-111">Supplémentaire « point » dans le chemin d’accès du nom complet rend la division de l’espace de noms classe ambiguë et interfère avec d’autres fonctionnalités XAML telles que les propriétés jointes.</span><span class="sxs-lookup"><span data-stu-id="aaa90-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="aaa90-112">Si un objet peut être instancié comme un élément objet, l’objet créé peut remplir le formulaire d’élément de propriété de toutes les propriétés qui acceptent l’objet comme type sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="aaa90-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="aaa90-113">Vous pouvez toujours fournir des valeurs d’objet pour les types qui ne répondent pas à ces critères, si vous activez un convertisseur de valeurs.</span><span class="sxs-lookup"><span data-stu-id="aaa90-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="aaa90-114">Pour plus d’informations, consultez [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="aaa90-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="aaa90-115">Structures</span><span class="sxs-lookup"><span data-stu-id="aaa90-115">Structures</span></span>  
 <span data-ttu-id="aaa90-116">Structures peuvent toujours être construites en XAML, par définition de CLR.</span><span class="sxs-lookup"><span data-stu-id="aaa90-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="aaa90-117">Il s’agit, car un compilateur CLR crée implicitement un constructeur par défaut pour une structure.</span><span class="sxs-lookup"><span data-stu-id="aaa90-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="aaa90-118">Ce constructeur initialise toutes les valeurs de propriétés à leurs valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="aaa90-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="aaa90-119">Dans certains cas, le comportement de construction par défaut pour une structure n’est pas souhaitable.</span><span class="sxs-lookup"><span data-stu-id="aaa90-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="aaa90-120">Cela peut être parce que la structure est destinée à remplir des valeurs et à fonctionner conceptuellement comme une union.</span><span class="sxs-lookup"><span data-stu-id="aaa90-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="aaa90-121">En tant qu’union, les valeurs contenues peuvent avoir des interprétations mutuellement exclusives, et par conséquent, aucune de ses propriétés peuvent être définies.</span><span class="sxs-lookup"><span data-stu-id="aaa90-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="aaa90-122">Un exemple d’une telle structure dans le vocabulaire WPF est <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="aaa90-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="aaa90-123">Ces structures doivent implémenter un convertisseur de type afin que les valeurs peuvent être exprimées sous forme d’attribut, à l’aide des conventions de chaîne qui créent les différents modes ou interprétations des valeurs de structure.</span><span class="sxs-lookup"><span data-stu-id="aaa90-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="aaa90-124">La structure doit également exposer un comportement similaire pour la construction de code via un constructeur non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="aaa90-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="aaa90-125">Interfaces</span><span class="sxs-lookup"><span data-stu-id="aaa90-125">Interfaces</span></span>  
 <span data-ttu-id="aaa90-126">Interfaces peuvent servir de types sous-jacents des membres.</span><span class="sxs-lookup"><span data-stu-id="aaa90-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="aaa90-127">Le système de type XAML vérifie la liste assignable et attend que l’objet qui est fourni en tant que la valeur peut être assigné à l’interface.</span><span class="sxs-lookup"><span data-stu-id="aaa90-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="aaa90-128">Il n’existe aucun concept de la façon dont l’interface doit être présentée comme un type XAML tant un type assignable approprié prend en charge les spécifications de construction XAML.</span><span class="sxs-lookup"><span data-stu-id="aaa90-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="aaa90-129">Méthodes de fabrique</span><span class="sxs-lookup"><span data-stu-id="aaa90-129">Factory Methods</span></span>  
 <span data-ttu-id="aaa90-130">Méthodes de fabrique sont une fonctionnalité de XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="aaa90-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="aaa90-131">Ils modifient le principe XAML que les objets doivent avoir des constructeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="aaa90-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="aaa90-132">Méthodes de fabrique ne sont pas documentées dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="aaa90-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="aaa90-133">Consultez [x : FactoryMethod, Directive](x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="aaa90-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="aaa90-134">Énumérations</span><span class="sxs-lookup"><span data-stu-id="aaa90-134">Enumerations</span></span>  
 <span data-ttu-id="aaa90-135">Les énumérations ont un comportement de conversion de type natif XAML.</span><span class="sxs-lookup"><span data-stu-id="aaa90-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="aaa90-136">Noms de constantes d’énumération spécifiées dans XAML sont résolus par rapport au type énumération sous-jacent et retournent la valeur d’énumération à un writer d’objet XAML.</span><span class="sxs-lookup"><span data-stu-id="aaa90-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="aaa90-137">XAML prend en charge une utilisation d’indicateurs de style pour les énumérations avec <xref:System.FlagsAttribute> appliquée.</span><span class="sxs-lookup"><span data-stu-id="aaa90-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="aaa90-138">Pour plus d’informations, consultez [syntaxe de XAML en détail](../wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="aaa90-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="aaa90-139">([Syntaxe de XAML en détail](../wpf/advanced/xaml-syntax-in-detail.md) est rédigée pour les utilisateurs WPF, mais la plupart des informations dans cette rubrique s’applique pour XAML qui n’est pas spécifique à une infrastructure d’implémentation particulière.)</span><span class="sxs-lookup"><span data-stu-id="aaa90-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="aaa90-140">Définitions de membre</span><span class="sxs-lookup"><span data-stu-id="aaa90-140">Member Definitions</span></span>  
 <span data-ttu-id="aaa90-141">Types peuvent définir des membres pour l’utilisation XAML.</span><span class="sxs-lookup"><span data-stu-id="aaa90-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="aaa90-142">Il est possible de définir des membres qui sont utilisables à XAML même si ce type spécifique n’est pas utilisable en XAML.</span><span class="sxs-lookup"><span data-stu-id="aaa90-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="aaa90-143">Cela est possible en raison de l’héritage du CLR.</span><span class="sxs-lookup"><span data-stu-id="aaa90-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="aaa90-144">Tant que certains type qui hérite du membre prend en charge l’utilisation XAML en tant que type, et le membre prend en charge l’utilisation XAML pour son type sous-jacent ou a une syntaxe XAML native disponible, ce membre est utilisable en XAML.</span><span class="sxs-lookup"><span data-stu-id="aaa90-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="aaa90-145">Properties</span><span class="sxs-lookup"><span data-stu-id="aaa90-145">Properties</span></span>  
 <span data-ttu-id="aaa90-146">Si vous définissez les propriétés comme une propriété CLR publique à l’aide du CLR standard `get` et `set` modèles d’accesseur et mots-clés approprié à la langue, le système de type XAML peut signaler fournie par la propriété en tant que membre avec les informations appropriées pour <xref:System.Xaml.XamlMember> propriétés, telles que <xref:System.Xaml.XamlMember.IsReadPublic%2A> et <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="aaa90-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="aaa90-147">Propriétés spécifiques peuvent activer une syntaxe de texte en appliquant <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="aaa90-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="aaa90-148">Pour plus d’informations, consultez [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="aaa90-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="aaa90-149">En l’absence d’une syntaxe de texte ou d’une conversion XAML native et en l’absence d’indirection supplémentaire, comme une extension de balisage, le type d’une propriété (<xref:System.Xaml.XamlMember.TargetType%2A> système de type dans le XAML) doit être en mesure de retourner une instance à un writer d’objet XAML en traitant le t type de cible comme un type CLR.</span><span class="sxs-lookup"><span data-stu-id="aaa90-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="aaa90-150">L’utilisation de XAML 2009, [x : Reference Markup Extension](x-reference-markup-extension.md) peut être utilisé pour fournir des valeurs si les considérations précédentes ne sont pas remplies ; Toutefois, qui est plus un problème d’utilisation qu’un problème de définition de type.</span><span class="sxs-lookup"><span data-stu-id="aaa90-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="aaa90-151">Événements</span><span class="sxs-lookup"><span data-stu-id="aaa90-151">Events</span></span>  
 <span data-ttu-id="aaa90-152">Si vous définissez des événements en tant qu’événement CLR public, le système de type XAML peut signaler l’événement en tant que membre avec <xref:System.Xaml.XamlMember.IsEvent%2A> comme `true`.</span><span class="sxs-lookup"><span data-stu-id="aaa90-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="aaa90-153">Les gestionnaires d’événements de câblage n’est pas dans l’étendue des fonctionnalités de Services XAML du .NET Framework ; en revanche, implémentations et les infrastructures spécifiques.</span><span class="sxs-lookup"><span data-stu-id="aaa90-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="aaa90-154">Méthodes</span><span class="sxs-lookup"><span data-stu-id="aaa90-154">Methods</span></span>  
 <span data-ttu-id="aaa90-155">Code inline des méthodes n’est pas une fonctionnalité XAML par défaut.</span><span class="sxs-lookup"><span data-stu-id="aaa90-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="aaa90-156">Dans la plupart des cas vous ne référencez pas directement les membres de méthode à partir de XAML, et le rôle des méthodes dans XAML est uniquement pour prendre en charge des modèles XAML spécifiques.</span><span class="sxs-lookup"><span data-stu-id="aaa90-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="aaa90-157">[x : FactoryMethod Directive](x-factorymethod-directive.md) est une exception.</span><span class="sxs-lookup"><span data-stu-id="aaa90-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="aaa90-158">Champs</span><span class="sxs-lookup"><span data-stu-id="aaa90-158">Fields</span></span>  
 <span data-ttu-id="aaa90-159">Instructions de conception CLR décourager les champs non statiques.</span><span class="sxs-lookup"><span data-stu-id="aaa90-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="aaa90-160">Pour les champs statiques, vous pouvez accéder à des valeurs de champ statique uniquement via [x : Static, Extension de balisage](x-static-markup-extension.md); dans ce cas vous ne font rien de spécial dans la définition du CLR pour exposer un champ pour [x : Static](x-static-markup-extension.md) utilisations.</span><span class="sxs-lookup"><span data-stu-id="aaa90-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="aaa90-161">Membres pouvant être attachés</span><span class="sxs-lookup"><span data-stu-id="aaa90-161">Attachable Members</span></span>  
 <span data-ttu-id="aaa90-162">Membres pouvant être attachés sont exposées à XAML via un modèle de méthode d’accesseur sur un type de définition.</span><span class="sxs-lookup"><span data-stu-id="aaa90-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="aaa90-163">Le type de définition lui-même est inutile être utilisable par le XAML en tant qu’objet.</span><span class="sxs-lookup"><span data-stu-id="aaa90-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="aaa90-164">En fait, il est courant de déclarer une classe de service dont le rôle est propriétaire du membre et implémenter les comportements associés, mais autre fonction comme une représentation de l’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="aaa90-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="aaa90-165">Pour les sections suivantes, l’espace réservé *PropertyName* représente le nom de votre membre pouvant être attaché.</span><span class="sxs-lookup"><span data-stu-id="aaa90-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="aaa90-166">Ce nom doit être valide dans le [XamlName, grammaire](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="aaa90-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="aaa90-167">Méfiez-vous des collisions de noms entre ces modèles et d’autres méthodes d’un type.</span><span class="sxs-lookup"><span data-stu-id="aaa90-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="aaa90-168">Si un membre existant qui correspond à l’un des modèles, il peut être interprété comme une voie d’accès au membre pouvant être attaché par un processeur XAML même si ce n’était pas votre intention.</span><span class="sxs-lookup"><span data-stu-id="aaa90-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="aaa90-169">L’accesseur GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="aaa90-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="aaa90-170">La signature pour l’accesseur `Get`*NomPropriété* doit être :</span><span class="sxs-lookup"><span data-stu-id="aaa90-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 `public static object Get` *<span data-ttu-id="aaa90-171">PropertyName</span><span class="sxs-lookup"><span data-stu-id="aaa90-171">PropertyName</span></span>* `(object`  `target` `)`  
  
-   <span data-ttu-id="aaa90-172">L’objet `target` peut être défini comme un type plus spécifique dans votre implémentation.</span><span class="sxs-lookup"><span data-stu-id="aaa90-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="aaa90-173">Vous pouvez l’utiliser pour limiter l’utilisation de votre membre pouvant être attaché ; utilisations en dehors de votre portée prévue lève des exceptions de cast non valide qui sont ensuite signalées par une erreur d’analyse XAML.</span><span class="sxs-lookup"><span data-stu-id="aaa90-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="aaa90-174">Le nom du paramètre `target` n’est pas obligatoire, mais est nommé `target` par convention dans la plupart des implémentations.</span><span class="sxs-lookup"><span data-stu-id="aaa90-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="aaa90-175">La valeur de retour peut être spécifiée comme un type plus spécifique dans votre implémentation.</span><span class="sxs-lookup"><span data-stu-id="aaa90-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="aaa90-176">Pour prendre en charge un <xref:System.ComponentModel.TypeConverter> appliquer de la syntaxe de texte est activée pour l’utilisation des attributs du membre pouvant être attachée, <xref:System.ComponentModel.TypeConverterAttribute> à la `Get` *PropertyName* accesseur.</span><span class="sxs-lookup"><span data-stu-id="aaa90-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="aaa90-177">Application à la `get` au lieu du `set` peut sembler non intuitive ; Toutefois, cette convention peut prendre en charge le concept de membres en lecture seule pouvant être attachés qui sont sérialisables, ce qui est utile dans les scénarios de concepteur.</span><span class="sxs-lookup"><span data-stu-id="aaa90-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="aaa90-178">L’accesseur SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="aaa90-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="aaa90-179">La signature pour l’ensemble*PropertyName* accesseur doit être :</span><span class="sxs-lookup"><span data-stu-id="aaa90-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 `public static void Set` *<span data-ttu-id="aaa90-180">PropertyName</span><span class="sxs-lookup"><span data-stu-id="aaa90-180">PropertyName</span></span>* `(object`  `target` `, object`  `value` `)`  
  
-   <span data-ttu-id="aaa90-181">Le `target` objet peut être spécifié comme un type plus spécifique dans votre implémentation, avec la même logique et les conséquences, comme décrit dans la section précédente.</span><span class="sxs-lookup"><span data-stu-id="aaa90-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="aaa90-182">L’objet `value` peut être défini comme un type plus spécifique dans votre implémentation.</span><span class="sxs-lookup"><span data-stu-id="aaa90-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="aaa90-183">N’oubliez pas que la valeur de cette méthode est l’entrée provenant de l’utilisation XAML, généralement sous la forme d’attribut.</span><span class="sxs-lookup"><span data-stu-id="aaa90-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="aaa90-184">À partir de la forme d’attribut doit être prise en charge de convertisseur de valeur pour une syntaxe de texte, et vous attribut sur le `Get` *PropertyName* accesseur.</span><span class="sxs-lookup"><span data-stu-id="aaa90-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="aaa90-185">Magasins de membres pouvant être attachée</span><span class="sxs-lookup"><span data-stu-id="aaa90-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="aaa90-186">Les méthodes d’accesseur ne sont généralement pas suffisamment pour fournir un moyen de placer des valeurs de membre pouvant être attaché dans un graphique d’objet, ou pour extraire des valeurs de graphique d’objet et les sérialiser correctement.</span><span class="sxs-lookup"><span data-stu-id="aaa90-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="aaa90-187">Pour offrir cette fonctionnalité, le `target` objets dans les signatures d’accesseur précédentes doivent être capables de stocker des valeurs.</span><span class="sxs-lookup"><span data-stu-id="aaa90-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="aaa90-188">Le mécanisme de stockage doit être conforme au principe de membre pouvant être attaché constituant le membre pouvant être attaché aux cibles où le membre pouvant être attaché n’est pas dans la liste des membres.</span><span class="sxs-lookup"><span data-stu-id="aaa90-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="aaa90-189">Les Services XAML .NET framework fournit une technique d’implémentation pour le membre pouvant être attaché stocke via les API <xref:System.Xaml.IAttachedPropertyStore> et <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="aaa90-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <xref:System.Xaml.IAttachedPropertyStore> <span data-ttu-id="aaa90-190">est utilisé par les writers XAML pour découvrir l’implémentation de magasin et doit être implémenté sur le type qui est la `target` des accesseurs.</span><span class="sxs-lookup"><span data-stu-id="aaa90-190">is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="aaa90-191">La méthode statique <xref:System.Xaml.AttachablePropertyServices> API sont utilisées dans le corps des accesseurs et faire référence au membre pouvant être attaché par son <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="aaa90-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="aaa90-192">Attributs CLR XAML</span><span class="sxs-lookup"><span data-stu-id="aaa90-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="aaa90-193">Attribution correctement vos types, membres et des assemblys est important dans l’ordre à signaler les informations de système de type XAML pour les Services XAML .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="aaa90-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="aaa90-194">Cela est utile si vous avez l’intention d’utiliser avec les systèmes XAML qui sont directement basés sur les lecteurs XAML de Services XAML .NET Framework et les writers XAML vos types, ou si vous définissez ou utilisez une infrastructure utilisent XAML qui repose sur ces lecteurs XAML et les writers XAML.</span><span class="sxs-lookup"><span data-stu-id="aaa90-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="aaa90-195">Pour obtenir la liste de chaque attribut de XAML qui est pertinente pour la prise en charge XAML de vos types personnalisés, consultez [Related CLR attributs pour les bibliothèques et Types personnalisés](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="aaa90-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="aaa90-196">Utilisation</span><span class="sxs-lookup"><span data-stu-id="aaa90-196">Usage</span></span>  
 <span data-ttu-id="aaa90-197">L’utilisation de types personnalisés requiert que l’auteur du balisage doit mapper un préfixe pour l’assembly et l’espace de noms CLR qui contiennent le type personnalisé.</span><span class="sxs-lookup"><span data-stu-id="aaa90-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="aaa90-198">Cette procédure n’est pas documentée dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="aaa90-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="aaa90-199">Niveau d’accès</span><span class="sxs-lookup"><span data-stu-id="aaa90-199">Access Level</span></span>  
 <span data-ttu-id="aaa90-200">XAML fournit un moyen pour charger et instancier des types qui ont un `internal` niveau d’accès.</span><span class="sxs-lookup"><span data-stu-id="aaa90-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="aaa90-201">Cette fonctionnalité est fournie afin que le code utilisateur peut définir ses propres types, puis instancier les classes à partir du balisage qui fait également partie de la même portée de code utilisateur.</span><span class="sxs-lookup"><span data-stu-id="aaa90-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="aaa90-202">Par exemple à partir de WPF, chaque fois que le code de l’utilisateur définit un <xref:System.Windows.Controls.UserControl> qui est conçu comme un moyen de refactoriser un comportement de l’interface utilisateur, mais pas dans le cadre de n’importe quel mécanisme d’extension possible qui peut être déduite d’une déclaration de la classe de prise en charge avec `public` niveau d’accès.</span><span class="sxs-lookup"><span data-stu-id="aaa90-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="aaa90-203">Tel un <xref:System.Windows.Controls.UserControl> peuvent être déclarés avec `internal` accéder si le code de stockage est compilé dans le même assembly à partir duquel il est référencé comme un type XAML.</span><span class="sxs-lookup"><span data-stu-id="aaa90-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="aaa90-204">Pour une application qui charge le XAML sous confiance totale et utilise <xref:System.Xaml.XamlObjectWriter>, chargement de classes avec `internal` niveau d’accès est toujours activé.</span><span class="sxs-lookup"><span data-stu-id="aaa90-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="aaa90-205">Pour une application qui charge le XAML sous confiance partielle, vous pouvez contrôler les caractéristiques de niveau d’accès à l’aide de la <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="aaa90-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="aaa90-206">En outre, des mécanismes de différé (par exemple, le système de modèle de WPF) doivent pouvoir propager les autorisations de niveau d’accès et de les conserver pour les évaluations éventuelle exécution ; Ceci est géré en interne en passant le <xref:System.Xaml.Permissions.XamlAccessLevel> plus d’informations.</span><span class="sxs-lookup"><span data-stu-id="aaa90-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="aaa90-207">Implémentation de WPF</span><span class="sxs-lookup"><span data-stu-id="aaa90-207">WPF Implementation</span></span>  
 <span data-ttu-id="aaa90-208">WPF XAML utilise un modèle d’accès de niveau de confiance partiel où Si BAML est chargé en confiance partielle, l’accès est limité à <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> pour l’assembly qui est la source BAML.</span><span class="sxs-lookup"><span data-stu-id="aaa90-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="aaa90-209">Report, WPF utilise <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> comme un mécanisme pour passer les informations au niveau d’accès.</span><span class="sxs-lookup"><span data-stu-id="aaa90-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="aaa90-210">Dans la terminologie de WPF XAML, un *type interne* est un type qui est défini par le même assembly qui inclut également le XAML de référencement.</span><span class="sxs-lookup"><span data-stu-id="aaa90-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="aaa90-211">Ce type peut être mappé par un espace de noms XAML qui omet délibérément l’assembly = partie d’un mappage, par exemple, `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="aaa90-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="aaa90-212">Si BAML fait référence à un type interne et que le type a `internal` accéder à niveau, cela génère un `GeneratedInternalTypeHelper` classe pour l’assembly.</span><span class="sxs-lookup"><span data-stu-id="aaa90-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="aaa90-213">Si vous souhaitez éviter `GeneratedInternalTypeHelper`, vous devez utiliser `public` niveau d’accès ou doit tenir compte de la classe appropriée dans un assembly distinct et créez une dépendance entre cet assembly.</span><span class="sxs-lookup"><span data-stu-id="aaa90-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="aaa90-214">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="aaa90-214">See also</span></span>

- [<span data-ttu-id="aaa90-215">Attributs CLR XAML pour les bibliothèques et types personnalisés</span><span class="sxs-lookup"><span data-stu-id="aaa90-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="aaa90-216">Services XAML</span><span class="sxs-lookup"><span data-stu-id="aaa90-216">XAML Services</span></span>](index.md)
