---
title: ICorProfilerInfo2::DoStackSnapshot, méthode
ms.date: 03/30/2017
api_name:
- ICorProfilerInfo2.DoStackSnapshot
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type:
- apiref
author: mairaw
ms.author: mairaw
ms.openlocfilehash: f3a558ad6f87995d6c0a0d164cf96376fba12da4
ms.sourcegitcommit: 5137208fa414d9ca3c58cdfd2155ac81bc89e917
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/06/2019
ms.locfileid: "57485263"
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a><span data-ttu-id="5b67c-102">ICorProfilerInfo2::DoStackSnapshot, méthode</span><span class="sxs-lookup"><span data-stu-id="5b67c-102">ICorProfilerInfo2::DoStackSnapshot Method</span></span>
<span data-ttu-id="5b67c-103">Parcourt les frames managés sur la pile pour le thread spécifié et envoie des informations au profileur via un rappel.</span><span class="sxs-lookup"><span data-stu-id="5b67c-103">Walks the managed frames on the stack for the specified thread, and sends information to the profiler through a callback.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="5b67c-104">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="5b67c-104">Syntax</span></span>  
  
```  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
## <a name="parameters"></a><span data-ttu-id="5b67c-105">Paramètres</span><span class="sxs-lookup"><span data-stu-id="5b67c-105">Parameters</span></span>  
 `thread`  
 <span data-ttu-id="5b67c-106">[in] L’ID du thread cible.</span><span class="sxs-lookup"><span data-stu-id="5b67c-106">[in] The ID of the target thread.</span></span>  
  
 <span data-ttu-id="5b67c-107">Le passage de null dans `thread` produit un instantané du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="5b67c-107">Passing null in `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="5b67c-108">Si un `ThreadID` d’un thread différent est passé, le common language runtime (CLR) suspend ce thread, exécute l’instantané et reprend.</span><span class="sxs-lookup"><span data-stu-id="5b67c-108">If a `ThreadID` of a different thread is passed, the common language runtime (CLR) suspends that thread, performs the snapshot, and resumes.</span></span>  
  
 `callback`  
 <span data-ttu-id="5b67c-109">[in] Un pointeur vers l’implémentation de la [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) (méthode), qui est appelée par le CLR pour fournir le profileur des informations sur chaque frame managé et chaque exécution de trames non gérées.</span><span class="sxs-lookup"><span data-stu-id="5b67c-109">[in] A pointer to the implementation of the [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) method, which is called by the CLR to provide the profiler with information on each managed frame and each run of unmanaged frames.</span></span>  
  
 <span data-ttu-id="5b67c-110">Le `StackSnapshotCallback` méthode est implémentée par le writer de profileur.</span><span class="sxs-lookup"><span data-stu-id="5b67c-110">The `StackSnapshotCallback` method is implemented by the profiler writer.</span></span>  
  
 `infoFlags`  
 <span data-ttu-id="5b67c-111">[in] Une valeur de la [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) énumération qui spécifie la quantité de données à renvoyer pour chaque frame par `StackSnapshotCallback`.</span><span class="sxs-lookup"><span data-stu-id="5b67c-111">[in] A value of the [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) enumeration, which specifies the amount of data to be passed back for each frame by `StackSnapshotCallback`.</span></span>  
  
 `clientData`  
 <span data-ttu-id="5b67c-112">[in] Un pointeur vers les données du client, qui sont transmis directement vers le `StackSnapshotCallback` fonction de rappel.</span><span class="sxs-lookup"><span data-stu-id="5b67c-112">[in] A pointer to the client data, which is passed straight through to the `StackSnapshotCallback` callback function.</span></span>  
  
 `context`  
 <span data-ttu-id="5b67c-113">[in] Un pointeur vers un Win32 `CONTEXT` structure, qui est utilisé pour amorcer le parcours de pile.</span><span class="sxs-lookup"><span data-stu-id="5b67c-113">[in] A pointer to a Win32 `CONTEXT` structure, which is used to seed the stack walk.</span></span> <span data-ttu-id="5b67c-114">Win32 `CONTEXT` structure contient les valeurs des registres du processeur et représente l’état de l’UC à un moment donné dans le temps.</span><span class="sxs-lookup"><span data-stu-id="5b67c-114">The Win32 `CONTEXT` structure contains values of the CPU registers and represents the state of the CPU at a particular moment in time.</span></span>  
  
 <span data-ttu-id="5b67c-115">La valeur de départ aide le CLR à déterminer où commencer le parcours de pile, si le haut de la pile est un code non managé d’assistance ; Sinon, la valeur de départ est ignorée.</span><span class="sxs-lookup"><span data-stu-id="5b67c-115">The seed helps the CLR determine where to begin the stack walk, if the top of the stack is unmanaged helper code; otherwise, the seed is ignored.</span></span> <span data-ttu-id="5b67c-116">Une valeur de départ doit être fournie pour un parcours asynchrone.</span><span class="sxs-lookup"><span data-stu-id="5b67c-116">A seed must be supplied for an asynchronous walk.</span></span> <span data-ttu-id="5b67c-117">Si vous effectuez un parcours synchrone, aucune valeur de départ n’est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="5b67c-117">If you are doing a synchronous walk, no seed is necessary.</span></span>  
  
 <span data-ttu-id="5b67c-118">Le `context` paramètre est valide uniquement si l’indicateur COR_PRF_SNAPSHOT_CONTEXT a été passé dans le `infoFlags` paramètre.</span><span class="sxs-lookup"><span data-stu-id="5b67c-118">The `context` parameter is valid only if the COR_PRF_SNAPSHOT_CONTEXT flag was passed in the `infoFlags` parameter.</span></span>  
  
 `contextSize`  
 <span data-ttu-id="5b67c-119">[in] La taille de la `CONTEXT` structure, ce qui est référencé par le `context` paramètre.</span><span class="sxs-lookup"><span data-stu-id="5b67c-119">[in] The size of the `CONTEXT` structure, which is referenced by the `context` parameter.</span></span>  
  
## <a name="remarks"></a><span data-ttu-id="5b67c-120">Notes</span><span class="sxs-lookup"><span data-stu-id="5b67c-120">Remarks</span></span>  
 <span data-ttu-id="5b67c-121">Le passage de null pour `thread` produit un instantané du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="5b67c-121">Passing null for `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="5b67c-122">Captures instantanées peuvent provenir d’autres threads uniquement si le thread cible est suspendu en temps.</span><span class="sxs-lookup"><span data-stu-id="5b67c-122">Snapshots can be taken of other threads only if the target thread is suspended at the time.</span></span>  
  
 <span data-ttu-id="5b67c-123">Lorsque le profileur souhaite remonter la pile, il appelle `DoStackSnapshot`.</span><span class="sxs-lookup"><span data-stu-id="5b67c-123">When the profiler wants to walk the stack, it calls `DoStackSnapshot`.</span></span> <span data-ttu-id="5b67c-124">Avant que le CLR est retournée à partir de cet appel, il appelle votre `StackSnapshotCallback` plusieurs fois, une fois pour chaque frame managé (ou exécution de trames non gérées) sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5b67c-124">Before the CLR returns from that call, it calls your `StackSnapshotCallback` several times, once for each managed frame (or run of unmanaged frames) on the stack.</span></span> <span data-ttu-id="5b67c-125">Lorsque des trames non gérées sont rencontrées, vous devez vous-même les parcourir.</span><span class="sxs-lookup"><span data-stu-id="5b67c-125">When unmanaged frames are encountered, you must walk them yourself.</span></span>  
  
 <span data-ttu-id="5b67c-126">L’ordre dans lequel la pile est parcourue est l’inverse de la façon dont les images ont été envoyées à la pile : feuille de dernière (envoyée en dernière) tout d’abord, principal (premier push) image.</span><span class="sxs-lookup"><span data-stu-id="5b67c-126">The order in which the stack is walked is the reverse of how the frames were pushed onto the stack: leaf (last-pushed) frame first, main (first-pushed) frame last.</span></span>  
  
 <span data-ttu-id="5b67c-127">Pour plus d’informations sur comment programmer le profileur permettant de remonter les piles gérées, consultez [Profiler parcours de la pile dans le .NET Framework 2.0 : Principes de base et d’autres fonctionnalités](https://go.microsoft.com/fwlink/?LinkId=73638).</span><span class="sxs-lookup"><span data-stu-id="5b67c-127">For more information about how to program the profiler to walk managed stacks, see [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://go.microsoft.com/fwlink/?LinkId=73638).</span></span>  
  
 <span data-ttu-id="5b67c-128">Un parcours de pile peut être synchrone ou asynchrone, comme expliqué dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="5b67c-128">A stack walk can be synchronous or asynchronous, as explained in the following sections.</span></span>  
  
## <a name="synchronous-stack-walk"></a><span data-ttu-id="5b67c-129">Parcours de pile synchrone</span><span class="sxs-lookup"><span data-stu-id="5b67c-129">Synchronous Stack Walk</span></span>  
 <span data-ttu-id="5b67c-130">Un parcours de pile synchrone implique le parcours de la pile du thread actuel en réponse à un rappel.</span><span class="sxs-lookup"><span data-stu-id="5b67c-130">A synchronous stack walk involves walking the stack of the current thread in response to a callback.</span></span> <span data-ttu-id="5b67c-131">Il ne nécessite pas l’amorçage ou à suspendre.</span><span class="sxs-lookup"><span data-stu-id="5b67c-131">It does not require seeding or suspending.</span></span>  
  
 <span data-ttu-id="5b67c-132">Vous apportez synchrone lorsque, appeler en réponse à l’appel d’un de votre profileur CLR [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (ou [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) méthodes, vous appelez `DoStackSnapshot` pour remonter la pile de la thread actuel.</span><span class="sxs-lookup"><span data-stu-id="5b67c-132">You make a synchronous call when, in response to the CLR calling one of your profiler's [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (or [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) methods, you call `DoStackSnapshot` to walk the stack of the current thread.</span></span> <span data-ttu-id="5b67c-133">Cela est utile lorsque vous souhaitez voir à quoi la pile ressemble à une notification comme [ICorProfilerCallback::ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span><span class="sxs-lookup"><span data-stu-id="5b67c-133">This is useful when you want to see what the stack looks like at a notification such as [ICorProfilerCallback::ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span></span> <span data-ttu-id="5b67c-134">Vous appelez simplement `DoStackSnapshot` depuis votre `ICorProfilerCallback` méthode, en passant la valeur null dans le `context` et `thread` paramètres.</span><span class="sxs-lookup"><span data-stu-id="5b67c-134">You just call `DoStackSnapshot` from within your `ICorProfilerCallback` method, passing null in the `context` and `thread` parameters.</span></span>  
  
## <a name="asynchronous-stack-walk"></a><span data-ttu-id="5b67c-135">Parcours de pile asynchrone</span><span class="sxs-lookup"><span data-stu-id="5b67c-135">Asynchronous Stack Walk</span></span>  
 <span data-ttu-id="5b67c-136">Un parcours de pile asynchrone implique de remonter la pile d’un thread différent, ou remonter la pile du thread actuel, pas en réponse à un rappel, mais par piratage du pointeur d’instruction du thread actif.</span><span class="sxs-lookup"><span data-stu-id="5b67c-136">An asynchronous stack walk entails walking the stack of a different thread, or walking the stack of the current thread, not in response to a callback, but by hijacking the current thread's instruction pointer.</span></span> <span data-ttu-id="5b67c-137">Un parcours asynchrone requiert une valeur initiale si le haut de la pile est un code non managé qui ne fait pas partie d’une plateforme appel (PInvoke) ou appel COM, mais code d’assistance dans le CLR lui-même.</span><span class="sxs-lookup"><span data-stu-id="5b67c-137">An asynchronous walk requires a seed if the top of the stack is unmanaged code that is not part of a platform invoke (PInvoke) or COM call, but helper code in the CLR itself.</span></span> <span data-ttu-id="5b67c-138">Par exemple, un code qui effectue juste-à-temps (JIT) compilation ou le garbage collection est code d’assistance.</span><span class="sxs-lookup"><span data-stu-id="5b67c-138">For example, code that does just-in-time (JIT) compiling or garbage collection is helper code.</span></span>  
  
 <span data-ttu-id="5b67c-139">Vous obtenez une valeur initiale par directement suspende le thread cible et remonter sa pile vous-même, jusqu'à ce que vous trouviez le premier frame managé.</span><span class="sxs-lookup"><span data-stu-id="5b67c-139">You obtain a seed by directly suspending the target thread and walking its stack yourself, until you find the topmost managed frame.</span></span> <span data-ttu-id="5b67c-140">Une fois que le thread cible est suspendu, obtenez le contexte de Registre actuel du thread cible.</span><span class="sxs-lookup"><span data-stu-id="5b67c-140">After the target thread is suspended, get the target thread's current register context.</span></span> <span data-ttu-id="5b67c-141">Ensuite, déterminez si le contexte de Registre pointe au code non managé en appelant [ICorProfilerInfo::GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) — si elle retourne un `FunctionID` égale à zéro, le frame est de code non managé.</span><span class="sxs-lookup"><span data-stu-id="5b67c-141">Next, determine whether the register context points to unmanaged code by calling [ICorProfilerInfo::GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) — if it returns a `FunctionID` equal to zero, the frame is unmanaged code.</span></span> <span data-ttu-id="5b67c-142">À présent, remonter la pile jusqu'à ce que la première trame gérée, puis calculer le contexte de base selon le contexte de Registre pour ce frame.</span><span class="sxs-lookup"><span data-stu-id="5b67c-142">Now, walk the stack until you reach the first managed frame, and then calculate the seed context based on the register context for that frame.</span></span>  
  
 <span data-ttu-id="5b67c-143">Appelez `DoStackSnapshot` avec votre contexte de base pour commencer le parcours de pile asynchrone.</span><span class="sxs-lookup"><span data-stu-id="5b67c-143">Call `DoStackSnapshot` with your seed context to begin the asynchronous stack walk.</span></span> <span data-ttu-id="5b67c-144">Si vous ne fournissez pas une valeur de départ, `DoStackSnapshot` peut ignorer les frames managés en haut de la pile et, par conséquent, vous donnera un parcours de pile incomplète.</span><span class="sxs-lookup"><span data-stu-id="5b67c-144">If you do not supply a seed, `DoStackSnapshot` might skip managed frames at the top of the stack and, consequently, will give you an incomplete stack walk.</span></span> <span data-ttu-id="5b67c-145">Si vous ne fournissez pas une valeur de départ, il doit pointer vers la compilation JIT ou Native Image Generator (Ngen.exe)-généré le code ; Sinon, `DoStackSnapshot` renvoie le code d’échec CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span><span class="sxs-lookup"><span data-stu-id="5b67c-145">If you do supply a seed, it must point to JIT-compiled or Native Image Generator (Ngen.exe)-generated code; otherwise, `DoStackSnapshot` returns the failure code, CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span></span>  
  
 <span data-ttu-id="5b67c-146">Parcours de pile asynchrones peuvent facilement provoquer des interblocages ou violations d’accès, sauf si vous suivez ces instructions :</span><span class="sxs-lookup"><span data-stu-id="5b67c-146">Asynchronous stack walks can easily cause deadlocks or access violations, unless you follow these guidelines:</span></span>  
  
-   <span data-ttu-id="5b67c-147">Lorsque vous interrompez directement des threads, n’oubliez pas que seul un thread qui n’a jamais exécuté du code managé peut suspendre un autre thread.</span><span class="sxs-lookup"><span data-stu-id="5b67c-147">When you directly suspend threads, remember that only a thread that has never run managed code can suspend another thread.</span></span>  
  
-   <span data-ttu-id="5b67c-148">Toujours bloquer votre [ICorProfilerCallback::ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) rappel jusqu'à la fin de parcours de pile de ce thread.</span><span class="sxs-lookup"><span data-stu-id="5b67c-148">Always block in your [ICorProfilerCallback::ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) callback until that thread's stack walk is complete.</span></span>  
  
-   <span data-ttu-id="5b67c-149">Ne détenez pas un verrou pendant que votre profileur appelle une fonction CLR pouvant déclencher un garbage collection.</span><span class="sxs-lookup"><span data-stu-id="5b67c-149">Do not hold a lock while your profiler calls into a CLR function that can trigger a garbage collection.</span></span> <span data-ttu-id="5b67c-150">Autrement dit, ne détenez pas un verrou si le thread propriétaire peut effectuer un appel qui déclenche un garbage collection.</span><span class="sxs-lookup"><span data-stu-id="5b67c-150">That is, do not hold a lock if the owning thread might make a call that triggers a garbage collection.</span></span>  
  
 <span data-ttu-id="5b67c-151">Il existe également un risque d’interblocage si vous appelez `DoStackSnapshot` à partir d’un thread que votre profileur a créé afin que vous pouvez parcourir la pile d’un thread cible séparé.</span><span class="sxs-lookup"><span data-stu-id="5b67c-151">There is also a risk of deadlock if you call `DoStackSnapshot` from a thread that your profiler has created so that you can walk the stack of a separate target thread.</span></span> <span data-ttu-id="5b67c-152">La première fois que le thread que vous avez créé entre certaines `ICorProfilerInfo*` méthodes (y compris `DoStackSnapshot`), le CLR effectuera une initialisation par thread, spécifique au CLR sur ce thread.</span><span class="sxs-lookup"><span data-stu-id="5b67c-152">The first time the thread you created enters certain `ICorProfilerInfo*` methods (including `DoStackSnapshot`), the CLR will perform per-thread, CLR-specific initialization on that thread.</span></span> <span data-ttu-id="5b67c-153">Si votre profileur a suspendu le thread cible dont vous essayez de parcourir la pile, et si ce thread cible est arrivé à possède un verrou nécessaires pour effectuer cette initialisation par thread, un interblocage se produit.</span><span class="sxs-lookup"><span data-stu-id="5b67c-153">If your profiler has suspended the target thread whose stack you are trying to walk, and if that target thread happened to own a lock necessary for performing this per-thread initialization, a deadlock will occur.</span></span> <span data-ttu-id="5b67c-154">Pour éviter ce blocage, faites un appel initial à `DoStackSnapshot` à partir de votre thread créé le profileur permettant de remonter thread cible distinct, mais n’interrompez pas le thread cible au préalable.</span><span class="sxs-lookup"><span data-stu-id="5b67c-154">To avoid this deadlock, make an initial call into `DoStackSnapshot` from your profiler-created thread to walk a separate target thread, but do not suspend the target thread first.</span></span> <span data-ttu-id="5b67c-155">Cet appel initial garantit que l’initialisation par thread peut s’effectuer sans blocage.</span><span class="sxs-lookup"><span data-stu-id="5b67c-155">This initial call ensures that the per-thread initialization can complete without deadlock.</span></span> <span data-ttu-id="5b67c-156">Si `DoStackSnapshot` réussit et signale au moins une frame, après ce point, il sera sécurisé pour ce thread créé le profileur à interrompre n’importe quel thread cible et l’appel `DoStackSnapshot` pour remonter la pile du thread cible.</span><span class="sxs-lookup"><span data-stu-id="5b67c-156">If `DoStackSnapshot` succeeds and reports at least one frame, after that point, it will be safe for that profiler-created thread to suspend any target thread and call `DoStackSnapshot` to walk the stack of that target thread.</span></span>  
  
## <a name="requirements"></a><span data-ttu-id="5b67c-157">Spécifications</span><span class="sxs-lookup"><span data-stu-id="5b67c-157">Requirements</span></span>  
 <span data-ttu-id="5b67c-158">**Plateformes :** Consultez [Configuration requise](../../../../docs/framework/get-started/system-requirements.md).</span><span class="sxs-lookup"><span data-stu-id="5b67c-158">**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).</span></span>  
  
 <span data-ttu-id="5b67c-159">**En-tête :** CorProf.idl, CorProf.h</span><span class="sxs-lookup"><span data-stu-id="5b67c-159">**Header:** CorProf.idl, CorProf.h</span></span>  
  
 <span data-ttu-id="5b67c-160">**Bibliothèque :** CorGuids.lib</span><span class="sxs-lookup"><span data-stu-id="5b67c-160">**Library:** CorGuids.lib</span></span>  
  
 <span data-ttu-id="5b67c-161">**Versions du .NET Framework :** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span><span class="sxs-lookup"><span data-stu-id="5b67c-161">**.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5b67c-162">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="5b67c-162">See also</span></span>
- [<span data-ttu-id="5b67c-163">ICorProfilerInfo, interface</span><span class="sxs-lookup"><span data-stu-id="5b67c-163">ICorProfilerInfo Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)
- [<span data-ttu-id="5b67c-164">ICorProfilerInfo2, interface</span><span class="sxs-lookup"><span data-stu-id="5b67c-164">ICorProfilerInfo2 Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)
