---
title: Fonctionnement de l'accélération dans PLINQ
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: bc36c926ba81de8a59ff3af69719bec6b7370efc
ms.sourcegitcommit: ad99773e5e45068ce03b99518008397e1299e0d1
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/22/2018
ms.locfileid: "46586842"
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="1c11e-102">Fonctionnement de l'accélération dans PLINQ</span><span class="sxs-lookup"><span data-stu-id="1c11e-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="1c11e-103">Le principal objectif de PLINQ est d’accélérer l’exécution de requêtes LINQ to Objects en exécutant parallèlement les délégués de requête sur des ordinateurs multicœurs.</span><span class="sxs-lookup"><span data-stu-id="1c11e-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="1c11e-104">PLINQ accomplit les meilleures performances lorsque le traitement de chaque élément dans une collection source est indépendant, sans aucun état partagé parmi les délégués individuels.</span><span class="sxs-lookup"><span data-stu-id="1c11e-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="1c11e-105">Ces opérations sont courantes dans LINQ to Objects et PLINQ et sont souvent appelées « *délicieusement parallèles* », car elles se prêtent facilement à la planification sur plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="1c11e-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="1c11e-106">Toutefois, toutes les requêtes ne sont pas entièrement constituées d’opérations délicieusement parallèles ; dans la plupart des cas, une requête concerne certains opérateurs qui ne peuvent pas être parallélisés, ou qui ralentissent l’exécution parallèle.</span><span class="sxs-lookup"><span data-stu-id="1c11e-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="1c11e-107">Et même dans le cas de requêtes qui sont entièrement délicieusement parallèles, PLINQ doit encore partitionner la source de données et planifier le travail sur les threads et, généralement, fusionner les résultats lorsque la requête est terminée.</span><span class="sxs-lookup"><span data-stu-id="1c11e-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="1c11e-108">Toutes ces opérations ajoutent au coût de calcul de la parallélisation ; ces coûts d’ajout de parallélisation sont appelés *surcharge*.</span><span class="sxs-lookup"><span data-stu-id="1c11e-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="1c11e-109">Pour optimiser les performances dans une requête PLINQ, l’objectif est d’augmenter les parties délicieusement parallèles et de réduire au minimum les parties qui nécessitent une surcharge.</span><span class="sxs-lookup"><span data-stu-id="1c11e-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="1c11e-110">Cet article fournit des informations qui vous aideront à écrire des requêtes PLINQ aussi efficaces que possible, tout en produisant des résultats corrects.</span><span class="sxs-lookup"><span data-stu-id="1c11e-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="1c11e-111">Facteurs ayant un impact sur les performances des requêtes</span><span class="sxs-lookup"><span data-stu-id="1c11e-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="1c11e-112">Les sections suivantes répertorient certains des facteurs plus importants ayant un impact sur les performances des requêtes parallèles.</span><span class="sxs-lookup"><span data-stu-id="1c11e-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="1c11e-113">Il s’agit d’instructions générales qui ne sont en soi pas suffisantes pour prédire les performances des requêtes dans tous les cas.</span><span class="sxs-lookup"><span data-stu-id="1c11e-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="1c11e-114">Comme toujours, il est important de mesurer les performances réelles de requêtes spécifiques sur des ordinateurs avec une plage de configurations et de charges représentatives.</span><span class="sxs-lookup"><span data-stu-id="1c11e-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="1c11e-115">Coût de calcul du travail global.</span><span class="sxs-lookup"><span data-stu-id="1c11e-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="1c11e-116">Pour atteindre l’accélération, une requête PLINQ doit avoir suffisamment de travail délicieusement parallèle pour compenser la surcharge.</span><span class="sxs-lookup"><span data-stu-id="1c11e-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="1c11e-117">Le travail peut être exprimé comme le coût de calcul de chaque délégué multiplié par le nombre d’éléments dans la collection source.</span><span class="sxs-lookup"><span data-stu-id="1c11e-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="1c11e-118">En supposant qu’une opération peut être parallélisée, plus elle est coûteuse en matière de calcul, plus la possibilité d’accélération est grande.</span><span class="sxs-lookup"><span data-stu-id="1c11e-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="1c11e-119">Par exemple, si une fonction s’exécute en une milliseconde, une requête séquentielle de 1 000 éléments prendra une seconde, tandis qu’une requête parallèle sur un ordinateur doté de quatre cœurs ne prendra probablement que 250 millisecondes.</span><span class="sxs-lookup"><span data-stu-id="1c11e-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="1c11e-120">Il en résulte une accélération de 750 millisecondes.</span><span class="sxs-lookup"><span data-stu-id="1c11e-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="1c11e-121">Si la fonction mettait une seconde à s’exécuter pour chaque élément, l’accélération sera de 750 secondes.</span><span class="sxs-lookup"><span data-stu-id="1c11e-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="1c11e-122">Si le délégué est très coûteux, PLINQ peut offrir une accélération significative avec uniquement quelques éléments dans la collection source.</span><span class="sxs-lookup"><span data-stu-id="1c11e-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="1c11e-123">À l’inverse, de petites collections source avec des délégués triviaux ne sont généralement pas bons candidats pour PLINQ.</span><span class="sxs-lookup"><span data-stu-id="1c11e-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="1c11e-124">Dans l’exemple suivant, queryA est probablement un bon candidat pour PLINQ, en supposant que sa fonction Select implique de nombreuses tâches.</span><span class="sxs-lookup"><span data-stu-id="1c11e-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="1c11e-125">queryB n’est probablement pas un bon candidat, car il n’y a pas suffisamment de travail dans l’instruction Select, et la surcharge de parallélisation compensera la plus grande partie ou la totalité de l’accélération.</span><span class="sxs-lookup"><span data-stu-id="1c11e-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="1c11e-126">Nombre de cœurs logiques sur le système (degré de parallélisme).</span><span class="sxs-lookup"><span data-stu-id="1c11e-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="1c11e-127">Ce point est un corollaire évident de la section précédente : lLes requêtes délicieusement parallèles s’exécutent plus rapidement sur des ordinateurs au nombre de cœurs plus élevé, car le travail peut être divisé entre davantage de threads simultanés.</span><span class="sxs-lookup"><span data-stu-id="1c11e-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="1c11e-128">L’accélération globale dépend du pourcentage de travail global parallèle de la requête.</span><span class="sxs-lookup"><span data-stu-id="1c11e-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="1c11e-129">Toutefois, ne supposez pas que toutes les requêtes s’exécuteront deux fois plus vite sur un ordinateur à huit cœurs que sur un ordinateur à quatre cœurs.</span><span class="sxs-lookup"><span data-stu-id="1c11e-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="1c11e-130">Lors du paramétrage des requêtes pour des performances optimales, il est important de mesurer les résultats réels sur des ordinateurs avec des nombres de cœurs différents.</span><span class="sxs-lookup"><span data-stu-id="1c11e-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="1c11e-131">Ce point est lié au point numéro 1 : des jeux de données plus volumineux sont nécessaires pour tirer parti de ressources de calcul plus importantes.</span><span class="sxs-lookup"><span data-stu-id="1c11e-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="1c11e-132">Le nombre et le type d’opérations.</span><span class="sxs-lookup"><span data-stu-id="1c11e-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="1c11e-133">PLINQ fournit l’opérateur AsOrdered pour les situations dans lesquelles il est nécessaire de conserver l’ordre des éléments dans la séquence source.</span><span class="sxs-lookup"><span data-stu-id="1c11e-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="1c11e-134">Un coût est associé à la commande, mais il est généralement modeste.</span><span class="sxs-lookup"><span data-stu-id="1c11e-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="1c11e-135">Les opérations GroupBy et Join entraînent également une surcharge.</span><span class="sxs-lookup"><span data-stu-id="1c11e-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="1c11e-136">PLINQ offre les meilleures performances lorsqu’elle est autorisée à traiter les éléments de la collection source dans n’importe quel ordre et à les passer à l’opérateur suivant dès qu’ils sont prêts.</span><span class="sxs-lookup"><span data-stu-id="1c11e-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="1c11e-137">Pour plus d’informations, consultez [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md) (Conservation de l’ordre dans PLINQ).</span><span class="sxs-lookup"><span data-stu-id="1c11e-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="1c11e-138">Formulaire d'exécution des requêtes.</span><span class="sxs-lookup"><span data-stu-id="1c11e-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="1c11e-139">Si vous stockez les résultats d’une requête en appelant ToArray ou ToList, les résultats de tous les threads parallèles doivent être fusionnés dans la structure de données unique.</span><span class="sxs-lookup"><span data-stu-id="1c11e-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="1c11e-140">Ceci implique un coût de calcul inévitable.</span><span class="sxs-lookup"><span data-stu-id="1c11e-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="1c11e-141">De même, si vous itérez les résultats à l’aide d’une boucle foreach (For Each en Visual Basic), les résultats des threads de travail doivent être sérialisés sur le thread de l’énumérateur.</span><span class="sxs-lookup"><span data-stu-id="1c11e-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="1c11e-142">Mais si vous souhaitez simplement effectuer une action en fonction du résultat de chaque thread, vous pouvez utiliser la méthode ForAll pour exécuter ce travail sur plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="1c11e-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="1c11e-143">Le type des options de fusion.</span><span class="sxs-lookup"><span data-stu-id="1c11e-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="1c11e-144">PLINQ peut être configuré pour mettre en mémoire tampon sa sortie et en produire des segments ou la totalité après avoir produit le jeu de résultats entier, ou enfin transmettre en continu des résultats individuels à mesure qu'ils sont produits.</span><span class="sxs-lookup"><span data-stu-id="1c11e-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="1c11e-145">Le premier résultat représente le temps d'exécution réduit et les derniers résultats représentent la latence entre les éléments produits.</span><span class="sxs-lookup"><span data-stu-id="1c11e-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="1c11e-146">Tandis que les options de fusion n'ont pas toujours une incidence majeure sur les performances globales de la requête, elles peuvent affecter les performances perçues dans la mesure où elles contrôlent la durée d'attente d'un utilisateur avant consultation des résultats.</span><span class="sxs-lookup"><span data-stu-id="1c11e-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="1c11e-147">Pour plus d’informations, consultez l’article [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md) (Options de fusion de PLINQ).</span><span class="sxs-lookup"><span data-stu-id="1c11e-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="1c11e-148">Types de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="1c11e-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="1c11e-149">Dans certains cas, une requête PLINQ sur une collection source indexable peut entraîner une charge de travail déséquilibrée.</span><span class="sxs-lookup"><span data-stu-id="1c11e-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="1c11e-150">Lorsque cela se produit, vous pouvez peut-être augmenter les performances des requêtes en créant un partitionneur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="1c11e-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="1c11e-151">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et la bibliothèque parallèle de tâches (TPL)](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="1c11e-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="1c11e-152">Lorsque PLINQ choisit le mode séquentiel</span><span class="sxs-lookup"><span data-stu-id="1c11e-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="1c11e-153">PLINQ essaiera toujours exécuter une requête au moins aussi rapidement que si elle était exécutée de manière séquentielle.</span><span class="sxs-lookup"><span data-stu-id="1c11e-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="1c11e-154">Bien que PLINQ ne tienne compte ni du coût de calcul des délégués de l’utilisateur, ni de la taille la source d’entrée, il recherche certaines « formes » de requêtes.</span><span class="sxs-lookup"><span data-stu-id="1c11e-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="1c11e-155">Plus précisément, il recherche des opérateurs de requêtes ou des combinaisons d’opérateurs qui font qu’une requête s’exécute plus lentement en mode parallèle.</span><span class="sxs-lookup"><span data-stu-id="1c11e-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="1c11e-156">Lorsqu’il trouve de telles formes, par défaut PLINQ revient au mode séquentiel.</span><span class="sxs-lookup"><span data-stu-id="1c11e-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="1c11e-157">Toutefois, après avoir mesuré les performances d’une requête spécifique, vous pouvez déterminer qu’elle s’exécute plus rapidement en mode parallèle.</span><span class="sxs-lookup"><span data-stu-id="1c11e-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="1c11e-158">Dans ce cas, vous pouvez utiliser l’indicateur <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> via la méthode <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> pour indiquer à PLINQ de paralléliser la requête.</span><span class="sxs-lookup"><span data-stu-id="1c11e-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="1c11e-159">Pour plus d’informations, consultez [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md) (Guide pratique pour spécifier le mode d’exécution dans PLINQ).</span><span class="sxs-lookup"><span data-stu-id="1c11e-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="1c11e-160">La liste suivante décrit les formes de requêtes que PLINQ exécutera en mode séquentiel par défaut :</span><span class="sxs-lookup"><span data-stu-id="1c11e-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="1c11e-161">Requêtes qui contiennent une instruction Select, Where indexée, SelectMany indexée ou ElementAt après un opérateur de tri ou de filtrage qui a supprimé ou réorganisé les indices d’origine.</span><span class="sxs-lookup"><span data-stu-id="1c11e-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="1c11e-162">Requêtes qui contiennent un SkipWhile opérateur Take, TakeWhile, ignorer et où les index de la séquence source ne sont pas dans l’ordre d’origine.</span><span class="sxs-lookup"><span data-stu-id="1c11e-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="1c11e-163">Requêtes qui contiennent Zip ou SequenceEquals, sauf si une des sources de données a un index ordonné à l’origine et la source de données indexable (autrement dit, un tableau ou un IList(T)).</span><span class="sxs-lookup"><span data-stu-id="1c11e-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="1c11e-164">Requêtes qui contiennent Concat, sauf si elle est appliquée aux sources de données indexables.</span><span class="sxs-lookup"><span data-stu-id="1c11e-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="1c11e-165">Requêtes qui contiennent Reverse, sauf si elle est appliquée aux sources de données indexables.</span><span class="sxs-lookup"><span data-stu-id="1c11e-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1c11e-166">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="1c11e-166">See also</span></span>

- [<span data-ttu-id="1c11e-167">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="1c11e-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
