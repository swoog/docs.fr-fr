---
title: Implémentation d’une méthode Dispose
ms.date: 04/07/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 176ae3589443937331259ee4716570c66053de3c
ms.sourcegitcommit: c7f3e2e9d6ead6cc3acd0d66b10a251d0c66e59d
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/09/2018
ms.locfileid: "44186186"
---
# <a name="implementing-a-dispose-method"></a><span data-ttu-id="3d625-102">Implémentation d’une méthode Dispose</span><span class="sxs-lookup"><span data-stu-id="3d625-102">Implementing a Dispose method</span></span>

<span data-ttu-id="3d625-103">Vous implémentez une méthode <xref:System.IDisposable.Dispose%2A> pour libérer les ressources non managées utilisées par votre application.</span><span class="sxs-lookup"><span data-stu-id="3d625-103">You implement a <xref:System.IDisposable.Dispose%2A> method to release unmanaged resources used by your application.</span></span> <span data-ttu-id="3d625-104">Le Garbage collector .NET n’alloue pas de mémoire non managée, et n’en libère pas non plus.</span><span class="sxs-lookup"><span data-stu-id="3d625-104">The .NET garbage collector does not allocate or release unmanaged memory.</span></span>  
  
<span data-ttu-id="3d625-105">Le modèle pour supprimer un objet, dénommé [modèle de suppression](../../../docs/standard/design-guidelines/dispose-pattern.md), impose un ordre sur la durée de vie d’un objet.</span><span class="sxs-lookup"><span data-stu-id="3d625-105">The pattern for disposing an object, referred to as a [dispose pattern](../../../docs/standard/design-guidelines/dispose-pattern.md), imposes order on the lifetime of an object.</span></span> <span data-ttu-id="3d625-106">Le modèle de suppression est utilisé uniquement pour les objets qui accèdent à des ressources non managées, telles que les handles de fichiers et de canaux, les handles d’attente, les handles d’attente ou les pointeurs vers les blocs de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="3d625-106">The dispose pattern is used only for objects that access unmanaged resources, such as file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="3d625-107">Cela est dû au fait que le récupérateur de mémoire est très efficace pour récupérer les objets managés inutilisés, mais ne peut pas récupérer les objets non managés.</span><span class="sxs-lookup"><span data-stu-id="3d625-107">This is because the garbage collector is very efficient at reclaiming unused managed objects, but it is unable to reclaim unmanaged objects.</span></span>  
  
<span data-ttu-id="3d625-108">Le modèle de suppression comporte deux variantes :</span><span class="sxs-lookup"><span data-stu-id="3d625-108">The dispose pattern has two variations:</span></span>  
  
* <span data-ttu-id="3d625-109">Vous encapsulez chaque ressource non managée utilisée par un type dans un handle sécurisé (autrement dit, dans une classe dérivée de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="3d625-109">You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>).</span></span> <span data-ttu-id="3d625-110">Dans ce cas, vous implémentez l'interface <xref:System.IDisposable> et une méthode `Dispose(Boolean)` supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="3d625-110">In this case, you implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method.</span></span> <span data-ttu-id="3d625-111">Il s'agit de la variante recommandée. Elle ne requiert pas le remplacement de la méthode <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d625-111">This is the recommended variation and doesn't require overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span>  
  
  > [!NOTE]
  > <span data-ttu-id="3d625-112">L'espace de noms <xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType> fournit un ensemble de classes dérivées de <xref:System.Runtime.InteropServices.SafeHandle>, qui sont répertoriées dans la section [Utilisation des handles sécurisés](#SafeHandles).</span><span class="sxs-lookup"><span data-stu-id="3d625-112">The <xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType> namespace provides a set of classes derived from <xref:System.Runtime.InteropServices.SafeHandle>, which are listed in the [Using safe handles](#SafeHandles) section.</span></span> <span data-ttu-id="3d625-113">Si vous ne parvenez pas à trouver une classe qui convient pour libérer votre ressource non managée, vous pouvez implémenter votre propre sous-classe de <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="3d625-113">If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>  
  
* <span data-ttu-id="3d625-114">Vous implémentez l'interface <xref:System.IDisposable> et une méthode `Dispose(Boolean)` supplémentaire, puis vous remplacez la méthode <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d625-114">You implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method, and you also override the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3d625-115">Vous devez remplacer <xref:System.Object.Finalize%2A> pour vous assurer que les ressources non managées sont supprimées si votre implémentation de <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> n'est pas appelée par un consommateur de votre type.</span><span class="sxs-lookup"><span data-stu-id="3d625-115">You must override <xref:System.Object.Finalize%2A> to ensure that unmanaged resources are disposed of if your <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation is not called by a consumer of your type.</span></span> <span data-ttu-id="3d625-116">Si vous utilisez la technique recommandée présentée dans le point précédent, la classe <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> effectue cette opération pour vous.</span><span class="sxs-lookup"><span data-stu-id="3d625-116">If you use the recommended technique discussed in the previous bullet, the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class does this on your behalf.</span></span>  
  
<span data-ttu-id="3d625-117">Pour que les ressources soient toujours assurées d'être correctement nettoyées, une méthode <xref:System.IDisposable.Dispose%2A> doit pouvoir être appelée à plusieurs reprises sans lever d'exception.</span><span class="sxs-lookup"><span data-stu-id="3d625-117">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be callable multiple times without throwing an exception.</span></span>  
  
<span data-ttu-id="3d625-118">L'exemple de code indiqué pour la méthode <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> affiche la façon dont un garbage collection agressif peut entraîner l'exécution d'un finaliseur pendant qu'un membre de l'objet demandé se trouve en cours d'exécution.</span><span class="sxs-lookup"><span data-stu-id="3d625-118">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how aggressive garbage collection can cause a finalizer to run while a member of the reclaimed object is still executing.</span></span> <span data-ttu-id="3d625-119">Il est conseillé d'appeler la méthode <xref:System.GC.KeepAlive%2A> à la fin d'une méthode <xref:System.IDisposable.Dispose%2A> longue.</span><span class="sxs-lookup"><span data-stu-id="3d625-119">It is a good idea to call the <xref:System.GC.KeepAlive%2A> method at the end of a lengthy <xref:System.IDisposable.Dispose%2A> method.</span></span>  
  
<a name="Dispose2"></a>
## <a name="dispose-and-disposeboolean"></a><span data-ttu-id="3d625-120">Dispose() et Dispose(Boolean)</span><span class="sxs-lookup"><span data-stu-id="3d625-120">Dispose() and Dispose(Boolean)</span></span>  

<span data-ttu-id="3d625-121">L'interface <xref:System.IDisposable> requiert l'implémentation d'une méthode unique sans paramètre, <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="3d625-121">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="3d625-122">Toutefois, le modèle de suppression requiert deux méthodes `Dispose` à implémenter :</span><span class="sxs-lookup"><span data-stu-id="3d625-122">However, the dispose pattern requires two `Dispose` methods to be implemented:</span></span>  
  
* <span data-ttu-id="3d625-123">Implémentation non virtuelle publique de (`NonInheritable` en Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> qui n'a aucun paramètre.</span><span class="sxs-lookup"><span data-stu-id="3d625-123">A public non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>  
  
* <span data-ttu-id="3d625-124">Méthode virtuelle (`Overridable` en Visual Basic) `Dispose` dont la signature est :</span><span class="sxs-lookup"><span data-stu-id="3d625-124">A protected virtual (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>  
  
  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]  
  
### <a name="the-dispose-overload"></a><span data-ttu-id="3d625-125">Surcharge de Dispose()</span><span class="sxs-lookup"><span data-stu-id="3d625-125">The Dispose() overload</span></span>

<span data-ttu-id="3d625-126">Comme la méthode `NonInheritable` sans paramètre non virtuelle (`Dispose` en Visual Basic) publique est appelée par un consommateur de type, son objectif est de libérer les ressources non managées et d'indiquer que le finaliseur, s'il en existe un, ne doit pas s'exécuter.</span><span class="sxs-lookup"><span data-stu-id="3d625-126">Because the public, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="3d625-127">De ce fait, son implémentation standard est la suivante :</span><span class="sxs-lookup"><span data-stu-id="3d625-127">Because of this, it has a standard implementation:</span></span>  
  
[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]  
  
<span data-ttu-id="3d625-128">La méthode `Dispose` effectue le nettoyage de tous les objets, le récupérateur de mémoire n'a plus donc besoin d'appeler la remplacement de <xref:System.Object.Finalize%2A?displayProperty=nameWithType> des objets.</span><span class="sxs-lookup"><span data-stu-id="3d625-128">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="3d625-129">Par conséquent, l'appel à la méthode <xref:System.GC.SuppressFinalize%2A> empêche le récupérateur de mémoire d'exécuter le finaliseur.</span><span class="sxs-lookup"><span data-stu-id="3d625-129">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="3d625-130">Si le type n'a pas de finaliseur, l'appel à <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> n'a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="3d625-130">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="3d625-131">Notez que le travail réel de libération des ressources non managées est effectué par la deuxième surcharge de la méthode `Dispose`.</span><span class="sxs-lookup"><span data-stu-id="3d625-131">Note that the actual work of releasing unmanaged resources is performed by the second overload of the `Dispose` method.</span></span>  
  
### <a name="the-disposeboolean-overload"></a><span data-ttu-id="3d625-132">Surcharge de Dispose(Boolean)</span><span class="sxs-lookup"><span data-stu-id="3d625-132">The Dispose(Boolean) overload</span></span>

<span data-ttu-id="3d625-133">Dans la seconde surcharge, le paramètre *disposing* est un <xref:System.Boolean> qui indique si l'appel de la méthode provient d'une méthode <xref:System.IDisposable.Dispose%2A> (sa valeur est `true`) ou d'un finaliseur (sa valeur est `false`).</span><span class="sxs-lookup"><span data-stu-id="3d625-133">In the second overload, the *disposing* parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>  
  
<span data-ttu-id="3d625-134">Le corps de la méthode se compose de deux blocs de code :</span><span class="sxs-lookup"><span data-stu-id="3d625-134">The body of the method consists of two blocks of code:</span></span>  
  
* <span data-ttu-id="3d625-135">Un bloc qui libère les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="3d625-135">A block that frees unmanaged resources.</span></span> <span data-ttu-id="3d625-136">Ce bloc s'exécute indépendamment de la valeur du paramètre `disposing`.</span><span class="sxs-lookup"><span data-stu-id="3d625-136">This block executes regardless of the value of the `disposing` parameter.</span></span>  
  
* <span data-ttu-id="3d625-137">Un bloc conditionnel qui libère les ressources managées.</span><span class="sxs-lookup"><span data-stu-id="3d625-137">A conditional block that frees managed resources.</span></span> <span data-ttu-id="3d625-138">Ce bloc s'exécute si la valeur de `disposing` est `true`.</span><span class="sxs-lookup"><span data-stu-id="3d625-138">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="3d625-139">Les ressources managées qu'il libère peuvent inclure :</span><span class="sxs-lookup"><span data-stu-id="3d625-139">The managed resources that it frees can include:</span></span>  
  
  <span data-ttu-id="3d625-140">**Objets managés qui implémentent <xref:System.IDisposable>.**</span><span class="sxs-lookup"><span data-stu-id="3d625-140">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="3d625-141">Le bloc conditionnel peut être utilisé pour appeler leur implémentation de <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="3d625-141">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation.</span></span> <span data-ttu-id="3d625-142">Si vous avez utilisé un handle sécurisé pour encapsuler votre ressource non managée, vous devez appeler l'implémentation de <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType> ici.</span><span class="sxs-lookup"><span data-stu-id="3d625-142">If you have used a safe handle to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType> implementation here.</span></span>  
  
  <span data-ttu-id="3d625-143">**Objets managés qui consomment de grandes quantités de mémoire ou consomment des ressources rares.**</span><span class="sxs-lookup"><span data-stu-id="3d625-143">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="3d625-144">La libération de ces objets explicitement dans la méthode `Dispose` les libère plus rapidement que s'ils ont été récupérés de façon non déterministe par le récupérateur de mémoire.</span><span class="sxs-lookup"><span data-stu-id="3d625-144">Freeing these objects explicitly in the `Dispose` method releases them faster than if they were reclaimed non-deterministically by the garbage collector.</span></span>  
  
<span data-ttu-id="3d625-145">Si l’appel de la méthode vient d’un finaliseur (autrement dit, si *disposing* a la valeur `false`), seul le code qui libère les ressources non managées s’exécute.</span><span class="sxs-lookup"><span data-stu-id="3d625-145">If the method call comes from a finalizer (that is, if *disposing* is `false`), only the code that frees unmanaged resources executes.</span></span> <span data-ttu-id="3d625-146">Étant donné que l'ordre dans lequel le récupérateur de mémoire détruit les objets managés pendant la finalisation n'est pas défini, l'appel de cette surcharge `Dispose` avec la valeur `false` empêche le finaliseur d'essayer de libérer les ressources managées qui peuvent avoir déjà été récupérées.</span><span class="sxs-lookup"><span data-stu-id="3d625-146">Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this `Dispose` overload with a value of `false` prevents the finalizer from trying to release managed resources that may have already been reclaimed.</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="3d625-147">Implémentation du modèle de suppression d'une classe de base</span><span class="sxs-lookup"><span data-stu-id="3d625-147">Implementing the dispose pattern for a base class</span></span>

<span data-ttu-id="3d625-148">Si vous implémentez le modèle de suppression d'une classe de base, vous devez spécifier ce qui suit :</span><span class="sxs-lookup"><span data-stu-id="3d625-148">If you implement the dispose pattern for a base class, you must provide the following:</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="3d625-149">Vous devez implémenter ce modèle pour toutes les classes de base qui implémentent <xref:System.IDisposable.Dispose> et qui ne sont pas `sealed` (`NotInheritable` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3d625-149">You should implement this pattern for all base classes that implement <xref:System.IDisposable.Dispose> and are not `sealed` (`NotInheritable` in Visual Basic).</span></span>  
  
* <span data-ttu-id="3d625-150">Une implémentation de <xref:System.IDisposable.Dispose%2A> qui appelle la méthode `Dispose(Boolean)`.</span><span class="sxs-lookup"><span data-stu-id="3d625-150">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(Boolean)` method.</span></span>  
  
* <span data-ttu-id="3d625-151">Une méthode `Dispose(Boolean)` qui effectue le travail réel de libération des ressources.</span><span class="sxs-lookup"><span data-stu-id="3d625-151">A `Dispose(Boolean)` method that performs the actual work of releasing resources.</span></span>  
  
* <span data-ttu-id="3d625-152">Une classe dérivée de <xref:System.Runtime.InteropServices.SafeHandle> qui encapsule votre ressource managée (recommandée) ou une substitution de la méthode <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d625-152">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3d625-153">La classe <xref:System.Runtime.InteropServices.SafeHandle> fournit un finaliseur qui vous permet de ne pas avoir à en coder un.</span><span class="sxs-lookup"><span data-stu-id="3d625-153">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span>  
  
<span data-ttu-id="3d625-154">Voici le modèle général d'implémentation du modèle de suppression d'une classe de base qui utilise un handle sécurisé.</span><span class="sxs-lookup"><span data-stu-id="3d625-154">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>  
  
[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
> [!NOTE]
> <span data-ttu-id="3d625-155">L'exemple précédent utilise un objet <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> pour illustrer le modèle, mais il est possible d'utiliser à la place n'importe quel objet dérivé de <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="3d625-155">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="3d625-156">Notez que l'exemple n'instancie pas correctement son objet <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="3d625-156">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="3d625-157">Voici le modèle général d'implémentation du modèle de suppression d'une classe de base qui remplace <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d625-157">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>  
  
[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
> [!NOTE]
> <span data-ttu-id="3d625-158">En C#, vous substituez <xref:System.Object.Finalize%2A?displayProperty=nameWithType> en définissant un [destructeur](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="3d625-158">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="3d625-159">Implémentation du modèle de suppression d’une classe dérivée</span><span class="sxs-lookup"><span data-stu-id="3d625-159">Implementing the dispose pattern for a derived class</span></span>

<span data-ttu-id="3d625-160">Une classe dérivée d'une classe qui implémente l'interface <xref:System.IDisposable> ne doit pas implémenter <xref:System.IDisposable>, car l'implémentation de la classe de base de <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> est héritée par les classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="3d625-160">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="3d625-161">À la place, pour implémenter le modèle de suppression d’une classe dérivée, vous fournissez ce qui suit :</span><span class="sxs-lookup"><span data-stu-id="3d625-161">Instead, to implement the dispose pattern for a derived class, you provide the following:</span></span>  
  
* <span data-ttu-id="3d625-162">Une méthode `protected Dispose(Boolean)` qui substitue la méthode de la classe de base et effectue le travail réel de libération des ressources de la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="3d625-162">A `protected Dispose(Boolean)` method that overrides the base class method and performs the actual work of releasing the resources of the derived class.</span></span> <span data-ttu-id="3d625-163">Cette méthode doit également appeler la méthode `Dispose(Boolean)` de la classe de base et lui passer une valeur `true` pour l’argument *disposing*.</span><span class="sxs-lookup"><span data-stu-id="3d625-163">This method should also call the `Dispose(Boolean)` method of the base class and pass it a value of `true` for the *disposing* argument.</span></span>  
  
* <span data-ttu-id="3d625-164">Une classe dérivée de <xref:System.Runtime.InteropServices.SafeHandle> qui encapsule votre ressource managée (recommandée) ou une substitution de la méthode <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d625-164">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3d625-165">La classe <xref:System.Runtime.InteropServices.SafeHandle> fournit un finaliseur qui vous permet de ne pas avoir à en coder un.</span><span class="sxs-lookup"><span data-stu-id="3d625-165">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="3d625-166">Si vous fournissez un finaliseur, il doit appeler la surcharge `Dispose(Boolean)` avec un argument *disposing* égal à `false`.</span><span class="sxs-lookup"><span data-stu-id="3d625-166">If you do provide a finalizer, it should call the `Dispose(Boolean)` overload with a *disposing* argument of `false`.</span></span>  
  
<span data-ttu-id="3d625-167">Voici le modèle général d’implémentation du modèle de suppression d’une classe dérivée qui utilise un handle sécurisé :</span><span class="sxs-lookup"><span data-stu-id="3d625-167">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>  
  
[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
> [!NOTE]
> <span data-ttu-id="3d625-168">L'exemple précédent utilise un objet <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> pour illustrer le modèle, mais il est possible d'utiliser à la place n'importe quel objet dérivé de <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="3d625-168">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="3d625-169">Notez que l'exemple n'instancie pas correctement son objet <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="3d625-169">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="3d625-170">Voici le modèle général d'implémentation du modèle de suppression d'une classe dérivée qui remplace <xref:System.Object.Finalize%2A?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="3d625-170">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>  
  
[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]  
  
> [!NOTE]
> <span data-ttu-id="3d625-171">En C#, vous substituez <xref:System.Object.Finalize%2A?displayProperty=nameWithType> en définissant un [destructeur](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="3d625-171">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
<a name="SafeHandles"></a>   
## <a name="using-safe-handles"></a><span data-ttu-id="3d625-172">Utilisation des handles sécurisés</span><span class="sxs-lookup"><span data-stu-id="3d625-172">Using safe handles</span></span>

<span data-ttu-id="3d625-173">L'écriture de code pour le finaliseur d'un objet est une tâche complexe qui peut provoquer des problèmes si elle n'est pas effectuée correctement.</span><span class="sxs-lookup"><span data-stu-id="3d625-173">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="3d625-174">Par conséquent, nous vous recommandons de construire des objets <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> au lieu d'implémenter un finaliseur.</span><span class="sxs-lookup"><span data-stu-id="3d625-174">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>  
  
<span data-ttu-id="3d625-175">Les classes dérivées de la classe <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> simplifient les problèmes de durée de vie des objets en assignant et en libérant des handles sans interruption.</span><span class="sxs-lookup"><span data-stu-id="3d625-175">Classes derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class simplify object lifetime issues by assigning and releasing handles without interruption.</span></span> <span data-ttu-id="3d625-176">Elles contiennent un finaliseur critique dont le fonctionnement pendant le déchargement d'un domaine d'application est garanti.</span><span class="sxs-lookup"><span data-stu-id="3d625-176">They contain a critical finalizer that is guaranteed to run while an application domain is unloading.</span></span> <span data-ttu-id="3d625-177">Pour plus d'informations sur les avantages de l'utilisation d'un handle sécurisé, consultez <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d625-177">For more information about the advantages of using a safe handle, see <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3d625-178">Les classes dérivées suivantes de l'espace de noms <xref:Microsoft.Win32.SafeHandles> fournissent des handles sécurisés :</span><span class="sxs-lookup"><span data-stu-id="3d625-178">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>  
  
* <span data-ttu-id="3d625-179">La classe <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> et <xref:Microsoft.Win32.SafeHandles.SafePipeHandle>, pour les fichiers, les fichiers mappés en mémoire et les canaux.</span><span class="sxs-lookup"><span data-stu-id="3d625-179">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>  
  
* <span data-ttu-id="3d625-180">La classe <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>, pour les vues de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="3d625-180">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>  
  
* <span data-ttu-id="3d625-181">Les classes <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> et <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> pour les constructions de chiffrement.</span><span class="sxs-lookup"><span data-stu-id="3d625-181">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>  
  
* <span data-ttu-id="3d625-182">La classe <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> pour les clés de Registre.</span><span class="sxs-lookup"><span data-stu-id="3d625-182">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>  
  
* <span data-ttu-id="3d625-183">La classe <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>, pour les handles d'attente.</span><span class="sxs-lookup"><span data-stu-id="3d625-183">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>  
  
<a name="base"></a>   
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="3d625-184">Utilisation d'un handle sécurisé pour implémenter le modèle de suppression d'une classe de base</span><span class="sxs-lookup"><span data-stu-id="3d625-184">Using a safe handle to implement the dispose pattern for a base class</span></span>

<span data-ttu-id="3d625-185">L'exemple suivant illustre le modèle de suppression d'une classe de base, `DisposableStreamResource`, qui utilise un handle sécurisé pour encapsuler les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="3d625-185">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="3d625-186">Il définit une classe `DisposableResource` qui utilise <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> pour encapsuler un objet <xref:System.IO.Stream> qui représente un fichier ouvert.</span><span class="sxs-lookup"><span data-stu-id="3d625-186">It defines a `DisposableResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="3d625-187">La méthode `DisposableResource` inclut également une seule propriété, `Size`, qui retourne le nombre total d'octets du flux de fichier.</span><span class="sxs-lookup"><span data-stu-id="3d625-187">The `DisposableResource` method also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>  
  
[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]  
  
<a name="derived"></a>   
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="3d625-188">Utilisation d'un handle sécurisé pour implémenter le modèle de suppression d'une classe dérivée</span><span class="sxs-lookup"><span data-stu-id="3d625-188">Using a safe handle to implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="3d625-189">L'exemple suivant illustre le modèle de suppression d'une classe dérivée, `DisposableStreamResource2`, qui hérite de la classe `DisposableStreamResource` présentée dans l'exemple précédent.</span><span class="sxs-lookup"><span data-stu-id="3d625-189">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="3d625-190">La classe ajoute une méthode supplémentaire, `WriteFileInfo`, et utilise un objet <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> pour encapsuler le handle du fichier accessible en écriture.</span><span class="sxs-lookup"><span data-stu-id="3d625-190">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>  
  
[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]  
  
## <a name="see-also"></a><span data-ttu-id="3d625-191">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="3d625-191">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>   
- <xref:System.IDisposable>   
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>   
- <xref:Microsoft.Win32.SafeHandles>   
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>   
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>   
- [<span data-ttu-id="3d625-192">Guide pratique pour définir et consommer des classes et des structs (C++-CLI)</span><span class="sxs-lookup"><span data-stu-id="3d625-192">How to: Define and Consume Classes and Structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)   
- [<span data-ttu-id="3d625-193">Dispose, modèle</span><span class="sxs-lookup"><span data-stu-id="3d625-193">Dispose Pattern</span></span>](../../../docs/standard/design-guidelines/dispose-pattern.md)
