---
title: "Constructions de regroupement dans les expressions régulières"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 766f20f92cd4ac2d987137f86616a69df9f53600
ms.sourcegitcommit: 83dd5ec003e788ccb3e33f3412a7af39ae347646
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/15/2018
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="99a6b-102">Constructions de regroupement dans les expressions régulières</span><span class="sxs-lookup"><span data-stu-id="99a6b-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="99a6b-103">Les constructions de regroupement délimitent les sous-expressions d'une expression régulière et capturent les sous-chaînes d'une chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="99a6b-104">Utilisez les constructions de regroupement pour effectuer les opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="99a6b-104">You can use grouping constructs to do the following:</span></span>  
  
-   <span data-ttu-id="99a6b-105">Mettre en correspondance une sous-expression qui est répétée dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-105">Match a subexpression that is repeated in the input string.</span></span>  
  
-   <span data-ttu-id="99a6b-106">Appliquer un quantificateur à une sous-expression qui possède plusieurs éléments de langage d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="99a6b-107">Pour plus d'informations sur les quantificateurs, voir [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="99a6b-107">For more information about quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="99a6b-108">Inclure une sous-expression dans la chaîne retournée par les méthodes <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> et <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99a6b-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
-   <span data-ttu-id="99a6b-109">Récupérer des sous-expressions spécifiques de la propriété <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> et les traiter séparément du texte global mis en correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="99a6b-110">Le tableau suivant répertorie les constructions de regroupement prises en charge par le moteur d’expression régulière de .NET et indique si ce sont des constructions avec ou sans capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="99a6b-111">Construction de regroupement</span><span class="sxs-lookup"><span data-stu-id="99a6b-111">Grouping construct</span></span>|<span data-ttu-id="99a6b-112">Avec ou sans capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="99a6b-113">Sous-expressions mises en correspondance</span><span class="sxs-lookup"><span data-stu-id="99a6b-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="99a6b-114">Capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-114">Capturing</span></span>|  
|[<span data-ttu-id="99a6b-115">Sous-expressions mises en correspondance nommées</span><span class="sxs-lookup"><span data-stu-id="99a6b-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="99a6b-116">Capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-116">Capturing</span></span>|  
|[<span data-ttu-id="99a6b-117">Définitions de groupe d'équilibrage</span><span class="sxs-lookup"><span data-stu-id="99a6b-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="99a6b-118">Capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-118">Capturing</span></span>|  
|[<span data-ttu-id="99a6b-119">Groupes sans capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="99a6b-120">Sans capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-120">Noncapturing</span></span>|  
|[<span data-ttu-id="99a6b-121">Options de groupe</span><span class="sxs-lookup"><span data-stu-id="99a6b-121">Group options</span></span>](#group_options)|<span data-ttu-id="99a6b-122">Sans capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-122">Noncapturing</span></span>|  
|[<span data-ttu-id="99a6b-123">Assertions de préanalyse positive de largeur nulle</span><span class="sxs-lookup"><span data-stu-id="99a6b-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="99a6b-124">Sans capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-124">Noncapturing</span></span>|  
|[<span data-ttu-id="99a6b-125">Assertions de préanalyse négative de largeur nulle</span><span class="sxs-lookup"><span data-stu-id="99a6b-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="99a6b-126">Sans capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-126">Noncapturing</span></span>|  
|[<span data-ttu-id="99a6b-127">Assertions de postanalyse positive de largeur nulle</span><span class="sxs-lookup"><span data-stu-id="99a6b-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="99a6b-128">Sans capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-128">Noncapturing</span></span>|  
|[<span data-ttu-id="99a6b-129">Assertions de postanalyse négative de largeur nulle</span><span class="sxs-lookup"><span data-stu-id="99a6b-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="99a6b-130">Sans capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-130">Noncapturing</span></span>|  
|[<span data-ttu-id="99a6b-131">Sous-expressions non rétroactives</span><span class="sxs-lookup"><span data-stu-id="99a6b-131">Nonbacktracking subexpressions</span></span>](#nonbacktracking_subexpression)|<span data-ttu-id="99a6b-132">Sans capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="99a6b-133">Pour plus d'informations sur les groupes et le modèle objet d'expression régulière, voir [Constructions de regroupement et objets d'expression régulière](#Objects).</span><span class="sxs-lookup"><span data-stu-id="99a6b-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>   
## <a name="matched-subexpressions"></a><span data-ttu-id="99a6b-134">Sous-expressions mises en correspondance</span><span class="sxs-lookup"><span data-stu-id="99a6b-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="99a6b-135">La construction de regroupement suivante capture une sous-expression mise en correspondance :</span><span class="sxs-lookup"><span data-stu-id="99a6b-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="99a6b-136">`(` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="99a6b-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="99a6b-137">où *subexpression* représente un modèle d'expression régulière valide.</span><span class="sxs-lookup"><span data-stu-id="99a6b-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="99a6b-138">Les captures qui utilisent des parenthèses sont numérotées automatiquement de la gauche vers la droite en fonction de l'ordre des parenthèses ouvrantes dans l'expression régulière, à partir de 1.</span><span class="sxs-lookup"><span data-stu-id="99a6b-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="99a6b-139">La capture numérotée 0 représente le texte mis en correspondance par le modèle d'expression régulière entier.</span><span class="sxs-lookup"><span data-stu-id="99a6b-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="99a6b-140">Par défaut, l'élément de langage `(`*subexpression*`)` capture la sous-expression mise en correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="99a6b-141">Toutefois, si le paramètre <xref:System.Text.RegularExpressions.RegexOptions> d'une méthode de mise en correspondance de modèle d'expression régulière comprend l'indicateur <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> ou que l'option `n` soit appliquée à cette sous-expression (voir [Options de groupe](#group_options) plus loin dans cette rubrique), la sous-expression mise en correspondance n'est pas capturée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="99a6b-142">Vous pouvez accéder aux groupes capturés de quatre façons :</span><span class="sxs-lookup"><span data-stu-id="99a6b-142">You can access captured groups in four ways:</span></span>  
  
-   <span data-ttu-id="99a6b-143">En utilisant la construction de référence arrière dans l'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="99a6b-144">La sous-expression mise en correspondance est référencée dans la même expression régulière en utilisant la syntaxe `\`*nombre*, où *nombre* est le nombre ordinal de la sous-expression capturée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="99a6b-145">En utilisant la construction de référence arrière nommée dans l'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="99a6b-146">La sous-expression mise en correspondance est référencée dans la même expression régulière en utilisant la syntaxe `\k<`*nom*`>`, où *nom* est le nom d'un groupe de capture, ou la syntaxe `\k<`*nombre*`>`, où *nombre* est le nombre ordinal d'un groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="99a6b-147">Un groupe de capture possède un nom par défaut qui est identique à son nombre ordinal.</span><span class="sxs-lookup"><span data-stu-id="99a6b-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="99a6b-148">Pour plus d'informations, voir [Sous-expressions mises en correspondance nommées](#named_matched_subexpression) plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="99a6b-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
-   <span data-ttu-id="99a6b-149">En utilisant la séquence de remplacement `$`*nombre* dans un appel de méthode <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> ou <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, où *nombre* est le nombre ordinal de la sous-expression capturée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="99a6b-150">Par programmation, en utilisant l'objet <xref:System.Text.RegularExpressions.GroupCollection> retourné par la propriété <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99a6b-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="99a6b-151">Le membre situé à la position zéro dans la collection représente la correspondance de l'expression régulière entière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="99a6b-152">Chaque membre suivant représente une sous-expression mise en correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="99a6b-153">Pour plus d'informations, voir la section [Grouping Constructs and Regular Expression Objects](#Objects) .</span><span class="sxs-lookup"><span data-stu-id="99a6b-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="99a6b-154">L'exemple suivant illustre une expression régulière qui identifie des mots en double dans le texte.</span><span class="sxs-lookup"><span data-stu-id="99a6b-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="99a6b-155">Les deux groupes de capture du modèle d'expression régulière représentent les deux instances du mot en double.</span><span class="sxs-lookup"><span data-stu-id="99a6b-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="99a6b-156">La capture de la seconde instance permet d'indiquer la position de départ du mot dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="99a6b-157">Le modèle d'expression régulière est le suivant :</span><span class="sxs-lookup"><span data-stu-id="99a6b-157">The regular expression pattern is the following:</span></span>  
  
```  
(\w+)\s(\1)\W  
```  
  
 <span data-ttu-id="99a6b-158">Le tableau suivant montre comment le modèle d'expression régulière est interprété.</span><span class="sxs-lookup"><span data-stu-id="99a6b-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="99a6b-159">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-159">Pattern</span></span>|<span data-ttu-id="99a6b-160">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="99a6b-161">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-161">Match one or more word characters.</span></span> <span data-ttu-id="99a6b-162">Il s'agit du premier groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="99a6b-163">Mettre en correspondance un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="99a6b-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="99a6b-164">Mettre en correspondance la chaîne dans le premier groupe capturé.</span><span class="sxs-lookup"><span data-stu-id="99a6b-164">Match the string in the first captured group.</span></span> <span data-ttu-id="99a6b-165">Il s'agit du deuxième groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-165">This is the second capturing group.</span></span> <span data-ttu-id="99a6b-166">L'exemple l'affecte à un groupe capturé pour que la position de départ du mot en double puisse être récupérée de la propriété `Match.Index` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="99a6b-167">Mettre en correspondance un caractère n'appartenant pas à un mot, comme un espace blanc ou un signe de ponctuation.</span><span class="sxs-lookup"><span data-stu-id="99a6b-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="99a6b-168">Cela empêche le modèle d'expression régulière de mettre en correspondance un mot qui commence par le mot récupéré du premier groupe capturé.</span><span class="sxs-lookup"><span data-stu-id="99a6b-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>   
## <a name="named-matched-subexpressions"></a><span data-ttu-id="99a6b-169">Sous-expressions mises en correspondance nommées</span><span class="sxs-lookup"><span data-stu-id="99a6b-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="99a6b-170">La construction de regroupement suivante capture une sous-expression mise en correspondance et vous permet d'y accéder à partir d'un nom ou d'un nombre :</span><span class="sxs-lookup"><span data-stu-id="99a6b-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
```  
(?<name>subexpression)  
```  
  
 <span data-ttu-id="99a6b-171">ou :</span><span class="sxs-lookup"><span data-stu-id="99a6b-171">or:</span></span>  
  
```  
(?'name'subexpression)  
```  
  
 <span data-ttu-id="99a6b-172">où *name* est un nom de groupe valide, et *subexpression* représente un modèle d'expression régulière valide.</span><span class="sxs-lookup"><span data-stu-id="99a6b-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="99a6b-173">*name* ne doit pas contenir de caractères de ponctuation et ne peut pas commencer par un nombre.</span><span class="sxs-lookup"><span data-stu-id="99a6b-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="99a6b-174">Si le paramètre <xref:System.Text.RegularExpressions.RegexOptions> d'une méthode de mise en correspondance de modèle d'expression régulière comprend l'indicateur <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> ou que l'option `n` soit appliquée à cette sous-expression (voir [Options de groupe](#group_options) plus loin dans cette rubrique), la seule façon de capturer une sous-expression consiste à nommer explicitement des groupes de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="99a6b-175">Vous pouvez accéder aux groupes capturés nommés comme suit :</span><span class="sxs-lookup"><span data-stu-id="99a6b-175">You can access named captured groups in the following ways:</span></span>  
  
-   <span data-ttu-id="99a6b-176">En utilisant la construction de référence arrière nommée dans l'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="99a6b-177">La sous-expression mise en correspondance est référencée dans la même expression régulière en utilisant la syntaxe `\k<`*nom*`>`, où *nom* est le nom de la sous-expression capturée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="99a6b-178">En utilisant la construction de référence arrière dans l'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="99a6b-179">La sous-expression mise en correspondance est référencée dans la même expression régulière en utilisant la syntaxe `\`*nombre*, où *nombre* est le nombre ordinal de la sous-expression capturée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="99a6b-180">Les sous-expressions mises en correspondance nommées sont numérotées de manière consécutive de la gauche vers la droite après les sous-expressions mises en correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
-   <span data-ttu-id="99a6b-181">En utilisant la séquence de remplacement `${`*nom*`}` dans un appel de méthode <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> ou <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, où *nom* est le nom de la sous-expression capturée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="99a6b-182">En utilisant la séquence de remplacement `$`*nombre* dans un appel de méthode <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> ou <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, où *nombre* est le nombre ordinal de la sous-expression capturée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="99a6b-183">Par programmation, en utilisant l'objet <xref:System.Text.RegularExpressions.GroupCollection> retourné par la propriété <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99a6b-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="99a6b-184">Le membre situé à la position zéro dans la collection représente la correspondance de l'expression régulière entière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="99a6b-185">Chaque membre suivant représente une sous-expression mise en correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="99a6b-186">Les groupes capturés nommés sont stockés dans la collection après les groupes capturés numérotés.</span><span class="sxs-lookup"><span data-stu-id="99a6b-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
-   <span data-ttu-id="99a6b-187">Par programmation, en fournissant le nom de la sous-expression à l'indexeur de l'objet <xref:System.Text.RegularExpressions.GroupCollection> (en C#) ou à sa propriété <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="99a6b-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="99a6b-188">Un modèle d'expression régulière simple permet d'illustrer comment les groupes numérotés (sans nom) et nommés peuvent être référencés par programmation ou à l'aide d'une syntaxe de langage d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="99a6b-189">L'expression régulière `((?<One>abc)\d+)?(?<Two>xyz)(.*)` génère les groupes de capture suivants en fonction du nombre et du nom.</span><span class="sxs-lookup"><span data-stu-id="99a6b-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="99a6b-190">Le premier groupe de capture (nombre 0) fait toujours référence au modèle entier.</span><span class="sxs-lookup"><span data-stu-id="99a6b-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="99a6b-191">nombre</span><span class="sxs-lookup"><span data-stu-id="99a6b-191">Number</span></span>|<span data-ttu-id="99a6b-192">nom</span><span class="sxs-lookup"><span data-stu-id="99a6b-192">Name</span></span>|<span data-ttu-id="99a6b-193">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="99a6b-194">0</span><span class="sxs-lookup"><span data-stu-id="99a6b-194">0</span></span>|<span data-ttu-id="99a6b-195">0 (nom par défaut)</span><span class="sxs-lookup"><span data-stu-id="99a6b-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="99a6b-196">1</span><span class="sxs-lookup"><span data-stu-id="99a6b-196">1</span></span>|<span data-ttu-id="99a6b-197">1 (nom par défaut)</span><span class="sxs-lookup"><span data-stu-id="99a6b-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="99a6b-198">2</span><span class="sxs-lookup"><span data-stu-id="99a6b-198">2</span></span>|<span data-ttu-id="99a6b-199">2 (nom par défaut)</span><span class="sxs-lookup"><span data-stu-id="99a6b-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="99a6b-200">3</span><span class="sxs-lookup"><span data-stu-id="99a6b-200">3</span></span>|<span data-ttu-id="99a6b-201">Un</span><span class="sxs-lookup"><span data-stu-id="99a6b-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="99a6b-202">4</span><span class="sxs-lookup"><span data-stu-id="99a6b-202">4</span></span>|<span data-ttu-id="99a6b-203">Deux</span><span class="sxs-lookup"><span data-stu-id="99a6b-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="99a6b-204">L'exemple suivant illustre une expression régulière qui identifie les mots en double et le mot qui se trouve juste après chaque mot en double.</span><span class="sxs-lookup"><span data-stu-id="99a6b-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="99a6b-205">Le modèle d'expression régulière définit deux sous-expressions nommées : `duplicateWord`, qui représente le mot en double, et `nextWord`, qui représente le mot qui suit le mot en double.</span><span class="sxs-lookup"><span data-stu-id="99a6b-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="99a6b-206">Le modèle d'expression régulière est le suivant :</span><span class="sxs-lookup"><span data-stu-id="99a6b-206">The regular expression pattern is as follows:</span></span>  
  
```  
(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)  
```  
  
 <span data-ttu-id="99a6b-207">Le tableau suivant montre comment l'expression régulière est interprétée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="99a6b-208">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-208">Pattern</span></span>|<span data-ttu-id="99a6b-209">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="99a6b-210">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-210">Match one or more word characters.</span></span> <span data-ttu-id="99a6b-211">Nommer ce groupe de capture `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="99a6b-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="99a6b-212">Mettre en correspondance un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="99a6b-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="99a6b-213">Mettre en correspondance la chaîne à partir du groupe capturé nommé `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="99a6b-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="99a6b-214">Mettre en correspondance un caractère n'appartenant pas à un mot, comme un espace blanc ou un signe de ponctuation.</span><span class="sxs-lookup"><span data-stu-id="99a6b-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="99a6b-215">Cela empêche le modèle d'expression régulière de mettre en correspondance un mot qui commence par le mot récupéré du premier groupe capturé.</span><span class="sxs-lookup"><span data-stu-id="99a6b-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="99a6b-216">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-216">Match one or more word characters.</span></span> <span data-ttu-id="99a6b-217">Nommer ce groupe de capture `nextWord`.</span><span class="sxs-lookup"><span data-stu-id="99a6b-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="99a6b-218">Notez qu'un nom de groupe peut être répété dans une expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="99a6b-219">Par exemple, il est possible pour plusieurs groupes soient nommés `digit`, comme le montre l'exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="99a6b-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="99a6b-220">Dans le cas de noms en doublon, la valeur de l'objet <xref:System.Text.RegularExpressions.Group> est déterminée par la dernière capture réussie dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="99a6b-221">En outre, la collection <xref:System.Text.RegularExpressions.CaptureCollection> est remplie avec des informations sur chaque capture, comme si le nom du groupe n'était pas en doublon.</span><span class="sxs-lookup"><span data-stu-id="99a6b-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="99a6b-222">Dans l'exemple suivant, l'expression régulière `\D+(?<digit>\d+)\D+(?<digit>\d+)?` comprend deux occurrences d'un groupe nommé `digit`.</span><span class="sxs-lookup"><span data-stu-id="99a6b-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="99a6b-223">Le premier groupe nommé `digit` capture un ou plusieurs caractères numériques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="99a6b-224">Le deuxième groupe nommé `digit` capture zéro ou une occurrence d'un ou plusieurs caractères numériques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="99a6b-225">Comme la sortie de l'exemple le montre, si le deuxième groupe de capture correspond à du texte, la valeur de ce texte définit la valeur de l'objet <xref:System.Text.RegularExpressions.Group> .</span><span class="sxs-lookup"><span data-stu-id="99a6b-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="99a6b-226">Si le deuxième groupe de capture ne correspond pas à la chaîne d'entrée, la valeur de la dernière correspondance définit la valeur de l'objet <xref:System.Text.RegularExpressions.Group> .</span><span class="sxs-lookup"><span data-stu-id="99a6b-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="99a6b-227">Le tableau suivant montre comment l'expression régulière est interprétée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="99a6b-228">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-228">Pattern</span></span>|<span data-ttu-id="99a6b-229">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="99a6b-230">Mettre en correspondance un ou plusieurs caractères non décimaux.</span><span class="sxs-lookup"><span data-stu-id="99a6b-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="99a6b-231">Mettre en correspondance un ou plusieurs caractères décimaux.</span><span class="sxs-lookup"><span data-stu-id="99a6b-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="99a6b-232">Affecter la correspondance au groupe nommé `digit` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-232">Assign the match to the `digit` named group.</span></span>|  
|<span data-ttu-id="99a6b-233">\D+</span><span class="sxs-lookup"><span data-stu-id="99a6b-233">\D+</span></span>|<span data-ttu-id="99a6b-234">Mettre en correspondance un ou plusieurs caractères non décimaux.</span><span class="sxs-lookup"><span data-stu-id="99a6b-234">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="99a6b-235">Mettre en correspondance zéro ou une occurrence d'un ou plusieurs caractères numériques décimaux.</span><span class="sxs-lookup"><span data-stu-id="99a6b-235">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="99a6b-236">Affecter la correspondance au groupe nommé `digit` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-236">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>   
## <a name="balancing-group-definitions"></a><span data-ttu-id="99a6b-237">Définitions de groupe d'équilibrage</span><span class="sxs-lookup"><span data-stu-id="99a6b-237">Balancing Group Definitions</span></span>  
 <span data-ttu-id="99a6b-238">Une définition de groupe d'équilibrage supprime la définition d'un groupe précédemment défini et stocke, dans le groupe actuel, l'intervalle entre le groupe précédemment défini et ce dernier.</span><span class="sxs-lookup"><span data-stu-id="99a6b-238">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="99a6b-239">Cette construction de regroupement se présente sous la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="99a6b-239">This grouping construct has the following format:</span></span>  
  
```  
(?<name1-name2>subexpression)  
```  
  
 <span data-ttu-id="99a6b-240">ou :</span><span class="sxs-lookup"><span data-stu-id="99a6b-240">or:</span></span>  
  
```  
(?'name1-name2' subexpression)  
```  
  
 <span data-ttu-id="99a6b-241">où *name1* est le groupe actuel (facultatif), *name2* un groupe précédemment défini et *subexpression* un modèle d'expression régulière valide.</span><span class="sxs-lookup"><span data-stu-id="99a6b-241">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="99a6b-242">La définition de groupe d'équilibrage supprime la définition de *name2* et stocke l'intervalle entre *name2* et *name1* dans *name1*.</span><span class="sxs-lookup"><span data-stu-id="99a6b-242">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="99a6b-243">Si aucun groupe *name2* n'est défini, la recherche de correspondance s'effectue de façon rétroactive.</span><span class="sxs-lookup"><span data-stu-id="99a6b-243">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="99a6b-244">Comme la suppression de la dernière définition de *name2* révèle la définition antérieure de *name2*, cette construction vous permet d'utiliser la pile de captures du groupe *name2* en tant que compteur pour effectuer le suivi des constructions imbriquées, telles que des parenthèses ou des crochets ouvrants et fermants.</span><span class="sxs-lookup"><span data-stu-id="99a6b-244">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="99a6b-245">La définition de groupe d'équilibrage utilise *name2* comme pile.</span><span class="sxs-lookup"><span data-stu-id="99a6b-245">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="99a6b-246">Le caractère initial de chaque construction imbriquée est placé dans le groupe et dans sa collection <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99a6b-246">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="99a6b-247">Quand le caractère fermant est mis en correspondance, le caractère ouvrant correspondant est supprimé du groupe, et la collection <xref:System.Text.RegularExpressions.Group.Captures%2A> est diminuée d'une unité.</span><span class="sxs-lookup"><span data-stu-id="99a6b-247">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="99a6b-248">Une fois que les caractères ouvrant et fermant de toutes les constructions imbriquées ont été mis en correspondance, *name1* est vide.</span><span class="sxs-lookup"><span data-stu-id="99a6b-248">After the opening and closing characters of all nested constructs have been matched, *name1* is empty.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="99a6b-249">Une fois que vous avez modifié l'expression régulière dans l'exemple suivant pour utiliser les caractères ouvrant et fermant appropriés d'une construction imbriquée, vous pouvez l'utiliser pour gérer la plupart des constructions imbriquées, telles que les expressions mathématiques ou les lignes de code de programme qui comprennent plusieurs appels de méthode imbriqués.</span><span class="sxs-lookup"><span data-stu-id="99a6b-249">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="99a6b-250">L'exemple suivant utilise une définition de groupe d'équilibrage pour mettre en correspondance les chevrons gauche et droit (<>) dans une chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-250">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="99a6b-251">L'exemple définit deux groupes nommés, `Open` et `Close`, qui sont utilisés comme une pile pour effectuer le suivi des paires de chevrons correspondantes.</span><span class="sxs-lookup"><span data-stu-id="99a6b-251">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="99a6b-252">Chaque chevron gauche capturé est placé dans la collection de captures du groupe `Open` , tandis que chaque chevron droit capturé est placé dans la collection de captures du groupe `Close` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-252">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="99a6b-253">La définition de groupe d'équilibrage s'assure qu'à chaque chevron gauche correspond un chevron droit.</span><span class="sxs-lookup"><span data-stu-id="99a6b-253">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="99a6b-254">Si tel n'est pas le cas, le sous-modèle final, `(?(Open)(?!))`, n'est évalué que si le groupe `Open` n'est pas vide (signe que toutes les constructions imbriquées n'ont pas été fermées).</span><span class="sxs-lookup"><span data-stu-id="99a6b-254">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="99a6b-255">Si le sous-modèle final est évalué, la recherche de correspondance échoue, car le sous-modèle `(?!)` est une assertion de préanalyse négative de largeur nulle qui échoue systématiquement.</span><span class="sxs-lookup"><span data-stu-id="99a6b-255">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="99a6b-256">Le modèle d'expression régulière est le suivant :</span><span class="sxs-lookup"><span data-stu-id="99a6b-256">The regular expression pattern is:</span></span>  
  
```  
^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$  
```  
  
 <span data-ttu-id="99a6b-257">L'expression régulière est interprétée comme suit :</span><span class="sxs-lookup"><span data-stu-id="99a6b-257">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="99a6b-258">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-258">Pattern</span></span>|<span data-ttu-id="99a6b-259">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-259">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="99a6b-260">Commencer au début de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="99a6b-260">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="99a6b-261">Mettre en correspondance zéro caractère, ou plus, à l'exception des chevrons gauches ou droits.</span><span class="sxs-lookup"><span data-stu-id="99a6b-261">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="99a6b-262">Mettre en correspondance un chevron gauche et l'affecter à un groupe nommé `Open`.</span><span class="sxs-lookup"><span data-stu-id="99a6b-262">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="99a6b-263">Mettre en correspondance zéro caractère, ou plus, à l'exception des chevrons gauches ou droits.</span><span class="sxs-lookup"><span data-stu-id="99a6b-263">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*) +`|<span data-ttu-id="99a6b-264">Mettre en correspondance une ou plusieurs occurrences d'un chevron gauche suivies de zéro caractère, ou plus, à l'exception des chevrons gauches ou droits.</span><span class="sxs-lookup"><span data-stu-id="99a6b-264">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="99a6b-265">Il s'agit du deuxième groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-265">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="99a6b-266">Mettre en correspondance un chevron droit, affecter la sous-chaîne entre le groupe `Open` et le groupe actuel au groupe `Close` , puis supprimer la définition du groupe `Open` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-266">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="99a6b-267">Mettre en correspondance zéro occurrence, ou plus, d'un caractère à l'exception d'un chevron gauche ou droit.</span><span class="sxs-lookup"><span data-stu-id="99a6b-267">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="99a6b-268">Mettre en correspondance une occurrence, ou plus, d'un chevron droit, suivies de zéro occurrence, ou plus, d'un caractère à l'exception d'un chevron gauche ou droit.</span><span class="sxs-lookup"><span data-stu-id="99a6b-268">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="99a6b-269">Durant la mise en correspondance du chevron droit, affecter la sous-chaîne entre le groupe `Open` et le groupe actuel au groupe `Close` , puis supprimer la définition du groupe `Open` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-269">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="99a6b-270">Il s'agit du troisième groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-270">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="99a6b-271">Mettre en correspondance zéro occurrence, ou plus, du modèle suivant : une ou plusieurs occurrences d'un chevron gauche, suivies de zéro caractère, ou plus, autre qu'un chevron, suivis d'une ou plusieurs occurrences d'un chevron droit, suivies de zéro caractère, ou plus, autre qu'un chevron.</span><span class="sxs-lookup"><span data-stu-id="99a6b-271">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="99a6b-272">Durant la mise en correspondance du chevron droit, supprimer la définition du groupe `Open` et affecter la sous-chaîne entre le groupe `Open` et le groupe actuel au groupe `Close` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-272">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="99a6b-273">Il s'agit du premier groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-273">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="99a6b-274">Si le groupe `Open` existe, abandonner la recherche de correspondance si une chaîne vide peut être mise en correspondance, mais ne pas avancer la position du moteur d'expression régulière dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="99a6b-274">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="99a6b-275">Il s'agit d'une assertion de préanalyse négative de largeur nulle.</span><span class="sxs-lookup"><span data-stu-id="99a6b-275">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="99a6b-276">Comme une chaîne vide est toujours implicitement présente dans une chaîne d'entrée, cette recherche de correspondance échoue systématiquement.</span><span class="sxs-lookup"><span data-stu-id="99a6b-276">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="99a6b-277">L'échec de cette recherche de correspondance indique que les chevrons ne sont pas équilibrés.</span><span class="sxs-lookup"><span data-stu-id="99a6b-277">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="99a6b-278">Mettre en correspondance la fin de la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-278">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="99a6b-279">La sous-expression finale, `(?(Open)(?!))`, indique si les constructions d'imbrication dans la chaîne d'entrée sont correctement équilibrées (par exemple, si à chaque chevron gauche correspond un chevron droit).</span><span class="sxs-lookup"><span data-stu-id="99a6b-279">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="99a6b-280">Elle utilise une mise en correspondance conditionnelle basée sur un groupe capturé valide ; pour plus d'informations, voir [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="99a6b-280">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="99a6b-281">Si le groupe `Open` est défini, le moteur d'expression régulière essaie de mettre en correspondance la sous-expression `(?!)` dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-281">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="99a6b-282">Le groupe `Open` ne doit être défini que si les constructions d'imbrication ne sont pas équilibrées.</span><span class="sxs-lookup"><span data-stu-id="99a6b-282">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="99a6b-283">Le modèle à mettre en correspondance dans la chaîne d'entrée doit donc être un modèle qui entraîne systématiquement l'échec de la recherche de correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-283">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="99a6b-284">Dans ce cas, `(?!)` est une assertion de préanalyse négative de largeur nulle qui échoue systématiquement, car une chaîne vide est toujours implicitement présente à la position suivante dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-284">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="99a6b-285">Dans l'exemple, le moteur d'expression régulière évalue la chaîne d'entrée « \<abc><mno\<xyz>> » comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="99a6b-285">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="99a6b-286">Étape</span><span class="sxs-lookup"><span data-stu-id="99a6b-286">Step</span></span>|<span data-ttu-id="99a6b-287">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-287">Pattern</span></span>|<span data-ttu-id="99a6b-288">Résultat</span><span class="sxs-lookup"><span data-stu-id="99a6b-288">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="99a6b-289">1</span><span class="sxs-lookup"><span data-stu-id="99a6b-289">1</span></span>|`^`|<span data-ttu-id="99a6b-290">Commence la correspondance au début de la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-290">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="99a6b-291">2</span><span class="sxs-lookup"><span data-stu-id="99a6b-291">2</span></span>|`[^<>]*`|<span data-ttu-id="99a6b-292">Recherche des caractères autres que des chevrons avant le chevron gauche ; ne trouve aucune correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-292">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="99a6b-293">3</span><span class="sxs-lookup"><span data-stu-id="99a6b-293">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="99a6b-294">Met en correspondance le chevron gauche dans « \<abc> » et l'affecte au groupe `Open`.</span><span class="sxs-lookup"><span data-stu-id="99a6b-294">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="99a6b-295">4</span><span class="sxs-lookup"><span data-stu-id="99a6b-295">4</span></span>|`[^<>]*`|<span data-ttu-id="99a6b-296">Met en correspondance « abc ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-296">Matches "abc".</span></span>|  
|<span data-ttu-id="99a6b-297">5</span><span class="sxs-lookup"><span data-stu-id="99a6b-297">5</span></span>|`)+`|<span data-ttu-id="99a6b-298">« <abc » est la valeur du deuxième groupe capturé.</span><span class="sxs-lookup"><span data-stu-id="99a6b-298">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="99a6b-299">Le caractère suivant dans la chaîne d'entrée n'étant pas un chevron gauche, le moteur d'expression régulière ne repasse pas par le sous-modèle `(?'Open'<)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-299">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="99a6b-300">6</span><span class="sxs-lookup"><span data-stu-id="99a6b-300">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="99a6b-301">Met en correspondance le chevron droit dans «\<abc> », affecte « abc », qui est la sous-chaîne entre le groupe `Open` et le chevron droit, au groupe `Close`, puis supprime la valeur actuelle (« < ») du groupe `Open`, qui se trouve alors vide.</span><span class="sxs-lookup"><span data-stu-id="99a6b-301">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="99a6b-302">7</span><span class="sxs-lookup"><span data-stu-id="99a6b-302">7</span></span>|`[^<>]*`|<span data-ttu-id="99a6b-303">Recherche des caractères autres que des chevrons après le chevron droit ; ne trouve aucune correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-303">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="99a6b-304">8</span><span class="sxs-lookup"><span data-stu-id="99a6b-304">8</span></span>|`)+`|<span data-ttu-id="99a6b-305">La valeur du troisième groupe capturé est « > ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-305">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="99a6b-306">Le caractère suivant dans la chaîne d'entrée n'étant pas un chevron droit, le moteur d'expression régulière ne repasse pas par le sous-modèle `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-306">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="99a6b-307">9</span><span class="sxs-lookup"><span data-stu-id="99a6b-307">9</span></span>|`)*`|<span data-ttu-id="99a6b-308">La valeur du premier groupe capturé est « \<abc> ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-308">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="99a6b-309">Le caractère suivant dans la chaîne d'entrée étant un chevron gauche, le moteur d'expression régulière repasse par le sous-modèle `(((?'Open'<)` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-309">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="99a6b-310">10</span><span class="sxs-lookup"><span data-stu-id="99a6b-310">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="99a6b-311">Met en correspondance le chevron gauche dans « \<mno> » et l'affecte au groupe `Open`.</span><span class="sxs-lookup"><span data-stu-id="99a6b-311">Matches the left angle bracket in "\<mno>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="99a6b-312">Sa collection <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> ne possède maintenant qu'une valeur, en l'occurrence « < ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-312">Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="99a6b-313">11</span><span class="sxs-lookup"><span data-stu-id="99a6b-313">11</span></span>|`[^<>]*`|<span data-ttu-id="99a6b-314">Met en correspondance « mno ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-314">Matches "mno".</span></span>|  
|<span data-ttu-id="99a6b-315">12</span><span class="sxs-lookup"><span data-stu-id="99a6b-315">12</span></span>|`)+`|<span data-ttu-id="99a6b-316">« <mno » est la valeur du deuxième groupe capturé.</span><span class="sxs-lookup"><span data-stu-id="99a6b-316">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="99a6b-317">Le caractère suivant dans la chaîne d'entrée étant un chevron gauche, le moteur d'expression régulière repasse par le sous-modèle `(?'Open'<)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-317">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="99a6b-318">13</span><span class="sxs-lookup"><span data-stu-id="99a6b-318">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="99a6b-319">Met en correspondance le chevron gauche dans « \<xyz> » et l'affecte au groupe `Open`.</span><span class="sxs-lookup"><span data-stu-id="99a6b-319">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="99a6b-320">La collection <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> du groupe `Open` comprend maintenant deux captures : le chevron gauche dans « \<mno> » et le chevron gauche dans « \<xyz> ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-320">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno>", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="99a6b-321">14</span><span class="sxs-lookup"><span data-stu-id="99a6b-321">14</span></span>|`[^<>]*`|<span data-ttu-id="99a6b-322">Met en correspondance « xyz ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-322">Matches "xyz".</span></span>|  
|<span data-ttu-id="99a6b-323">15</span><span class="sxs-lookup"><span data-stu-id="99a6b-323">15</span></span>|`)+`|<span data-ttu-id="99a6b-324">« <xyz » est la valeur du deuxième groupe capturé.</span><span class="sxs-lookup"><span data-stu-id="99a6b-324">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="99a6b-325">Le caractère suivant dans la chaîne d'entrée n'étant pas un chevron gauche, le moteur d'expression régulière ne repasse pas par le sous-modèle `(?'Open'<)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-325">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="99a6b-326">16</span><span class="sxs-lookup"><span data-stu-id="99a6b-326">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="99a6b-327">Met en correspondance le chevron droit dans « \<xyz> ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-327">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="99a6b-328">"xyz" affecte la sous-chaîne entre le groupe `Open` et le chevron droit au groupe `Close` , puis supprime la valeur actuelle du groupe `Open` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-328">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="99a6b-329">La valeur de la capture précédente (le chevron gauche dans « \<mno> ») devient la valeur actuelle du groupe `Open`.</span><span class="sxs-lookup"><span data-stu-id="99a6b-329">The value of the previous capture (the left angle bracket in "\<mno>") becomes the current value of the `Open` group.</span></span> <span data-ttu-id="99a6b-330">La collection <xref:System.Text.RegularExpressions.Group.Captures%2A> du groupe `Open` comprend maintenant une seule capture, en l’occurrence le chevron gauche dans « \<xyz> ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-330">The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="99a6b-331">17</span><span class="sxs-lookup"><span data-stu-id="99a6b-331">17</span></span>|`[^<>]*`|<span data-ttu-id="99a6b-332">Recherche des caractères autres que des chevrons ; ne trouve aucune correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-332">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="99a6b-333">18</span><span class="sxs-lookup"><span data-stu-id="99a6b-333">18</span></span>|`)+`|<span data-ttu-id="99a6b-334">La valeur du troisième groupe capturé est « > ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-334">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="99a6b-335">Le caractère suivant dans la chaîne d'entrée étant un chevron droit, le moteur d'expression régulière repasse par le sous-modèle `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-335">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="99a6b-336">19</span><span class="sxs-lookup"><span data-stu-id="99a6b-336">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="99a6b-337">Met en correspondance le chevron droit final dans « xyz>> », affecte « mno\<xyz » (la sous-chaîne entre le groupe `Open` et le chevron droit) au groupe `Close`, puis supprime la valeur actuelle du groupe `Open`.</span><span class="sxs-lookup"><span data-stu-id="99a6b-337">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="99a6b-338">Le groupe `Open` est maintenant vide.</span><span class="sxs-lookup"><span data-stu-id="99a6b-338">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="99a6b-339">20</span><span class="sxs-lookup"><span data-stu-id="99a6b-339">20</span></span>|`[^<>]*`|<span data-ttu-id="99a6b-340">Recherche des caractères autres que des chevrons ; ne trouve aucune correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-340">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="99a6b-341">21</span><span class="sxs-lookup"><span data-stu-id="99a6b-341">21</span></span>|`)+`|<span data-ttu-id="99a6b-342">La valeur du troisième groupe capturé est « > ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-342">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="99a6b-343">Le caractère suivant dans la chaîne d'entrée n'étant pas un chevron droit, le moteur d'expression régulière ne repasse pas par le sous-modèle `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-343">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="99a6b-344">22</span><span class="sxs-lookup"><span data-stu-id="99a6b-344">22</span></span>|`)*`|<span data-ttu-id="99a6b-345">La valeur du premier groupe capturé est « <mno\<xyz>> ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-345">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="99a6b-346">Le caractère suivant dans la chaîne d'entrée n'étant pas un chevron gauche, le moteur d'expression régulière ne repasse pas par le sous-modèle `(((?'Open'<)` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-346">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="99a6b-347">23</span><span class="sxs-lookup"><span data-stu-id="99a6b-347">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="99a6b-348">Le groupe `Open` n'étant pas défini, aucune recherche de correspondance n'est effectuée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-348">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="99a6b-349">24</span><span class="sxs-lookup"><span data-stu-id="99a6b-349">24</span></span>|`$`|<span data-ttu-id="99a6b-350">Met en correspondance la fin de la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-350">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>   
## <a name="noncapturing-groups"></a><span data-ttu-id="99a6b-351">Groupes sans capture</span><span class="sxs-lookup"><span data-stu-id="99a6b-351">Noncapturing Groups</span></span>  
 <span data-ttu-id="99a6b-352">La construction de regroupement suivante ne capture pas la sous-chaîne mise en correspondance par une sous-expression :</span><span class="sxs-lookup"><span data-stu-id="99a6b-352">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
```  
(?:subexpression)  
```  
  
 <span data-ttu-id="99a6b-353">où *subexpression* représente un modèle d'expression régulière valide.</span><span class="sxs-lookup"><span data-stu-id="99a6b-353">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="99a6b-354">En règle générale, la construction de groupe sans capture est utilisée quand un quantificateur est appliqué à un groupe, mais que les sous-chaînes capturées par celui-ci ne présentent aucun intérêt.</span><span class="sxs-lookup"><span data-stu-id="99a6b-354">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="99a6b-355">Si une expression régulière comprend des constructions de regroupement imbriquées, une construction de groupe sans capture externe ne s'applique pas aux constructions de groupe imbriquées internes.</span><span class="sxs-lookup"><span data-stu-id="99a6b-355">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="99a6b-356">L'exemple suivant illustre une expression régulière qui comprend des groupes sans capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-356">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="99a6b-357">Notez que la sortie ne comprend aucun groupe capturé.</span><span class="sxs-lookup"><span data-stu-id="99a6b-357">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="99a6b-358">L'expression régulière `(?:\b(?:\w+)\W*)+\.` met en correspondance une phrase terminée par un point.</span><span class="sxs-lookup"><span data-stu-id="99a6b-358">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="99a6b-359">Comme l'expression régulière porte sur des phrases et non sur des mots spécifiques, les constructions de regroupement sont exclusivement utilisées en tant que quantificateurs.</span><span class="sxs-lookup"><span data-stu-id="99a6b-359">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="99a6b-360">Le modèle d'expression régulière est interprété comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="99a6b-360">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="99a6b-361">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-361">Pattern</span></span>|<span data-ttu-id="99a6b-362">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-362">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="99a6b-363">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-363">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="99a6b-364">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-364">Match one or more word characters.</span></span> <span data-ttu-id="99a6b-365">Ne pas affecter le texte mis en correspondance à un groupe capturé.</span><span class="sxs-lookup"><span data-stu-id="99a6b-365">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="99a6b-366">Mettre en correspondance zéro ou plusieurs caractères non alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-366">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="99a6b-367">Mettre en correspondance le modèle d'un ou plusieurs caractères alphabétiques en commençant à la limite d'un mot, suivi de zéro caractère non alphabétique, ou plus, une ou plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="99a6b-367">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="99a6b-368">Ne pas affecter le texte mis en correspondance à un groupe capturé.</span><span class="sxs-lookup"><span data-stu-id="99a6b-368">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="99a6b-369">Mettre en correspondance un point.</span><span class="sxs-lookup"><span data-stu-id="99a6b-369">Match a period.</span></span>|  
  
<a name="group_options"></a>   
## <a name="group-options"></a><span data-ttu-id="99a6b-370">Options de groupe</span><span class="sxs-lookup"><span data-stu-id="99a6b-370">Group Options</span></span>  
 <span data-ttu-id="99a6b-371">La construction de regroupement suivante applique ou désactive les options spécifiées dans une sous-expression :</span><span class="sxs-lookup"><span data-stu-id="99a6b-371">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="99a6b-372">`(?imnsx-imnsx:` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="99a6b-372">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="99a6b-373">où *subexpression* représente un modèle d'expression régulière valide.</span><span class="sxs-lookup"><span data-stu-id="99a6b-373">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="99a6b-374">Par exemple, `(?i-s:)` désactive la prise en compte des majuscules et des minuscules, ainsi que le mode à ligne simple.</span><span class="sxs-lookup"><span data-stu-id="99a6b-374">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="99a6b-375">Pour plus d'informations sur les options inline que vous pouvez spécifier, voir [Options des expressions régulières](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="99a6b-375">For more information about the inline options you can specify, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="99a6b-376">Vous pouvez spécifier des options qui s'appliquent à une expression régulière entière plutôt qu'à une sous-expression en utilisant un constructeur de classe <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> ou une méthode statique.</span><span class="sxs-lookup"><span data-stu-id="99a6b-376">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="99a6b-377">Vous pouvez également spécifier des options inline qui s'appliquent après un point spécifique dans une expression régulière en utilisant la construction de langage `(?imnsx-imnsx)` .</span><span class="sxs-lookup"><span data-stu-id="99a6b-377">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="99a6b-378">La construction des options de groupe n'est pas un groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-378">The group options construct is not a capturing group.</span></span> <span data-ttu-id="99a6b-379">En d'autres termes, bien qu'une partie d'une chaîne capturée par *sous-expression* soit incluse dans la correspondance, elle n'est pas placée dans un groupe capturé, ni utilisée pour remplir l'objet <xref:System.Text.RegularExpressions.GroupCollection> .</span><span class="sxs-lookup"><span data-stu-id="99a6b-379">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="99a6b-380">Dans l’exemple suivant, l’expression régulière `\b(?ix: d \w+)\s` utilise des options inline dans une construction de regroupement pour désactiver le respect de la casse et ignorer l’espace blanc du modèle durant l’identification de tous les mots commençant par la lettre « d ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-380">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern white space in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="99a6b-381">L'expression régulière est définie comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="99a6b-381">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="99a6b-382">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-382">Pattern</span></span>|<span data-ttu-id="99a6b-383">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-383">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="99a6b-384">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-384">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="99a6b-385">Sans prendre en compte les majuscules et les minuscules et en ignorant l'espace blanc dans ce modèle, mettre en correspondance un caractère « d » suivi d'un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-385">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="99a6b-386">Mettre en correspondance un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="99a6b-386">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>   
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="99a6b-387">Assertions de préanalyse positive de largeur nulle</span><span class="sxs-lookup"><span data-stu-id="99a6b-387">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="99a6b-388">La construction de regroupement suivante définit une assertion de préanalyse positive de largeur nulle :</span><span class="sxs-lookup"><span data-stu-id="99a6b-388">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="99a6b-389">`(?=` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="99a6b-389">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="99a6b-390">où *sous-expression* représente un modèle d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-390">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="99a6b-391">Pour qu'une recherche de correspondance réussisse, la chaîne d'entrée doit correspondre au modèle d'expression régulière dans *sous-expression*, bien que la sous-chaîne mise en correspondance ne soit pas incluse dans le résultat de la recherche de correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-391">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="99a6b-392">Une assertion de préanalyse positive de largeur nulle n'est pas rétroactive.</span><span class="sxs-lookup"><span data-stu-id="99a6b-392">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="99a6b-393">En règle générale, une assertion de préanalyse positive de largeur nulle est trouvée à la fin d'un modèle d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-393">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="99a6b-394">Elle définit une sous-chaîne qui doit être trouvée à la fin d'une chaîne pour qu'une mise en correspondance se produise, mais qui ne doit pas être incluse dans la correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-394">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="99a6b-395">En outre, elle est utile pour empêcher une rétroactivité excessive.</span><span class="sxs-lookup"><span data-stu-id="99a6b-395">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="99a6b-396">Vous pouvez utiliser une assertion de préanalyse positive de largeur nulle indiquant qu'un groupe capturé particulier doit commencer par un texte qui correspond à une partie du modèle défini pour ce groupe.</span><span class="sxs-lookup"><span data-stu-id="99a6b-396">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="99a6b-397">Par exemple, si un groupe de capture met en correspondance des caractères alphabétiques consécutifs, vous pouvez utiliser une assertion de préanalyse positive de largeur nulle pour imposer que le premier caractère soit un caractère majuscule alphabétique.</span><span class="sxs-lookup"><span data-stu-id="99a6b-397">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="99a6b-398">L'exemple suivant utilise une assertion de préanalyse positive de largeur nulle pour mettre en correspondance le mot qui précède le verbe « is » dans la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-398">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="99a6b-399">L'expression régulière `\b\w+(?=\sis\b)` est interprétée comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="99a6b-399">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="99a6b-400">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-400">Pattern</span></span>|<span data-ttu-id="99a6b-401">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-401">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="99a6b-402">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-402">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="99a6b-403">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-403">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="99a6b-404">Détermine si les caractères alphabétiques sont suivis d'un espace blanc et de la chaîne « is », qui se termine à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-404">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="99a6b-405">Si tel est le cas, la recherche de correspondance réussit.</span><span class="sxs-lookup"><span data-stu-id="99a6b-405">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>   
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="99a6b-406">Assertions de préanalyse négative de largeur nulle</span><span class="sxs-lookup"><span data-stu-id="99a6b-406">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="99a6b-407">La construction de regroupement suivante définit une assertion de préanalyse négative de largeur nulle :</span><span class="sxs-lookup"><span data-stu-id="99a6b-407">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="99a6b-408">`(?!` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="99a6b-408">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="99a6b-409">où *sous-expression* représente un modèle d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-409">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="99a6b-410">Pour que la recherche de correspondance réussisse, la chaîne d'entrée ne doit pas correspondre au modèle d'expression régulière dans *sous-expression*, bien que la chaîne mise en correspondance ne soit pas incluse dans le résultat de la recherche de correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-410">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="99a6b-411">En règle générale, une assertion de préanalyse négative de largeur nulle est utilisée au début ou à la fin d'une expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-411">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="99a6b-412">Au début d'une expression régulière, elle peut définir un modèle spécifique qui ne doit pas être mis en correspondance quand le début de l'expression régulière définit un modèle de recherche de correspondance similaire, mais plus général.</span><span class="sxs-lookup"><span data-stu-id="99a6b-412">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="99a6b-413">Dans ce cas, elle est souvent utilisée pour limiter la rétroactivité.</span><span class="sxs-lookup"><span data-stu-id="99a6b-413">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="99a6b-414">À la fin d'une expression régulière, elle peut définir une sous-expression qui ne peut pas apparaître à la fin d'une correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-414">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="99a6b-415">L'exemple suivant définit une expression régulière qui utilise une assertion de préanalyse de largeur nulle au début de l'expression régulière pour mettre en correspondance les mots qui ne commencent pas par « un ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-415">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="99a6b-416">L'expression régulière `\b(?!un)\w+\b` est interprétée comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="99a6b-416">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="99a6b-417">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-417">Pattern</span></span>|<span data-ttu-id="99a6b-418">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-418">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="99a6b-419">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-419">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="99a6b-420">Déterminer si les deux caractères suivants sont « un ».</span><span class="sxs-lookup"><span data-stu-id="99a6b-420">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="99a6b-421">Si tel n'est pas le cas, une correspondance est possible.</span><span class="sxs-lookup"><span data-stu-id="99a6b-421">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="99a6b-422">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-422">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="99a6b-423">Terminer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-423">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="99a6b-424">L'exemple suivant définit une expression régulière qui utilise une assertion de préanalyse de largeur nulle à la fin de l'expression régulière pour mettre en correspondance les mots qui ne se terminent pas par un caractère de ponctuation.</span><span class="sxs-lookup"><span data-stu-id="99a6b-424">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="99a6b-425">L'expression régulière `\b\w+\b(?!\p{P})` est interprétée comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="99a6b-425">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="99a6b-426">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-426">Pattern</span></span>|<span data-ttu-id="99a6b-427">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-427">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="99a6b-428">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-428">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="99a6b-429">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-429">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="99a6b-430">Terminer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-430">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="99a6b-431">Si le caractère suivant n'est pas un symbole de ponctuation (tel qu'un point ou une virgule), la recherche de correspondance réussit.</span><span class="sxs-lookup"><span data-stu-id="99a6b-431">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>   
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="99a6b-432">Assertions de postanalyse positive de largeur nulle</span><span class="sxs-lookup"><span data-stu-id="99a6b-432">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="99a6b-433">La construction de regroupement suivante définit une assertion de postanalyse positive de largeur nulle :</span><span class="sxs-lookup"><span data-stu-id="99a6b-433">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="99a6b-434">`(?<=` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="99a6b-434">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="99a6b-435">où *sous-expression* représente un modèle d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-435">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="99a6b-436">Pour qu'une recherche de correspondance réussisse, *sous-expression* doit se trouver dans la chaîne d'entrée à gauche de la position actuelle, bien que la sous-expression ( `subexpression` ) ne soit pas incluse dans le résultat de la recherche de correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-436">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="99a6b-437">Une assertion de postanalyse positive de largeur nulle n'est pas rétroactive.</span><span class="sxs-lookup"><span data-stu-id="99a6b-437">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="99a6b-438">Les assertions de postanalyse positive de largeur nulle sont généralement utilisées au début des expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="99a6b-438">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="99a6b-439">Le modèle qu'elles définissent est une condition préalable pour une correspondance, bien qu'il ne fasse pas partie du résultat de la recherche de correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-439">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="99a6b-440">L'exemple suivant met en correspondance les deux derniers chiffres des années appartenant au vingt et unième siècle (en d'autres termes, les chiffres « 20 » doivent précéder la chaîne mise en correspondance).</span><span class="sxs-lookup"><span data-stu-id="99a6b-440">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="99a6b-441">Le modèle d'expression régulière `(?<=\b20)\d{2}\b` est interprété comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="99a6b-441">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="99a6b-442">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-442">Pattern</span></span>|<span data-ttu-id="99a6b-443">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-443">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="99a6b-444">Mettre en correspondance deux chiffres décimaux.</span><span class="sxs-lookup"><span data-stu-id="99a6b-444">Match two decimal digits.</span></span>|  
|`(?<=\b20)`|<span data-ttu-id="99a6b-445">Continuer la mise en correspondance si les deux chiffres décimaux sont précédés des chiffres décimaux « 20 » à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-445">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="99a6b-446">Terminer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-446">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="99a6b-447">Les assertions de postanalyse positive de largeur nulle permettent également de limiter la rétroactivité quand le ou les derniers caractères d'un groupe capturé doivent être une partie des caractères qui correspondent au modèle d'expression régulière de ce groupe.</span><span class="sxs-lookup"><span data-stu-id="99a6b-447">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="99a6b-448">Par exemple, si un groupe capture tous les caractères alphabétiques consécutifs, vous pouvez utiliser une assertion de postanalyse positive de largeur nulle pour imposer que le dernier caractère soit un caractère alphabétique.</span><span class="sxs-lookup"><span data-stu-id="99a6b-448">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>   
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="99a6b-449">Assertions de postanalyse négative de largeur nulle</span><span class="sxs-lookup"><span data-stu-id="99a6b-449">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="99a6b-450">La construction de regroupement suivante définit une assertion de postanalyse négative de largeur nulle :</span><span class="sxs-lookup"><span data-stu-id="99a6b-450">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="99a6b-451">`(?<!` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="99a6b-451">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="99a6b-452">où *sous-expression* représente un modèle d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-452">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="99a6b-453">Pour qu'une recherche de correspondance réussisse, *sous-expression* ne doit pas se trouver dans la chaîne d'entrée à gauche de la position actuelle.</span><span class="sxs-lookup"><span data-stu-id="99a6b-453">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="99a6b-454">Toutefois, toute sous-chaîne qui ne correspond pas à `subexpression` est exclue du résultat de la recherche de correspondance.</span><span class="sxs-lookup"><span data-stu-id="99a6b-454">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="99a6b-455">Les assertions de postanalyse négative de largeur nulle sont généralement utilisées au début des expressions régulières.</span><span class="sxs-lookup"><span data-stu-id="99a6b-455">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="99a6b-456">Le modèle qu'elles définissent exclut une mise en correspondance dans la chaîne qui suit.</span><span class="sxs-lookup"><span data-stu-id="99a6b-456">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="99a6b-457">Elles permettent également de limiter la rétroactivité quand le ou les derniers caractères d'un groupe capturé ne doivent pas être un ou plusieurs des caractères qui correspondent au modèle d'expression régulière de ce groupe.</span><span class="sxs-lookup"><span data-stu-id="99a6b-457">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="99a6b-458">Par exemple, si un groupe capture tous les caractères alphabétiques consécutifs, vous pouvez utiliser une assertion de postanalyse positive de largeur nulle pour imposer que le dernier caractère ne soit pas un caractère de soulignement (_).</span><span class="sxs-lookup"><span data-stu-id="99a6b-458">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</span></span>  
  
 <span data-ttu-id="99a6b-459">L'exemple suivant met en correspondance la date de n'importe quel jour de la semaine ne tombant pas pendant le week-end (c'est-à-dire, tous les jours sauf le samedi et le dimanche).</span><span class="sxs-lookup"><span data-stu-id="99a6b-459">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="99a6b-460">Le modèle d'expression régulière `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` est interprété comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="99a6b-460">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="99a6b-461">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-461">Pattern</span></span>|<span data-ttu-id="99a6b-462">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-462">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="99a6b-463">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-463">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="99a6b-464">Mettre en correspondance un ou plusieurs caractères alphabétiques suivis d'un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="99a6b-464">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="99a6b-465">Mettre en correspondance un ou deux chiffres décimaux suivis d'un espace blanc et d'une virgule.</span><span class="sxs-lookup"><span data-stu-id="99a6b-465">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="99a6b-466">Mettre en correspondance quatre chiffres décimaux, puis terminer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-466">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="99a6b-467">Si la correspondance est précédée d'une chaîne autre que « Saturday » ou « Sunday » suivie d'un espace, la mise en correspondance réussit.</span><span class="sxs-lookup"><span data-stu-id="99a6b-467">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="nonbacktracking_subexpression"></a>   
## <a name="nonbacktracking-subexpressions"></a><span data-ttu-id="99a6b-468">Sous-expressions non rétroactives</span><span class="sxs-lookup"><span data-stu-id="99a6b-468">Nonbacktracking Subexpressions</span></span>  
 <span data-ttu-id="99a6b-469">La construction de regroupement suivante représente une sous-expression non rétroactive (ou « gourmande ») :</span><span class="sxs-lookup"><span data-stu-id="99a6b-469">The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</span></span>  
  
 <span data-ttu-id="99a6b-470">`(?>` *subexpression* `)`</span><span class="sxs-lookup"><span data-stu-id="99a6b-470">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="99a6b-471">où *sous-expression* représente un modèle d'expression régulière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-471">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="99a6b-472">D'ordinaire, si une expression régulière comprend un modèle de mise en correspondance facultatif ou de substitution et qu'aucune mise en correspondance ne réussit, le moteur d'expression régulière peut explorer plusieurs directions pour mettre en correspondance une chaîne d'entrée avec un modèle.</span><span class="sxs-lookup"><span data-stu-id="99a6b-472">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="99a6b-473">Si aucune correspondance n'est trouvée au niveau de la première branche, le moteur d'expression régulière peut revenir au point d'exécution de la première mise en correspondance et renouveler l'opération au niveau de la deuxième branche.</span><span class="sxs-lookup"><span data-stu-id="99a6b-473">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="99a6b-474">Ce processus peut se poursuivre jusqu'à ce que toutes les branches aient été essayées.</span><span class="sxs-lookup"><span data-stu-id="99a6b-474">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="99a6b-475">Le groupe `(?>`*subexpression*`)` désactive la rétroactivité.</span><span class="sxs-lookup"><span data-stu-id="99a6b-475">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="99a6b-476">Le moteur d'expression régulière met en correspondance tous les caractères possibles de la chaîne d'entrée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-476">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="99a6b-477">Quand aucune mise en correspondance supplémentaire n'est possible, il n'essaie pas d'effectuer une mise en correspondance de modèle de substitution de manière rétroactive.</span><span class="sxs-lookup"><span data-stu-id="99a6b-477">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="99a6b-478">(En d'autres termes, la sous-expression ne met en correspondance que les chaînes qu'elle seule peut mettre en correspondance ; elle n'essaie pas de mettre en correspondance une chaîne avec le concours de sous-expressions qui la suivent éventuellement.)</span><span class="sxs-lookup"><span data-stu-id="99a6b-478">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="99a6b-479">Cette option est recommandée si vous savez que la rétroactivité est vouée à l'échec.</span><span class="sxs-lookup"><span data-stu-id="99a6b-479">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="99a6b-480">Empêcher le moteur d'expression régulière d'effectuer des recherches superflues améliore les performances.</span><span class="sxs-lookup"><span data-stu-id="99a6b-480">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="99a6b-481">L'exemple suivant montre comment une sous-expression non rétroactive modifie les résultats d'une mise en correspondance de modèle.</span><span class="sxs-lookup"><span data-stu-id="99a6b-481">The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</span></span> <span data-ttu-id="99a6b-482">Contrairement à l'expression régulière non rétroactive, l'expression régulière rétroactive met en correspondance une série de caractères répétés suivis d'une occurrence supplémentaire du même caractère à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-482">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="99a6b-483">L'expression régulière non rétroactive `(?>(\w)\1+).\b` est définie comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="99a6b-483">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="99a6b-484">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-484">Pattern</span></span>|<span data-ttu-id="99a6b-485">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-485">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="99a6b-486">Mettre en correspondance un seul caractère alphabétique et l'affecter au premier groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-486">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="99a6b-487">Mettre en correspondance la valeur de la première sous-chaîne capturée une ou plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="99a6b-487">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="99a6b-488">Mettre en correspondance n'importe quel caractère.</span><span class="sxs-lookup"><span data-stu-id="99a6b-488">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="99a6b-489">Terminer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-489">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="99a6b-490">Mettre en correspondance une ou plusieurs occurrences d'un caractère alphabétique en double, mais ne pas effectuer rétroactivement une mise en correspondance du dernier caractère à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-490">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>   
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="99a6b-491">Constructions de regroupement et objets d'expression régulière</span><span class="sxs-lookup"><span data-stu-id="99a6b-491">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="99a6b-492">Les sous-chaînes mises en correspondance par un groupe de capture d'expression régulière sont représentées par des objets <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType>, qui peuvent être récupérés de l'objet <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> retourné par la propriété <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99a6b-492">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="99a6b-493">L'objet <xref:System.Text.RegularExpressions.GroupCollection> est rempli comme suit :</span><span class="sxs-lookup"><span data-stu-id="99a6b-493">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
-   <span data-ttu-id="99a6b-494">Le premier objet <xref:System.Text.RegularExpressions.Group> de la collection (l'objet d'index zéro) représente la correspondance entière.</span><span class="sxs-lookup"><span data-stu-id="99a6b-494">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
-   <span data-ttu-id="99a6b-495">L'ensemble d'objets <xref:System.Text.RegularExpressions.Group> suivant représente des groupes de capture sans nom (numérotés).</span><span class="sxs-lookup"><span data-stu-id="99a6b-495">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="99a6b-496">Ils apparaissent dans l'ordre dans lequel ils sont définis dans l'expression régulière, de la gauche vers la droite.</span><span class="sxs-lookup"><span data-stu-id="99a6b-496">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="99a6b-497">Les valeurs d'index de ces groupes vont de 1 au nombre de groupes de capture sans nom dans la collection.</span><span class="sxs-lookup"><span data-stu-id="99a6b-497">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="99a6b-498">(L'index d'un groupe particulier est équivalent à sa référence arrière numérotée.</span><span class="sxs-lookup"><span data-stu-id="99a6b-498">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="99a6b-499">Pour plus d'informations sur les références arrière, voir [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span><span class="sxs-lookup"><span data-stu-id="99a6b-499">For more information about backreferences, see [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span></span>  
  
-   <span data-ttu-id="99a6b-500">Le dernier ensemble d'objets <xref:System.Text.RegularExpressions.Group> représente des groupes de capture nommés.</span><span class="sxs-lookup"><span data-stu-id="99a6b-500">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="99a6b-501">Ils apparaissent dans l'ordre dans lequel ils sont définis dans l'expression régulière, de la gauche vers la droite.</span><span class="sxs-lookup"><span data-stu-id="99a6b-501">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="99a6b-502">La valeur d'index du premier groupe de capture nommé est égale à l'index du dernier groupe de capture sans nom, plus une unité.</span><span class="sxs-lookup"><span data-stu-id="99a6b-502">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="99a6b-503">En l'absence de groupe de capture sans nom dans l'expression régulière, la valeur d'index du premier groupe de capture nommé est égale à un (1).</span><span class="sxs-lookup"><span data-stu-id="99a6b-503">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="99a6b-504">Si vous appliquez un quantificateur à un groupe de capture, les propriétés <xref:System.Text.RegularExpressions.Group>, <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType> et <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType> de l'objet <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> correspondant reflètent la dernière sous-chaîne capturée par un groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-504">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="99a6b-505">Vous pouvez récupérer de l'objet <xref:System.Text.RegularExpressions.CaptureCollection> retourné par la propriété <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> un ensemble complet de sous-chaînes capturées par des groupes possédant des quantificateurs.</span><span class="sxs-lookup"><span data-stu-id="99a6b-505">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="99a6b-506">L'exemple suivant clarifie la relation entre les objets <xref:System.Text.RegularExpressions.Group> et <xref:System.Text.RegularExpressions.Capture> .</span><span class="sxs-lookup"><span data-stu-id="99a6b-506">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="99a6b-507">Le modèle d'expression régulière `\b(\w+)\W+)+` extrait des mots spécifiques d'une chaîne.</span><span class="sxs-lookup"><span data-stu-id="99a6b-507">The regular expression pattern `\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="99a6b-508">Il est défini comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="99a6b-508">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="99a6b-509">Motif</span><span class="sxs-lookup"><span data-stu-id="99a6b-509">Pattern</span></span>|<span data-ttu-id="99a6b-510">Description</span><span class="sxs-lookup"><span data-stu-id="99a6b-510">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="99a6b-511">Commencer la correspondance à la limite d'un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-511">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="99a6b-512">Mettre en correspondance un ou plusieurs caractères alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-512">Match one or more word characters.</span></span> <span data-ttu-id="99a6b-513">Ensemble, ces caractères forment un mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-513">Together, these characters form a word.</span></span> <span data-ttu-id="99a6b-514">Il s'agit du deuxième groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-514">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="99a6b-515">Mettre en correspondance un ou plusieurs caractères non alphabétiques.</span><span class="sxs-lookup"><span data-stu-id="99a6b-515">Match one or more non-word characters.</span></span>|  
|`(\w+)\W+)+`|<span data-ttu-id="99a6b-516">Mettre en correspondance le modèle d'un ou plusieurs caractères alphabétiques, suivis d'un ou plusieurs caractères non alphabétiques, une ou plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="99a6b-516">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="99a6b-517">Il s'agit du premier groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-517">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="99a6b-518">Le premier groupe de capture met en correspondance chaque mot de la phrase.</span><span class="sxs-lookup"><span data-stu-id="99a6b-518">The first capturing group matches each word of the sentence.</span></span> <span data-ttu-id="99a6b-519">Le second groupe de capture met en correspondance chaque mot, ainsi que la ponctuation et l'espace blanc qui suivent le mot.</span><span class="sxs-lookup"><span data-stu-id="99a6b-519">The second capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="99a6b-520">L'objet <xref:System.Text.RegularExpressions.Group> dont l'index a pour valeur 2 fournit des informations sur le texte mis en correspondance par le second groupe de capture.</span><span class="sxs-lookup"><span data-stu-id="99a6b-520">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="99a6b-521">Tous les mots capturés par le groupe de capture sont récupérables de l'objet <xref:System.Text.RegularExpressions.CaptureCollection> retourné par la propriété <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99a6b-521">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="99a6b-522">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="99a6b-522">See Also</span></span>  
 [<span data-ttu-id="99a6b-523">Langage des expressions régulières - Aide-mémoire</span><span class="sxs-lookup"><span data-stu-id="99a6b-523">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
 [<span data-ttu-id="99a6b-524">Rétroaction</span><span class="sxs-lookup"><span data-stu-id="99a6b-524">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
