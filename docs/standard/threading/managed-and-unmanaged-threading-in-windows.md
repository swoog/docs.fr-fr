---
title: Threading managé et non managé dans Windows
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 1be82fd9f26e382f20913551f67e8303cf20e03b
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/03/2018
ms.locfileid: "43390611"
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="1a373-102">Threading managé et non managé dans Windows</span><span class="sxs-lookup"><span data-stu-id="1a373-102">Managed and Unmanaged Threading in Windows</span></span>
<span data-ttu-id="1a373-103">La gestion de tous les threads s'effectue par le biais de la classe <xref:System.Threading.Thread> , notamment les threads créés par le Common Language Runtime et ceux créés en dehors du runtime qui entrent dans l'environnement managé pour exécuter du code.</span><span class="sxs-lookup"><span data-stu-id="1a373-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="1a373-104">Le runtime surveille tous les threads dans son processus qui ont exécuté du code dans l'environnement d'exécution managé.</span><span class="sxs-lookup"><span data-stu-id="1a373-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="1a373-105">Il n'effectue le suivi d'aucun autre thread.</span><span class="sxs-lookup"><span data-stu-id="1a373-105">It does not track any other threads.</span></span> <span data-ttu-id="1a373-106">Les threads peuvent entrer dans l’environnement d’exécution managé par le biais du service COM Interop (car le runtime expose les objets managés en tant qu’objets COM à l’environnement non managé), de la fonction COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) et de l’appel de code non managé.</span><span class="sxs-lookup"><span data-stu-id="1a373-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="1a373-107">Quand un thread non managé entre dans le runtime via, par exemple, un wrapper CCW (COM Callable Wrapper), le système vérifie si le magasin de threads local de ce thread contient un objet <xref:System.Threading.Thread> managé interne.</span><span class="sxs-lookup"><span data-stu-id="1a373-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="1a373-108">Si un objet de ce type est trouvé, le runtime connaît déjà ce thread.</span><span class="sxs-lookup"><span data-stu-id="1a373-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="1a373-109">Sinon, le runtime crée quand même un objet <xref:System.Threading.Thread> et l’installe dans le magasin de threads local de ce thread.</span><span class="sxs-lookup"><span data-stu-id="1a373-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="1a373-110">Dans le modèle de thread managé, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> identifie les threads managés de manière stable.</span><span class="sxs-lookup"><span data-stu-id="1a373-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="1a373-111">Durant toute la durée de vie de votre thread, cette identification n'entre en conflit avec la valeur d'aucun autre thread, quel que soit le domaine d'application à partir duquel vous obtenez cette valeur.</span><span class="sxs-lookup"><span data-stu-id="1a373-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1a373-112">Un **ID de thread** de système d'exploitation n'est pas lié de manière fixe à un thread managé, car un hôte non managé peut contrôler la relation entre les threads managés et les threads non managés.</span><span class="sxs-lookup"><span data-stu-id="1a373-112">An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="1a373-113">En particulier, un hôte élaboré peut utiliser l'API Fiber pour planifier de nombreux threads managés par rapport au même thread de système d'exploitation, ou pour déplacer un thread managé parmi différents threads de système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="1a373-113">Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="1a373-114">Correspondance entre les éléments de thread Win32 et les éléments de thread managés</span><span class="sxs-lookup"><span data-stu-id="1a373-114">Mapping from Win32 Threading to Managed Threading</span></span>  
 <span data-ttu-id="1a373-115">Le tableau suivant établit une correspondance entre les éléments de thread Win32 et leurs équivalents approximatifs dans le runtime.</span><span class="sxs-lookup"><span data-stu-id="1a373-115">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="1a373-116">Notez que cette mise en correspondance ne représente pas des fonctionnalités identiques.</span><span class="sxs-lookup"><span data-stu-id="1a373-116">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="1a373-117">Par exemple, **TerminateThread** n'exécute pas de clauses **finally** ou ne libère pas de ressources, et son exécution ne peut pas être empêchée.</span><span class="sxs-lookup"><span data-stu-id="1a373-117">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="1a373-118">Toutefois, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> exécute tout votre code de restauration, récupère toutes les ressources et peut être refusé à l'aide de <xref:System.Threading.Thread.ResetAbort%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a373-118">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="1a373-119">Veillez à lire la documentation attentivement avant d'émettre des hypothèses sur les fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="1a373-119">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="1a373-120">Dans Win32</span><span class="sxs-lookup"><span data-stu-id="1a373-120">In Win32</span></span>|<span data-ttu-id="1a373-121">Dans le Common Language Runtime</span><span class="sxs-lookup"><span data-stu-id="1a373-121">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="1a373-122">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="1a373-122">**CreateThread**</span></span>|<span data-ttu-id="1a373-123">Combinaison de **Thread** et <xref:System.Threading.ThreadStart></span><span class="sxs-lookup"><span data-stu-id="1a373-123">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="1a373-124">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="1a373-124">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="1a373-125">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="1a373-125">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="1a373-126">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="1a373-126">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="1a373-127">**Sleep**</span><span class="sxs-lookup"><span data-stu-id="1a373-127">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="1a373-128">**WaitForSingleObject** sur le handle de thread</span><span class="sxs-lookup"><span data-stu-id="1a373-128">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="1a373-129">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="1a373-129">**ExitThread**</span></span>|<span data-ttu-id="1a373-130">Aucun équivalent</span><span class="sxs-lookup"><span data-stu-id="1a373-130">No equivalent</span></span>|  
|<span data-ttu-id="1a373-131">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="1a373-131">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="1a373-132">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="1a373-132">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="1a373-133">Aucun équivalent</span><span class="sxs-lookup"><span data-stu-id="1a373-133">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="1a373-134">Aucun équivalent</span><span class="sxs-lookup"><span data-stu-id="1a373-134">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="1a373-135">Proche de **CoInitializeEx** (OLE32.DLL)</span><span class="sxs-lookup"><span data-stu-id="1a373-135">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="1a373-136">Threads managés et cloisonnements COM</span><span class="sxs-lookup"><span data-stu-id="1a373-136">Managed Threads and COM Apartments</span></span>  
 <span data-ttu-id="1a373-137">Un thread managé peut être marqué pour indiquer qu’il hébergera un [thread unique cloisonné](/windows/desktop/com/single-threaded-apartments) ou un [multithread cloisonné](/windows/desktop/com/multithreaded-apartments).</span><span class="sxs-lookup"><span data-stu-id="1a373-137">A managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment.</span></span> <span data-ttu-id="1a373-138">(Pour plus d’informations sur l’architecture des threads COM, consultez l’article [Processes, threads, and Apartments](https://msdn.microsoft.com/library/windows/desktop/ms693344.aspx) (Processus, threads et cloisonnements).) Les méthodes <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> et <xref:System.Threading.Thread.TrySetApartmentState%2A> de la classe <xref:System.Threading.Thread> retournent et affectent l'état de cloisonnement d'un thread.</span><span class="sxs-lookup"><span data-stu-id="1a373-138">(For more information on the COM threading architecture, see [Processes, threads, and Apartments](https://msdn.microsoft.com/library/windows/desktop/ms693344.aspx).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="1a373-139">Si l'état n’a pas été défini, <xref:System.Threading.Thread.GetApartmentState%2A> retourne <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a373-139">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1a373-140">La propriété ne peut être définie que quand le thread se trouve dans l’état <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> et qu’une seule fois par thread.</span><span class="sxs-lookup"><span data-stu-id="1a373-140">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="1a373-141">Si l'état de cloisonnement n'est pas défini avant que le thread n'ait démarré, celui-ci est initialisé en tant que cloisonnement multithread (MTA).</span><span class="sxs-lookup"><span data-stu-id="1a373-141">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="1a373-142">Le thread finaliseur et tous les threads contrôlés par <xref:System.Threading.ThreadPool> sont des threads MTA.</span><span class="sxs-lookup"><span data-stu-id="1a373-142">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1a373-143">Pour le code de démarrage d'application, la seule façon de contrôler l'état de cloisonnement consiste à appliquer les attributs <xref:System.MTAThreadAttribute> ou <xref:System.STAThreadAttribute> à la procédure de point d'entrée.</span><span class="sxs-lookup"><span data-stu-id="1a373-143">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="1a373-144">Dans .NET Framework 1.0 et 1.1, la propriété <xref:System.Threading.Thread.ApartmentState%2A> peut être définie en tant que première ligne de code.</span><span class="sxs-lookup"><span data-stu-id="1a373-144">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="1a373-145">Cette opération n'est pas autorisée dans .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="1a373-145">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="1a373-146">Les objets managés exposés à COM se comportent comme s'ils avaient agrégé le marshaleur libre de threads.</span><span class="sxs-lookup"><span data-stu-id="1a373-146">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="1a373-147">En d'autres termes, ils peuvent être appelés depuis n'importe quel cloisonnement COM d'une manière libre de threads.</span><span class="sxs-lookup"><span data-stu-id="1a373-147">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="1a373-148">Les seuls objets managés qui ne présentent pas ce comportement libre de threads sont les objets qui dérivent de <xref:System.EnterpriseServices.ServicedComponent> ou <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span><span class="sxs-lookup"><span data-stu-id="1a373-148">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="1a373-149">Dans l'environnement managé, l'attribut <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> n'est pas pris en charge, sauf si vous utilisez des contextes et des instances managées liées au contexte.</span><span class="sxs-lookup"><span data-stu-id="1a373-149">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="1a373-150">Si vous utilisez Enterprise Services, votre objet doit dériver de <xref:System.EnterpriseServices.ServicedComponent> (lui-même dérivé de <xref:System.ContextBoundObject>).</span><span class="sxs-lookup"><span data-stu-id="1a373-150">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="1a373-151">Quand un code managé appelle des objets COM, il suit systématiquement les règles COM.</span><span class="sxs-lookup"><span data-stu-id="1a373-151">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="1a373-152">En d'autres termes, il effectue les appels par le biais de proxys de cloisonnement COM et de wrappers de contexte COM+ 1.0, conformément à OLE32.</span><span class="sxs-lookup"><span data-stu-id="1a373-152">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="1a373-153">Problèmes de blocage</span><span class="sxs-lookup"><span data-stu-id="1a373-153">Blocking Issues</span></span>  
 <span data-ttu-id="1a373-154">Si un thread effectue dans le système d'exploitation un appel non managé et qu'il se retrouve bloqué dans un code non managé, le runtime ne prend pas le contrôle du thread pour <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> ou <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a373-154">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1a373-155">Dans le cas de <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, le runtime marque le thread comme **Abandonné** et en prend le contrôle quand il revient dans le code managé.</span><span class="sxs-lookup"><span data-stu-id="1a373-155">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="1a373-156">Pensez à utiliser un blocage managé plutôt qu'un blocage non managé.</span><span class="sxs-lookup"><span data-stu-id="1a373-156">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="1a373-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, etc. réagissent tous à <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> et à <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a373-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1a373-158">En outre, si votre thread se trouve dans un cloisonnement monothread, toutes ces opérations de blocage managé pompent correctement les messages dans votre cloisonnement pendant que votre thread est bloqué.</span><span class="sxs-lookup"><span data-stu-id="1a373-158">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1a373-159">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="1a373-159">See Also</span></span>  
 <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>  
 <xref:System.Threading.ThreadState>  
 <xref:System.EnterpriseServices.ServicedComponent>  
 <xref:System.Threading.Thread>  
 <xref:System.Threading.Monitor>
