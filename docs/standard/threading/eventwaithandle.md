---
title: EventWaitHandle
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: cdb11b283cc008e7f4bb060d1c2cb18706c824b7
ms.sourcegitcommit: 64f4baed249341e5bf64d1385bf48e3f2e1a0211
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/07/2018
ms.locfileid: "44084716"
---
# <a name="eventwaithandle"></a><span data-ttu-id="591fb-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="591fb-102">EventWaitHandle</span></span>
<span data-ttu-id="591fb-103">La classe <xref:System.Threading.EventWaitHandle> permet aux threads de communiquer entre eux en signalant et en attendant des signaux.</span><span class="sxs-lookup"><span data-stu-id="591fb-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="591fb-104">Les handles d’attente d’événement (également appelés simplement des événements) sont des handles d’attente qui peuvent être signalés pour libérer un ou plusieurs threads en attente.</span><span class="sxs-lookup"><span data-stu-id="591fb-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="591fb-105">Une fois signalé, un handle d’attente d’événement est réinitialisé manuellement ou automatiquement.</span><span class="sxs-lookup"><span data-stu-id="591fb-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="591fb-106">La classe <xref:System.Threading.EventWaitHandle> peut représenter un handle d’attente d’événement local (événement local) ou un handle d’attente d’événement système nommé (événement nommé ou événement système, visible par tous les processus).</span><span class="sxs-lookup"><span data-stu-id="591fb-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="591fb-107">Les handles d’attente d’événements ne sont pas des événements dans le sens généralement donné à ce terme dans .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="591fb-107">Event wait handles are not events in the sense usually meant by that word in the .NET Framework.</span></span> <span data-ttu-id="591fb-108">Aucun délégué ni gestionnaire d’événements n’est impliqué.</span><span class="sxs-lookup"><span data-stu-id="591fb-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="591fb-109">Le terme « événement » est utilisé pour les décrire, car ils sont généralement connus sous le nom d’événements du système d’exploitation, et le fait de signaler le handle d’attente indique aux threads en attente qu’un événement s’est produit.</span><span class="sxs-lookup"><span data-stu-id="591fb-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="591fb-110">Les handles d’attente d’événement locaux et nommés utilisent des objets de synchronisation du système, qui sont protégés par des wrappers <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> pour garantir la libération des ressources.</span><span class="sxs-lookup"><span data-stu-id="591fb-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="591fb-111">Vous pouvez utiliser la méthode <xref:System.Threading.WaitHandle.Dispose%2A> pour libérer les ressources immédiatement après avoir terminé d’utiliser l’objet.</span><span class="sxs-lookup"><span data-stu-id="591fb-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="591fb-112">Handles d’attente d’événement à réinitialisation automatique</span><span class="sxs-lookup"><span data-stu-id="591fb-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="591fb-113">Pour créer un événement à réinitialisation automatique, spécifiez <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> quand vous créez l’objet <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="591fb-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="591fb-114">Comme son nom l’indique, cet événement de synchronisation est réinitialisé automatiquement quand il est signalé, après avoir libéré un thread en attente.</span><span class="sxs-lookup"><span data-stu-id="591fb-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="591fb-115">Signalez l’événement en appelant sa méthode <xref:System.Threading.EventWaitHandle.Set%2A>.</span><span class="sxs-lookup"><span data-stu-id="591fb-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="591fb-116">Les événements à réinitialisation automatique servent généralement à fournir un accès exclusif à une ressource pour un thread à la fois.</span><span class="sxs-lookup"><span data-stu-id="591fb-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="591fb-117">Un thread demande la ressource en appelant la méthode <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="591fb-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="591fb-118">Si aucun autre thread ne détient le handle d’attente, la méthode retourne `true`, et le thread appelant contrôle la ressource.</span><span class="sxs-lookup"><span data-stu-id="591fb-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="591fb-119">Comme avec tous les mécanismes de synchronisation, vous devez veiller à ce que tous les chemins de code attendent le handle d’attente approprié avant d’accéder à une ressource protégée.</span><span class="sxs-lookup"><span data-stu-id="591fb-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="591fb-120">La synchronisation des threads est coopérative.</span><span class="sxs-lookup"><span data-stu-id="591fb-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="591fb-121">Si un événement à réinitialisation automatique est signalé alors qu’aucun thread n’attend, il reste signalé jusqu'à ce qu’un thread tente de l’attendre.</span><span class="sxs-lookup"><span data-stu-id="591fb-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="591fb-122">L’événement libère le thread et est immédiatement réinitialisé, ce qui bloque les threads suivants.</span><span class="sxs-lookup"><span data-stu-id="591fb-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="591fb-123">Handles d’attente d’événement à réinitialisation manuelle</span><span class="sxs-lookup"><span data-stu-id="591fb-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="591fb-124">Pour créer un événement à réinitialisation manuelle, spécifiez <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> quand vous créez l’objet <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="591fb-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="591fb-125">Comme son nom l’indique, cet événement de synchronisation doit être réinitialisé manuellement après avoir été signalé.</span><span class="sxs-lookup"><span data-stu-id="591fb-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="591fb-126">Jusqu'à sa réinitialisation, en appelant sa méthode <xref:System.Threading.EventWaitHandle.Reset%2A>, les threads qui attendent le handle d’événement continuent immédiatement, sans blocage.</span><span class="sxs-lookup"><span data-stu-id="591fb-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="591fb-127">Un événement manuel agit comme la barrière d’un corral.</span><span class="sxs-lookup"><span data-stu-id="591fb-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="591fb-128">Quand l’événement n’est pas signalé, les threads qui l’attendent sont bloqués, comme les chevaux dans un corral.</span><span class="sxs-lookup"><span data-stu-id="591fb-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="591fb-129">Quand l’événement est signalé, en appelant sa méthode <xref:System.Threading.EventWaitHandle.Set%2A>, tous les threads en attente sont libres de continuer.</span><span class="sxs-lookup"><span data-stu-id="591fb-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="591fb-130">L’événement reste signalé jusqu'à ce que sa méthode <xref:System.Threading.EventWaitHandle.Reset%2A> soit appelée.</span><span class="sxs-lookup"><span data-stu-id="591fb-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="591fb-131">L’événement à réinitialisation manuelle est par conséquent un moyen idéal de retenir les threads qui doivent attendre jusqu'à ce qu’un thread termine une tâche.</span><span class="sxs-lookup"><span data-stu-id="591fb-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="591fb-132">À l’instar des chevaux qui quittent un corral, le système d’exploitation a besoin d’un certain temps pour planifier les threads libérés et reprendre l’exécution.</span><span class="sxs-lookup"><span data-stu-id="591fb-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="591fb-133">Si la méthode <xref:System.Threading.EventWaitHandle.Reset%2A> est appelée avant la reprise de l’exécution de tous les threads, les threads restants sont une nouvelle fois bloqués.</span><span class="sxs-lookup"><span data-stu-id="591fb-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="591fb-134">La détermination des threads qui reprennent et des threads bloqués dépend de facteurs aléatoires, tels que la charge sur le système, le nombre de threads en attente du planificateur, etc.</span><span class="sxs-lookup"><span data-stu-id="591fb-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="591fb-135">Ce n’est pas un problème si le thread qui signale l’événement se termine après le signalement, ce qui représente le modèle d’utilisation le plus courant.</span><span class="sxs-lookup"><span data-stu-id="591fb-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="591fb-136">Si vous souhaitez que le thread qui a signalé l’événement commence une nouvelle tâche après la reprise de tous les threads, vous devez le bloquer jusqu'à ce que tous les threads en attente aient repris.</span><span class="sxs-lookup"><span data-stu-id="591fb-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="591fb-137">Dans le cas contraire, il existe une condition de concurrence et le comportement de votre code est imprévisible.</span><span class="sxs-lookup"><span data-stu-id="591fb-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="591fb-138">Fonctionnalités communes aux événements automatiques et manuels</span><span class="sxs-lookup"><span data-stu-id="591fb-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="591fb-139">En général, un ou plusieurs threads sont bloqués sur un <xref:System.Threading.EventWaitHandle> jusqu'à ce qu’un thread débloqué appelle la méthode <xref:System.Threading.EventWaitHandle.Set%2A>, ce qui libère l’un des threads en attente (en cas d’événements à réinitialisation automatique) ou tous les threads (en cas d’événements à réinitialisation manuelle).</span><span class="sxs-lookup"><span data-stu-id="591fb-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="591fb-140">Un thread peut signaler un <xref:System.Threading.EventWaitHandle>, puis se bloquer sur celui-ci, comme une opération atomique, en appelant la méthode statique <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="591fb-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="591fb-141">Des objets <xref:System.Threading.EventWaitHandle> peuvent être utilisés avec les méthodes statique <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> et <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="591fb-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="591fb-142">Étant donné que les classes <xref:System.Threading.EventWaitHandle> et <xref:System.Threading.Mutex> dérivent de <xref:System.Threading.WaitHandle>, vous pouvez utiliser les deux classes avec ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="591fb-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="591fb-143">Événements nommés</span><span class="sxs-lookup"><span data-stu-id="591fb-143">Named Events</span></span>  
 <span data-ttu-id="591fb-144">Le système d'exploitation Windows permet d'attribuer un nom aux handles d'attente d'événement.</span><span class="sxs-lookup"><span data-stu-id="591fb-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="591fb-145">Un événement nommé est disponible à l'échelle du système.</span><span class="sxs-lookup"><span data-stu-id="591fb-145">A named event is system wide.</span></span> <span data-ttu-id="591fb-146">C'est-à-dire qu'une fois créé, l’événement nommé est visible par tous les threads de tous les processus.</span><span class="sxs-lookup"><span data-stu-id="591fb-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="591fb-147">Par conséquent, un événement nommé peut être utilisé pour synchroniser aussi bien des activités de processus que des threads.</span><span class="sxs-lookup"><span data-stu-id="591fb-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="591fb-148">Vous pouvez créer un objet <xref:System.Threading.EventWaitHandle> qui représente un événement système nommé en utilisant l'un des constructeurs qui spécifient un nom.</span><span class="sxs-lookup"><span data-stu-id="591fb-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="591fb-149">Étant donné que les événements nommés sont disponibles à l'échelle du système, il est possible que plusieurs objets <xref:System.Threading.EventWaitHandle> représentent le même événement nommé.</span><span class="sxs-lookup"><span data-stu-id="591fb-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="591fb-150">Chaque fois que vous appelez un constructeur ou la méthode <xref:System.Threading.EventWaitHandle.OpenExisting%2A>, un nouvel objet <xref:System.Threading.EventWaitHandle> est créé.</span><span class="sxs-lookup"><span data-stu-id="591fb-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="591fb-151">Le fait de spécifier un même nom plusieurs fois crée plusieurs objets qui représentent le même événement nommé.</span><span class="sxs-lookup"><span data-stu-id="591fb-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="591fb-152">Notez que les événements nommés doivent être utilisés avec prudence.</span><span class="sxs-lookup"><span data-stu-id="591fb-152">Caution is advised in using named events.</span></span> <span data-ttu-id="591fb-153">En effet, étant donné qu'ils sont disponibles à l'échelle du système, un autre processus portant le même nom peut bloquer vos threads de manière inattendue.</span><span class="sxs-lookup"><span data-stu-id="591fb-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="591fb-154">Du code malveillant exécuté sur le même ordinateur pourrait s'en servir pour une attaque par déni de service.</span><span class="sxs-lookup"><span data-stu-id="591fb-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="591fb-155">Utilisez la sécurité de contrôle d'accès pour protéger un objet <xref:System.Threading.EventWaitHandle> qui représente un événement nommé, de préférence à l’aide d’un constructeur qui spécifie un objet <xref:System.Security.AccessControl.EventWaitHandleSecurity>.</span><span class="sxs-lookup"><span data-stu-id="591fb-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="591fb-156">Vous pouvez également appliquer la sécurité de contrôle d'accès à l'aide de la méthode <xref:System.Threading.EventWaitHandle.SetAccessControl%2A>. Sachez toutefois que cela crée une vulnérabilité entre le moment où le handle d'attente d'événement est créé et celui où il est protégé.</span><span class="sxs-lookup"><span data-stu-id="591fb-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="591fb-157">La protection des événements à l’aide de la sécurité de contrôle d'accès empêche les attaques malveillantes, mais ne résout pas le problème des conflits de noms involontaires.</span><span class="sxs-lookup"><span data-stu-id="591fb-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="591fb-158">Contrairement à la classe <xref:System.Threading.EventWaitHandle>, les classes dérivées <xref:System.Threading.AutoResetEvent> et <xref:System.Threading.ManualResetEvent> peuvent uniquement représenter des handles d'attente locaux.</span><span class="sxs-lookup"><span data-stu-id="591fb-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="591fb-159">Elles ne peuvent pas représenter des événements système nommés.</span><span class="sxs-lookup"><span data-stu-id="591fb-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="591fb-160">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="591fb-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>  
- <xref:System.Threading.WaitHandle>  
- <xref:System.Threading.AutoResetEvent>  
- <xref:System.Threading.ManualResetEvent>  
- [<span data-ttu-id="591fb-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="591fb-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)
