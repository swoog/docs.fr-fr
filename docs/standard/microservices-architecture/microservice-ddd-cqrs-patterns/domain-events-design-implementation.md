---
title: Événements de domaine. Conception et implémentation
description: Architecture des microservices .NET pour les applications .NET conteneurisées | Obtenir une vue détaillée des événements de domaine, un concept essentiel pour établir la communication entre les agrégats.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/08/2018
ms.openlocfilehash: fc71e661a5fd2de2a69da36df0fc60616b149802
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/10/2018
ms.locfileid: "53127847"
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="70be3-104">Événements de domaine : conception et implémentation</span><span class="sxs-lookup"><span data-stu-id="70be3-104">Domain events: design and implementation</span></span>

<span data-ttu-id="70be3-105">Utilisez des événements de domaine pour implémenter explicitement les effets secondaires des modifications apportées à votre domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-105">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="70be3-106">En d’autres termes, pour utiliser la terminologie DDD, les événements de domaine permettent d’implémenter explicitement des effets secondaires sur plusieurs agrégats.</span><span class="sxs-lookup"><span data-stu-id="70be3-106">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="70be3-107">Si vous le souhaitez, pour une meilleure scalabilité et un impact moindre sur les verrous de base de données, utilisez la cohérence à terme entre les agrégats d’un même domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-107">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="70be3-108">Qu’est-ce qu’un événement de domaine ?</span><span class="sxs-lookup"><span data-stu-id="70be3-108">What is a domain event?</span></span>

<span data-ttu-id="70be3-109">Un événement est quelque chose qui s’est produit dans le passé.</span><span class="sxs-lookup"><span data-stu-id="70be3-109">An event is something that has happened in the past.</span></span> <span data-ttu-id="70be3-110">Un événement de domaine est quelque chose qui s’est produit dans le domaine et dont vous voulez que les autres parties du même domaine (in-process) soient informées.</span><span class="sxs-lookup"><span data-stu-id="70be3-110">A domain event is, something that happened in the domain that you want other parts of the same domain (in-process) to be aware of.</span></span> <span data-ttu-id="70be3-111">Les parties notifiées réagissent généralement aux événements.</span><span class="sxs-lookup"><span data-stu-id="70be3-111">The notified parts usually react somehow to the events.</span></span>

<span data-ttu-id="70be3-112">Un avantage important des événements de domaine est que les effets secondaires peuvent être exprimés de façon explicite.</span><span class="sxs-lookup"><span data-stu-id="70be3-112">An important benefit of domain events is that side effects can be expressed explicitly.</span></span>

<span data-ttu-id="70be3-113">Par exemple, si vous utilisez simplement Entity Framework et qu’il doit y avoir une réaction à un événement, vous allez probablement coder ce dont vous avez besoin d’une façon étroitement liée à ce qui déclenche l’événement.</span><span class="sxs-lookup"><span data-stu-id="70be3-113">For example, if you're just using Entity Framework and there has to be a reaction to some event, you would probably code whatever you need close to what triggers the event.</span></span> <span data-ttu-id="70be3-114">Ainsi, la règle est implicitement, couplée au code, et vous pouvez espérer qu’il suffit de regarder dans le code pour se rendre compte que la règle y est implémentée.</span><span class="sxs-lookup"><span data-stu-id="70be3-114">So the rule gets coupled, implicitly, to the code, and you have to look into the code to, hopefully, realize the rule is implemented there.</span></span>

<span data-ttu-id="70be3-115">D’un autre côté, l’utilisation d’événements de domaine rend le concept explicite, car un `DomainEvent` et au moins un `DomainEventHandler` sont impliqués.</span><span class="sxs-lookup"><span data-stu-id="70be3-115">On the other hand, using domain events makes the concept explicit, because there is a `DomainEvent` and at least one `DomainEventHandler` involved.</span></span>

<span data-ttu-id="70be3-116">Par exemple, dans l’application eShopOnContainers, quand une commande est créée, l’utilisateur devient un acheteur : par conséquent, un `OrderStartedDomainEvent` est déclenché et géré dans le `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, de sorte que le concept sous-jacent est évident.</span><span class="sxs-lookup"><span data-stu-id="70be3-116">For example, in the eShopOnContainers application, when an order is created, the user becomes a buyer, so an `OrderStartedDomainEvent` is raised and handled in the `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, so the underlying concept is evident.</span></span>

<span data-ttu-id="70be3-117">En résumé, les événements de domaine vous aident à exprimer explicitement les règles du domaine dans le langage courant fourni par les experts du domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-117">In short, domain events help you to express, explicitly, the domain rules, based in the ubiquitous language provided by the domain experts.</span></span> <span data-ttu-id="70be3-118">Les événements de domaine permettent aussi une meilleure séparation des préoccupations entre les classes au sein du même domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-118">Domain events also enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="70be3-119">Il est important de vérifier que, tout comme pour une transaction de base de données, toutes les opérations liées à un événement de domaine se terminent correctement ou que ce n’est le cas pour aucune d’entre elles.</span><span class="sxs-lookup"><span data-stu-id="70be3-119">It's important to ensure that, just like a database transaction, either all the operations related to a domain event finish successfully or none of them do.</span></span>

<span data-ttu-id="70be3-120">Les événements de domaine sont similaires aux événements de type message, avec cependant une différence importante.</span><span class="sxs-lookup"><span data-stu-id="70be3-120">Domain events are similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="70be3-121">Avec les systèmes de messagerie réels, la mise en file d’attente des messages, les répartiteurs de messages et les bus de services utilisant le protocole AMPQ, les messages sont toujours envoyés de manière asynchrone sur plusieurs processus et ordinateurs.</span><span class="sxs-lookup"><span data-stu-id="70be3-121">With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="70be3-122">Cela est utile pour l’intégration de plusieurs contextes délimités ou de plusieurs microservices, voire d’applications différentes.</span><span class="sxs-lookup"><span data-stu-id="70be3-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="70be3-123">Toutefois, avec les événements de domaine, vous devez déclencher un événement à partir de l’opération de domaine actuellement exécutée, et les effets secondaires doivent se produire dans le même domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="70be3-124">Les événements de domaine et leurs effets secondaires (les actions déclenchées par la suite qui sont gérées par les gestionnaires d’événements) doivent se produire presque immédiatement, généralement in-process, et dans le même domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="70be3-125">Par conséquent, les événements de domaine peuvent être synchrones ou asynchrones.</span><span class="sxs-lookup"><span data-stu-id="70be3-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="70be3-126">Cependant, les événements d’intégration doivent toujours être asynchrones.</span><span class="sxs-lookup"><span data-stu-id="70be3-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="70be3-127">Comparaison des événements de domaine et des événements d’intégration</span><span class="sxs-lookup"><span data-stu-id="70be3-127">Domain events versus integration events</span></span>

<span data-ttu-id="70be3-128">D’un point de vue sémantique, les événements de domaine et d’intégration sont identiques : ce sont des notifications à propos de quelque chose qui vient de se produire.</span><span class="sxs-lookup"><span data-stu-id="70be3-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="70be3-129">Toutefois, leur implémentation doit être différente.</span><span class="sxs-lookup"><span data-stu-id="70be3-129">However, their implementation must be different.</span></span> <span data-ttu-id="70be3-130">Les événements de domaine ne sont que des messages envoyés vers un répartiteur d’événements de domaine, qui peut être implémenté comme un médiateur en mémoire basé sur un conteneur IoC ou toute autre méthode.</span><span class="sxs-lookup"><span data-stu-id="70be3-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="70be3-131">En revanche, le rôle des événements d’intégration est de propager les transactions et les mises à jour validées sur d’autres sous-systèmes, tels que des microservices, des contextes délimités ou des applications externes.</span><span class="sxs-lookup"><span data-stu-id="70be3-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="70be3-132">Ainsi, ils doivent se produire seulement si l’entité est rendue persistante ; sinon, c’est comme si l’opération toute entière ne s’était jamais produite.</span><span class="sxs-lookup"><span data-stu-id="70be3-132">Hence, they should occur only if the entity is successfully persisted, otherwise it's as if the entire operation never happened.</span></span>

<span data-ttu-id="70be3-133">Comme mentionné auparavant, les événements d’intégration doivent être basés sur une communication asynchrone entre plusieurs microservices (d’autres contextes délimités), ou même entre des systèmes/applications externes.</span><span class="sxs-lookup"><span data-stu-id="70be3-133">As mentioned before, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span>

<span data-ttu-id="70be3-134">Par conséquent, l’interface du bus d’événements a besoin d’une infrastructure permettant une communication entre processus et distribuée entre des services potentiellement distants.</span><span class="sxs-lookup"><span data-stu-id="70be3-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="70be3-135">Elle peut reposer sur un bus de services commercial, sur des files d’attente, sur une base de données partagée utilisée comme une boîte aux lettres, ou sur tout autre système de messagerie distribué et idéalement basé sur les opérations d’envoi (push).</span><span class="sxs-lookup"><span data-stu-id="70be3-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="70be3-136">Utilisation des événements de domaine comme méthode par défaut de déclenchement des effets secondaires sur plusieurs agrégats appartenant à un même domaine</span><span class="sxs-lookup"><span data-stu-id="70be3-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="70be3-137">Si l’exécution d’une commande liée à une instance d’agrégat nécessite que d’autres règles de domaine soient exécutées sur un ou plusieurs autres agrégats, vous devez concevoir et implémenter ces effets secondaires de manière à ce qu’ils soient déclenchés par les événements de domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="70be3-138">Comme le montre la figure 7-14, et c’est là un des principaux cas d’utilisation, un événement de domaine doit être utilisé pour propager les changements d’état sur plusieurs agrégats au sein du même modèle de domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-138">As shown in Figure 7-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![<span data-ttu-id="70be3-139">La cohérence entre les agrégats est obtenue via des événements de domaine : l’agrégat Order (Commande) envoie un événement de domaine OrderStarted qui est géré pour mettre à jour l’agrégat Buyer (Acheteur).</span><span class="sxs-lookup"><span data-stu-id="70be3-139">Consistency between aggregates is achieved by domain events, the Order Aggregate sends an OrderStarted domain event that's handled to update the Buyer Aggregate.</span></span> ](./media/image15.png)

<span data-ttu-id="70be3-140">**Figure 7-14**.</span><span class="sxs-lookup"><span data-stu-id="70be3-140">**Figure 7-14**.</span></span> <span data-ttu-id="70be3-141">Utilisation des événements de domaine pour obtenir la cohérence entre les différents agrégats d’un même domaine</span><span class="sxs-lookup"><span data-stu-id="70be3-141">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="70be3-142">Dans la figure ci-dessus, lorsque l’utilisateur démarre la création d’une commande, l’événement de domaine OrderStarted déclenche la création d’un objet Acheteur dans le microservice de commande, en se basant sur les informations de l’utilisateur d’origine provenant du microservice d’identité (avec les informations fournies dans la commande CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="70be3-142">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span> <span data-ttu-id="70be3-143">L’événement de domaine est généré par l’agrégat de commande lors de sa création.</span><span class="sxs-lookup"><span data-stu-id="70be3-143">The domain event is generated by the order aggregate when it is created in the first place.</span></span>

<span data-ttu-id="70be3-144">Vous pouvez également abonner l’agrégat racine aux événements déclenchés par les membres de ses agrégats (entités enfants).</span><span class="sxs-lookup"><span data-stu-id="70be3-144">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="70be3-145">Par exemple, chaque entité enfant d’OrderItem peut déclencher un événement lorsque le prix du produit est supérieur à un montant donné, ou lorsque le montant du produit est trop élevé.</span><span class="sxs-lookup"><span data-stu-id="70be3-145">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="70be3-146">L’agrégat racine peut ensuite recevoir ces événements et effectuer un calcul global ou un agrégat.</span><span class="sxs-lookup"><span data-stu-id="70be3-146">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="70be3-147">Il est important de comprendre que cette communication basée sur les événements n’est pas implémentée directement dans les agrégats. Vous devez implémenter des gestionnaires d’événements de domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-147">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span>

<span data-ttu-id="70be3-148">La gestion des événements de domaine est située au niveau de l’application.</span><span class="sxs-lookup"><span data-stu-id="70be3-148">Handling the domain events is an application concern.</span></span> <span data-ttu-id="70be3-149">La couche de modèle de domaine doit se concentrer uniquement sur la logique de domaine (que seuls des experts en domaines sont à même de comprendre), et non sur l’infrastructure de l’application (par exemple, les gestionnaires et les actions de persistance des effets secondaires utilisant des dépôts).</span><span class="sxs-lookup"><span data-stu-id="70be3-149">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="70be3-150">Par conséquent, c’est au niveau de la couche Application que les gestionnaires d’événements de domaine doivent déclencher des actions lorsqu’un événement de domaine est déclenché.</span><span class="sxs-lookup"><span data-stu-id="70be3-150">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="70be3-151">Les événements de domaine peuvent également servir à déclencher autant d’actions d’application que nécessaire, et plus important encore, ils doivent permettre l’augmentation future du nombre d’actions d’une manière découplée.</span><span class="sxs-lookup"><span data-stu-id="70be3-151">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="70be3-152">Par exemple, lorsque vous démarrez la création de la commande, vous pouvez publier un événement de domaine pour propager ces informations sur d’autres agrégats ou même pour déclencher des actions telles que des notifications.</span><span class="sxs-lookup"><span data-stu-id="70be3-152">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="70be3-153">Le point essentiel est le nombre ouvert d’actions à exécuter lorsqu’un événement de domaine se produit.</span><span class="sxs-lookup"><span data-stu-id="70be3-153">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="70be3-154">Avec le temps, le nombre d’actions et de règles dans le domaine et dans l’application va augmenter.</span><span class="sxs-lookup"><span data-stu-id="70be3-154">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="70be3-155">La complexité ou le nombre d’actions d’effet secondaire lors d’un événement vont augmenter avec le temps. Cependant, si votre code était fortement couplé (c’est-à-dire en créant des objets spécifiques avec `new`), chaque fois que vous avez besoin d’ajouter une nouvelle action, vous devez aussi changer le code en cours d’exécution et le code testé.</span><span class="sxs-lookup"><span data-stu-id="70be3-155">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, creating specific objects with `new`), then every time you needed to add a new action you would also need to change working and tested code.</span></span>

<span data-ttu-id="70be3-156">Cette modification peut entraîner de nouveaux bogues, et cette approche va également à l’encontre du [principe ouvert/fermé](https://en.wikipedia.org/wiki/Open/closed_principle) de [SOLID](https://en.wikipedia.org/wiki/SOLID).</span><span class="sxs-lookup"><span data-stu-id="70be3-156">This change could result in new bugs and this approach also goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID).</span></span> <span data-ttu-id="70be3-157">En outre, le volume de la classe d’origine orchestrant les opérations ne ferait qu’augmenter, ce qui irait à l’encontre du [principe de responsabilité unique](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="70be3-157">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="70be3-158">En revanche, si vous utilisez des événements de domaine, vous pouvez créer une implémentation affinée et découplée en séparant les responsabilités à l’aide de la méthode suivante :</span><span class="sxs-lookup"><span data-stu-id="70be3-158">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1. <span data-ttu-id="70be3-159">Envoyez une commande (par exemple, CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="70be3-159">Send a command (for example, CreateOrder).</span></span>
2. <span data-ttu-id="70be3-160">Recevez la commande dans un gestionnaire de commandes.</span><span class="sxs-lookup"><span data-stu-id="70be3-160">Receive the command in a command handler.</span></span>
   - <span data-ttu-id="70be3-161">Exécutez la transaction d’un seul agrégat.</span><span class="sxs-lookup"><span data-stu-id="70be3-161">Execute a single aggregate’s transaction.</span></span>
   - <span data-ttu-id="70be3-162">(Facultatif) Déclenchez des événements de domaine pour les effets secondaires (par exemple, OrderStartedDomainEvent).</span><span class="sxs-lookup"><span data-stu-id="70be3-162">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
3. <span data-ttu-id="70be3-163">Gérez les événements de domaine (dans le processus actuel) qui vont exécuter un nombre ouvert d’effets secondaires dans plusieurs agrégats ou actions d’application.</span><span class="sxs-lookup"><span data-stu-id="70be3-163">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="70be3-164">Exemple :</span><span class="sxs-lookup"><span data-stu-id="70be3-164">For example:</span></span>
   - <span data-ttu-id="70be3-165">Vérifiez ou créez l’acheteur et la méthode de paiement.</span><span class="sxs-lookup"><span data-stu-id="70be3-165">Verify or create buyer and payment method.</span></span>
   - <span data-ttu-id="70be3-166">Créez et envoyez un événement d’intégration associé au bus d’événements pour propager les états sur les microservices ou déclencher des actions externes, comme l’envoi d’un e-mail à l’acheteur.</span><span class="sxs-lookup"><span data-stu-id="70be3-166">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
   - <span data-ttu-id="70be3-167">Gérez les autres effets secondaires.</span><span class="sxs-lookup"><span data-stu-id="70be3-167">Handle other side effects.</span></span>

<span data-ttu-id="70be3-168">Comme le montre la figure 7-15, à partir du même événement de domaine, vous pouvez gérer plusieurs actions liées aux autres agrégats du domaine ou à d’autres actions d’application à exécuter sur les microservices qui se connectent aux événements d’intégration et au bus d’événements.</span><span class="sxs-lookup"><span data-stu-id="70be3-168">As shown in Figure 7-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![Il peut exister plusieurs gestionnaires pour le même événement de domaine dans la couche Application, un gestionnaire peut résoudre la cohérence entre les agrégats, et un autre gestionnaire peut publier un événement d’intégration, pour que d’autres microservices puissent en faire quelque chose.](./media/image16.png)

<span data-ttu-id="70be3-170">**Figure 7-15**.</span><span class="sxs-lookup"><span data-stu-id="70be3-170">**Figure 7-15**.</span></span> <span data-ttu-id="70be3-171">Gestion de plusieurs actions par domaine</span><span class="sxs-lookup"><span data-stu-id="70be3-171">Handling multiple actions per domain</span></span>

<span data-ttu-id="70be3-172">Les gestionnaires d’événements se trouvent en général dans la couche Application, car vous allez utiliser les objets d’infrastructure comme les dépôts ou une API d’application pour le comportement du microservice.</span><span class="sxs-lookup"><span data-stu-id="70be3-172">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="70be3-173">Dans ce sens, les gestionnaires d’événements sont similaires aux gestionnaires de commandes, car tous deux font partie de la couche Application.</span><span class="sxs-lookup"><span data-stu-id="70be3-173">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="70be3-174">La principale différence est qu’une commande ne doit être traitée qu’une seule fois.</span><span class="sxs-lookup"><span data-stu-id="70be3-174">The important difference is that a command should be processed only once.</span></span> <span data-ttu-id="70be3-175">Un événement de domaine peut être traité zéro ou *n* fois, car il peut être reçu par plusieurs récepteurs ou gestionnaires d’événements, chacun ayant un objectif différent.</span><span class="sxs-lookup"><span data-stu-id="70be3-175">A domain event could be processed zero or *n* times, because it can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="70be3-176">La possibilité d’avoir un nombre quelconque de gestionnaires pour chaque événement de domaine vous permet d’ajouter autant de règles de domaine que nécessaire, sans impacter votre code actuel.</span><span class="sxs-lookup"><span data-stu-id="70be3-176">Having an open number of handlers per domain event allows you to add as many domain rules without as needed, without affecting  current code.</span></span> <span data-ttu-id="70be3-177">Par exemple, pour implémenter la règle métier suivante, vous pouvez simplement ajouter quelques gestionnaires d’événements (voire un seul) :</span><span class="sxs-lookup"><span data-stu-id="70be3-177">For instance, implementing the following business rule might be as easy as adding a few event handlers (or even just one):</span></span>

> <span data-ttu-id="70be3-178">Lorsque le montant total dépensé par un client (quel que soit le nombre de commandes) dépasse 6 000 $, appliquer une remise de 10 % à chaque nouvelle commande et envoyer un e-mail au client pour l’informer de cette remise sur ses commandes futures.</span><span class="sxs-lookup"><span data-stu-id="70be3-178">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implement-domain-events"></a><span data-ttu-id="70be3-179">Implémenter des événements de domaine</span><span class="sxs-lookup"><span data-stu-id="70be3-179">Implement domain events</span></span>

<span data-ttu-id="70be3-180">En C#, un événement de domaine est une simple structure ou classe contenant des données, tel qu’un objet de transfert de données (DTO), avec toutes les informations relatives à ce qui vient de se passer dans le domaine, comme dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="70be3-180">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; }
    public int CardTypeId { get; }
    public string CardNumber { get; }
    public string CardSecurityNumber { get; }
    public string CardHolderName { get; }
    public DateTime CardExpiration { get; }
    public Order Order { get; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="70be3-181">Il s’agit essentiellement d’une classe qui contient toutes les données associées à l’événement OrderStarted.</span><span class="sxs-lookup"><span data-stu-id="70be3-181">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="70be3-182">En ce qui concerne le langage omniprésent du domaine, dans la mesure où un événement est quelque chose qui s’est produit dans le passé, le nom de classe de l’événement doit être représenté comme un verbe au passé, comme dans OrderStartedDomainEvent ou OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="70be3-182">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="70be3-183">C’est ainsi qu’est implémenté l’événement de domaine dans le microservice Ordering de l’application eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="70be3-183">That's how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="70be3-184">Comme mentionné précédemment, l’une des caractéristiques les plus importantes des événements est, puisqu’ils se sont produits dans le passé, ils ne doivent pas changer.</span><span class="sxs-lookup"><span data-stu-id="70be3-184">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="70be3-185">Par conséquent, il doit s’agir d’une classe immuable.</span><span class="sxs-lookup"><span data-stu-id="70be3-185">Therefore, it must be an immutable class.</span></span> <span data-ttu-id="70be3-186">Dans le code précédent, vous pouvez voir que les propriétés sont en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="70be3-186">You can see in the previous code that the properties are read-only.</span></span> <span data-ttu-id="70be3-187">Il n’existe aucun moyen de mettre à jour l’objet : vous pouvez seulement définir des valeurs quand vous le créez.</span><span class="sxs-lookup"><span data-stu-id="70be3-187">There's no way to update the object, you can only set values when you create it.</span></span>

<span data-ttu-id="70be3-188">Il est important de souligner ici que si les événements de domaine devaient être traités de façon asynchrone en utilisant une file d’attente qui a nécessité la sérialisation et la désérialisation des objets d’événement, les propriétés devraient être définies comme étant privées et non pas en lecture seule : le désérialiseur pourrait alors affecter les valeurs après extraction de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="70be3-188">It’s important to highlight here that if domain events were to be handled asynchronously, using a queue that required serializing and deserializing the event objects, the properties would have to be “private set” instead of read-only, so the deserializer would be able to assign the values upon dequeuing.</span></span> <span data-ttu-id="70be3-189">Ceci n’est pas un problème dans le microservice Ordering, car la publication/abonnement de l’événement de domaine est implémentée de façon synchrone avec MediatR.</span><span class="sxs-lookup"><span data-stu-id="70be3-189">This is not an issue in the Ordering microservice, as the domain event pub/sub is implemented synchronously using MediatR.</span></span>

### <a name="raise-domain-events"></a><span data-ttu-id="70be3-190">Déclencher des événements de domaine</span><span class="sxs-lookup"><span data-stu-id="70be3-190">Raise domain events</span></span>

<span data-ttu-id="70be3-191">L’étape suivante consiste à déclencher un événement de domaine pour qu’il atteigne ses gestionnaires d’événements associés.</span><span class="sxs-lookup"><span data-stu-id="70be3-191">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="70be3-192">Il existe pour cela plusieurs méthodes.</span><span class="sxs-lookup"><span data-stu-id="70be3-192">You can use multiple approaches.</span></span>

<span data-ttu-id="70be3-193">Udi Dahan proposait à l’origine (dans plusieurs billets de blog comme, par exemple, [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) d’utiliser une classe statique pour gérer et déclencher les événements.</span><span class="sxs-lookup"><span data-stu-id="70be3-193">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="70be3-194">Ceci peut inclure une classe statique nommée DomainEvents qui déclenche des événements de domaine immédiatement quand elle est appelée, en utilisant une syntaxe comme `DomainEvents.Raise(Event myEvent)`.</span><span class="sxs-lookup"><span data-stu-id="70be3-194">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like `DomainEvents.Raise(Event myEvent)`.</span></span> <span data-ttu-id="70be3-195">Jimmy Bogard a écrit un billet de blog ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) qui recommande une approche similaire.</span><span class="sxs-lookup"><span data-stu-id="70be3-195">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="70be3-196">Toutefois, lorsque la classe d’événements de domaine est statique, elle distribue aussi les événements aux gestionnaires immédiatement.</span><span class="sxs-lookup"><span data-stu-id="70be3-196">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="70be3-197">Les tests et le débogage deviennent alors plus difficiles, car les gestionnaires d’événements avec une logique d’effets secondaires sont exécutés immédiatement après le déclenchement de l’événement.</span><span class="sxs-lookup"><span data-stu-id="70be3-197">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="70be3-198">Lorsque vous effectuez des tests et des débogages, vous devez vous concentrer uniquement sur ce qui se passe actuellement dans les classes d’agrégats. Vous ne voulez pas être soudainement redirigé vers d’autres gestionnaires d’événements pour des effets secondaires liés à d’autres agrégats ou à une autre logique d’application.</span><span class="sxs-lookup"><span data-stu-id="70be3-198">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="70be3-199">C’est pour cela que les autres approches ont évolué, comme nous allons le voir dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="70be3-199">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-to-raise-and-dispatch-events"></a><span data-ttu-id="70be3-200">Approche différée pour déclencher et distribuer des événements</span><span class="sxs-lookup"><span data-stu-id="70be3-200">The deferred approach to raise and dispatch events</span></span>

<span data-ttu-id="70be3-201">Au lieu de distribuer immédiatement les événements vers un gestionnaire d’événements de domaine, il est préférable d’ajouter les événements de domaine à une collection, puis de distribuer les événements de domaine *juste avant* ou *juste* *après* avoir validé la transaction (comme avec SaveChanges dans Entity Framework).</span><span class="sxs-lookup"><span data-stu-id="70be3-201">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="70be3-202">Cette approche est expliquée par Jimmy Bogard dans le billet de blog [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).</span><span class="sxs-lookup"><span data-stu-id="70be3-202">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="70be3-203">Il est important de décider si les événements de domaine doivent être envoyés juste avant ou juste après avoir validé la transaction, car cela permet de déterminer si vous devez inclure les effets secondaires dans la même transaction ou dans des transactions différentes.</span><span class="sxs-lookup"><span data-stu-id="70be3-203">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="70be3-204">Dans ce dernier cas, vous devez appliquer la cohérence à terme sur plusieurs agrégats.</span><span class="sxs-lookup"><span data-stu-id="70be3-204">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="70be3-205">Ce sujet est abordé dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="70be3-205">This topic is discussed in the next section.</span></span>

<span data-ttu-id="70be3-206">L’approche différée est celle utilisée par l’aplication eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="70be3-206">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="70be3-207">Tout d’abord, vous devez ajouter les événements qui se produisent dans vos entités à une collection ou à une liste d’événements pour chaque entité.</span><span class="sxs-lookup"><span data-stu-id="70be3-207">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="70be3-208">Cette liste doit faire partie de l’objet entité, ou mieux encore, de votre classe d’entité de base, comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="70be3-208">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //... 
     private List<INotification> _domainEvents;
     public List<INotification> DomainEvents => _domainEvents; 

     public void AddDomainEvent(INotification eventItem)
     {
         _domainEvents = _domainEvents ?? new List<INotification>();
         _domainEvents.Add(eventItem);
     }

     public void RemoveDomainEvent(INotification eventItem)
     {
         _domainEvents?.Remove(eventItem);
     }
     //... Additional code
}
```

<span data-ttu-id="70be3-209">Lorsque vous souhaitez déclencher un événement,il vous suffit de l’ajouter à la collection d’événements à partir du code, au niveau de n’importe quelle méthode de l’entité d’agrégat racine.</span><span class="sxs-lookup"><span data-stu-id="70be3-209">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="70be3-210">Le code suivant, qui fait partie de la [Commande d’agrégat racine d’eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), montre un exemple :</span><span class="sxs-lookup"><span data-stu-id="70be3-210">The following code, part of the [Order aggregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="70be3-211">Notez que la seule chose qu’effectue la méthode AddDomainEvent est d’ajouter un événement à la liste.</span><span class="sxs-lookup"><span data-stu-id="70be3-211">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="70be3-212">Aucun événement n’est encore distribué, et aucun gestionnaire d’événements n’a encore été appelé.</span><span class="sxs-lookup"><span data-stu-id="70be3-212">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="70be3-213">Les événements doivent être distribués plus tard, lorsque vous validez la transaction dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="70be3-213">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="70be3-214">Si vous utilisez Entity Framework Core, ce sera dans la méthode SaveChanges de votre DbContext Entity Framework, comme dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="70be3-214">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.        
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be committed
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="70be3-215">Avec ce code, vous distribuez les événements des entités à leurs gestionnaires d’événements respectifs.</span><span class="sxs-lookup"><span data-stu-id="70be3-215">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="70be3-216">Le résultat global est que vous avez découplé le déclenchement d’un événement de domaine (un simple ajout à une liste en mémoire) de sa distribution à un gestionnaire d’événements.</span><span class="sxs-lookup"><span data-stu-id="70be3-216">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="70be3-217">En outre, selon le type de répartiteur que vous utilisez, vous pouvez distribuer les événements de façon synchrone ou asynchrone.</span><span class="sxs-lookup"><span data-stu-id="70be3-217">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="70be3-218">N’oubliez pas qu’ici, les limites transactionnelles jouent un rôle important.</span><span class="sxs-lookup"><span data-stu-id="70be3-218">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="70be3-219">Si votre unité de travail et votre transaction peuvent s’étendre sur plusieurs agrégats (comme lorsque vous utilisez EF Core et une base de données relationnelle), cela peut bien fonctionner.</span><span class="sxs-lookup"><span data-stu-id="70be3-219">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="70be3-220">Cependant, si la transaction ne peut pas s’étendre sur plusieurs agrégats, par exemple quand vous utilisez une base de données NoSQL comme Azure CosmosDB, vous devez implémenter des étapes supplémentaires pour obtenir la cohérence.</span><span class="sxs-lookup"><span data-stu-id="70be3-220">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure CosmosDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="70be3-221">C’est une des raisons pour lesquelles l’ignorance de la persistance n’est pas universelle. Elle dépend du système de stockage que vous utilisez.</span><span class="sxs-lookup"><span data-stu-id="70be3-221">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span> 

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="70be3-222">Méthode de la transaction unique sur plusieurs agrégats versus méthode de la cohérence à terme</span><span class="sxs-lookup"><span data-stu-id="70be3-222">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="70be3-223">Effectuer une même transaction sur plusieurs agrégats ou compter sur la cohérence à terme de ces agrégats ? Il s’agit là d’une question controversée.</span><span class="sxs-lookup"><span data-stu-id="70be3-223">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="70be3-224">De nombreux auteurs DDD comme Eric Evans et Vaughn Vernon préconisent la règle « une transaction = un agrégat », et prennent donc position pour la méthode de la cohérence à terme.</span><span class="sxs-lookup"><span data-stu-id="70be3-224">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="70be3-225">Par exemple, dans son livre *Domain-Driven Design*, Eric Evans dit ceci :</span><span class="sxs-lookup"><span data-stu-id="70be3-225">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

> <span data-ttu-id="70be3-226">Une règle qui s’étend sur plusieurs agrégats ne peut pas être constamment à jour.</span><span class="sxs-lookup"><span data-stu-id="70be3-226">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="70be3-227">Grâce au traitement des événements, au traitement par lots et autres mécanismes de mise à jour, les autres dépendances peuvent être résolues dans un temps donné.</span><span class="sxs-lookup"><span data-stu-id="70be3-227">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="70be3-228">(page 128)</span><span class="sxs-lookup"><span data-stu-id="70be3-228">(page 128)</span></span>

<span data-ttu-id="70be3-229">Vaughn Vernon dit ce qui suit dans [Effective Aggregate Design. Part II: Making Aggregates Work Together](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf) :</span><span class="sxs-lookup"><span data-stu-id="70be3-229">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

> <span data-ttu-id="70be3-230">Par conséquent, si l’exécution d’une commande sur une instance d’agrégat nécessite que d’autres règles métier soient exécutées sur un ou plusieurs agrégats, utilisez la cohérence à terme \[...\] Il existe un moyen pratique de prendre en charge la cohérence à terme dans un modèle DDD.</span><span class="sxs-lookup"><span data-stu-id="70be3-230">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="70be3-231">Une méthode d’agrégation publie un événement de domaine qui est remis à un ou plusieurs abonnés asynchrones.</span><span class="sxs-lookup"><span data-stu-id="70be3-231">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="70be3-232">Cette logique est basée sur l’exécution de transactions affinées plutôt que de transactions s’étendant sur un grand nombre d’agrégats ou d’entités.</span><span class="sxs-lookup"><span data-stu-id="70be3-232">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="70be3-233">L’idée est que, dans le deuxième cas, le nombre de verrous de base de données sera important dans les applications à grande échelle nécessitant une haute scalabilité.</span><span class="sxs-lookup"><span data-stu-id="70be3-233">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="70be3-234">Le fait de reconnaître que les applications à haute scalabilité n’ont pas besoin d’une cohérence transactionnelle instantanée entre les différents agrégats aide à accepter le concept de cohérence à terme.</span><span class="sxs-lookup"><span data-stu-id="70be3-234">Embracing the fact that highly scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="70be3-235">Les modifications atomiques ne sont généralement pas nécessaires à l’entreprise, et il revient aux experts en domaines de décider si certaines opérations ont besoin de transactions atomiques.</span><span class="sxs-lookup"><span data-stu-id="70be3-235">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="70be3-236">Si une opération nécessite toujours une transaction atomique entre plusieurs agrégats, vous pouvez vous demander si la taille de votre agrégat doit être augmentée ou si vous l’avez conçu correctement.</span><span class="sxs-lookup"><span data-stu-id="70be3-236">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="70be3-237">Toutefois, les autres développeurs et architectes comme Jimmy Bogard sont d’accord pour utiliser une même transaction sur plusieurs agrégats, mais uniquement si les agrégats supplémentaires sont associés à des effets secondaires de la même commande d’origine.</span><span class="sxs-lookup"><span data-stu-id="70be3-237">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="70be3-238">Par exemple, dans [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard dit ceci :</span><span class="sxs-lookup"><span data-stu-id="70be3-238">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

> <span data-ttu-id="70be3-239">En règle générale, je veux que les effets secondaires d’un événement de domaine se produisent dans la même transaction logique, mais pas nécessairement dans la même étendue de déclenchement de l’événement domaine \[...\] Juste avant de valider notre transaction, nous distribuons nos événements à leurs gestionnaires respectifs.</span><span class="sxs-lookup"><span data-stu-id="70be3-239">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="70be3-240">Si vous distribuez les événements de domaine juste *avant* de valider la transaction d’origine, c’est parce que les effets secondaires doivent être inclus dans la même transaction.</span><span class="sxs-lookup"><span data-stu-id="70be3-240">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="70be3-241">Par exemple, si la méthode SaveChanges du DbContext EF échoue, la transaction annule toutes les modifications, y compris le résultat de toutes les opérations d’effet secondaire implémentées par les gestionnaires d’événements de domaine associés.</span><span class="sxs-lookup"><span data-stu-id="70be3-241">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="70be3-242">Cela est dû au fait que la durée de vie de DbContext est configurée par défaut comme étant limitée.</span><span class="sxs-lookup"><span data-stu-id="70be3-242">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="70be3-243">Par conséquent, l’objet DbContext est partagé par plusieurs objets de dépôt qui sont instanciés dans la même étendue ou le même graphe d’objet.</span><span class="sxs-lookup"><span data-stu-id="70be3-243">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="70be3-244">Cela coïncide avec l’étendue HttpRequest lors du développement d’API web ou d’applications MVC.</span><span class="sxs-lookup"><span data-stu-id="70be3-244">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="70be3-245">En réalité, les deux approches (une seule transaction atomique et la cohérence à terme) peuvent être appropriées.</span><span class="sxs-lookup"><span data-stu-id="70be3-245">Actually, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="70be3-246">Cela dépend en réalité des exigences métier ou de votre domaine, et de ce que les experts en domaines vous disent.</span><span class="sxs-lookup"><span data-stu-id="70be3-246">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="70be3-247">Cela dépend également du niveau de scalabilité dont doit disposer le service (les transactions plus granulaires ont un impact moindre sur les verrous de base de données).</span><span class="sxs-lookup"><span data-stu-id="70be3-247">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="70be3-248">Enfin, cela dépend de l’investissement que vous êtes prêt à mettre dans votre code, puisque la cohérence à terme nécessite un code plus complexe afin de détecter les éventuelles incohérences entre les agrégats et la nécessité d’implémenter des actions compensatoires.</span><span class="sxs-lookup"><span data-stu-id="70be3-248">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="70be3-249">Prenez en compte le fait que si vous validez des modifications dans l’agrégat d’origine et que par la suite, quand les événements sont distribués, si un problème se produit et que les gestionnaires d’événements ne peuvent pas valider leurs effets secondaires, vous aurez des incohérences entre les agrégats.</span><span class="sxs-lookup"><span data-stu-id="70be3-249">Consider that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, if there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="70be3-250">Pour permettre les actions compensatoires, vous pouvez stocker les événements de domaine dans des tables de base de données supplémentaires, pour qu’elles fassent partie de la transaction d’origine.</span><span class="sxs-lookup"><span data-stu-id="70be3-250">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="70be3-251">Ensuite, vous pouvez avoir un traitement par lots qui détecte des incohérences et exécute des actions compensatoires en comparant la liste des événements à l’état actuel des agrégats.</span><span class="sxs-lookup"><span data-stu-id="70be3-251">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="70be3-252">Les actions compensatoires sont un sujet complexe qui nécessite une analyse approfondie, impliquant à la fois les utilisateurs et les experts en domaines.</span><span class="sxs-lookup"><span data-stu-id="70be3-252">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="70be3-253">Quoi qu’il en soit, vous pouvez choisir l’approche dont vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="70be3-253">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="70be3-254">Toutefois, l’approche différée du début (qui déclenche les événements avant de les valider, permettant ainsi d’utiliser une seule transaction) est la plus simple lorsque vous utilisez EF Core et une base de données relationnelle.</span><span class="sxs-lookup"><span data-stu-id="70be3-254">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="70be3-255">Elle est plus facile à implémenter et convient dans de nombreux cas en entreprise.</span><span class="sxs-lookup"><span data-stu-id="70be3-255">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="70be3-256">Il s’agit également de l’approche utilisée dans le microservice de commande de l’application eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="70be3-256">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="70be3-257">Mais comment faire pour distribuer ces événements à leurs gestionnaires d’événements respectifs ?</span><span class="sxs-lookup"><span data-stu-id="70be3-257">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="70be3-258">Qu’est-ce que l’objet `_mediator` que vous voyez dans l’exemple précédent ?</span><span class="sxs-lookup"><span data-stu-id="70be3-258">What's the `_mediator` object you see in the previous example?</span></span> <span data-ttu-id="70be3-259">Il est lié aux techniques et aux artefacts que vous utilisez pour le mappage des événements aux gestionnaires d’événements.</span><span class="sxs-lookup"><span data-stu-id="70be3-259">It has to do with the techniques and artifacts you use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="70be3-260">Répartiteur d’événements de domaine : mappage des événements aux gestionnaires d’événements</span><span class="sxs-lookup"><span data-stu-id="70be3-260">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="70be3-261">Une fois que vous êtes en mesure de distribuer ou publier les événements, vous avez besoin d’un artefact pour ces événements, et faire en sorte que le gestionnaire associé puisse les recevoir et traiter les effets secondaires en fonction des événements.</span><span class="sxs-lookup"><span data-stu-id="70be3-261">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="70be3-262">L’une des méthodes possibles consiste à utiliser un système de messagerie réel, voire un bus d’événements, éventuellement basé sur un bus de services au lieu d’événements en mémoire.</span><span class="sxs-lookup"><span data-stu-id="70be3-262">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="70be3-263">Toutefois, pour le premier cas, un système de messagerie réel serait excessif pour traiter les événements de domaine, puisque vous avez seulement besoin de traiter ces événements au sein d’un même processus (c’est-à-dire, dans le même domaine et la même couche Application).</span><span class="sxs-lookup"><span data-stu-id="70be3-263">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="70be3-264">Une autre façon de mapper des événements à plusieurs gestionnaires d’événements est d’utiliser l’inscription des types dans un conteneur IoC, pour déduire dynamiquement où distribuer les événements.</span><span class="sxs-lookup"><span data-stu-id="70be3-264">Another way to map events to multiple event handlers is by using types registration in an IoC container so you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="70be3-265">En d’autres termes, vous devez savoir ce dont les gestionnaires d’événements ont besoin pour recevoir un événement spécifique.</span><span class="sxs-lookup"><span data-stu-id="70be3-265">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="70be3-266">La figure 7-16 montre une approche simplifiée de ceci.</span><span class="sxs-lookup"><span data-stu-id="70be3-266">Figure 7-16 shows a simplified approach for this approach.</span></span>

![L’injection de dépendances peut être utilisée pour associer des événements à des gestionnaires d’événements : c’est l’approche utilisée par MediatR](./media/image17.png)

<span data-ttu-id="70be3-268">**Figure 7-16**.</span><span class="sxs-lookup"><span data-stu-id="70be3-268">**Figure 7-16**.</span></span> <span data-ttu-id="70be3-269">Répartiteur d’événements de domaine utilisant l’IoC</span><span class="sxs-lookup"><span data-stu-id="70be3-269">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="70be3-270">Vous pouvez créer vous-même tous les éléments et artefacts pour implémenter cette approche.</span><span class="sxs-lookup"><span data-stu-id="70be3-270">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="70be3-271">Cependant, vous pouvez aussi utiliser des bibliothèques comme [MediatR](https://github.com/jbogard/MediatR), qui utilisent votre conteneur IoC en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="70be3-271">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR) that uses your IoC container under the covers.</span></span> <span data-ttu-id="70be3-272">Vous pouvez donc directement utiliser les interfaces prédéfinies, ainsi que les méthodes de publication/distribution de l’objet _mediator.</span><span class="sxs-lookup"><span data-stu-id="70be3-272">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="70be3-273">Dans le code, vous devez d’abord inscrire les types de gestionnaires d’événements dans votre conteneur IoC, comme le montre l’exemple suivant du [microservice de commande eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs) :</span><span class="sxs-lookup"><span data-stu-id="70be3-273">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="70be3-274">Le code identifie tout d’abord l’assembly qui contient les gestionnaires d’événements de domaine en recherchant l’assembly qui contient l’un des gestionnaires (en utilisant typeof(ValidateOrAddBuyerAggregateWhenXxxx). Toutefois, vous auriez pu choisir n’importe quel autre gestionnaire d’événements pour rechercher l’assembly.</span><span class="sxs-lookup"><span data-stu-id="70be3-274">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="70be3-275">Étant donné que tous les gestionnaires d’événements implémentent l’interface IAsyncNotificationHandler, le code recherche donc uniquement ces types et inscrit tous les gestionnaires d’événements.</span><span class="sxs-lookup"><span data-stu-id="70be3-275">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="70be3-276">Comment s’abonner aux événements de domaine</span><span class="sxs-lookup"><span data-stu-id="70be3-276">How to subscribe to domain events</span></span>

<span data-ttu-id="70be3-277">Lorsque vous utilisez MediatR, chaque gestionnaire d’événements doit utiliser un type d’événement fourni par le paramètre générique de l’interface INotificationHandler, comme vous pouvez le voir dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="70be3-277">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="70be3-278">En fonction de la relation qui existe entre l’événement et le gestionnaire d’événements, que l’on peut voir comme l’abonnement, l’artefact MediatR peut découvrir tous les gestionnaires d’événements pour chaque événement, et déclencher chacun de ces gestionnaires.</span><span class="sxs-lookup"><span data-stu-id="70be3-278">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each one of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="70be3-279">Comment gérer les événements de domaine</span><span class="sxs-lookup"><span data-stu-id="70be3-279">How to handle domain events</span></span>

<span data-ttu-id="70be3-280">Enfin, le gestionnaire d’événements implémente généralement le code de la couche Application qui utilise les dépôts de l’infrastructure pour obtenir les agrégats supplémentaires nécessaires et pour exécuter la logique de domaine d’effet secondaire.</span><span class="sxs-lookup"><span data-stu-id="70be3-280">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="70be3-281">Le [code de gestionnaire d’événements de domaine de l’application eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs) suivant montre un exemple d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="70be3-281">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;        
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) 
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="70be3-282">Le code du gestionnaire d’événements de domaine précédent est considéré comme du code de couche Application, car il utilise des dépôts d’infrastructure, comme expliqué dans la section suivante concernant la couche Persistance d’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="70be3-282">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="70be3-283">Les gestionnaires d’événements peuvent également utiliser d’autres composants d’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="70be3-283">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="70be3-284">Les événements de domaine peuvent générer des événements d’intégration devant être publiés en dehors des limites du microservice.</span><span class="sxs-lookup"><span data-stu-id="70be3-284">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="70be3-285">Enfin, il est important de mentionner qu’il est parfois utile de propager des événements sur plusieurs microservices.</span><span class="sxs-lookup"><span data-stu-id="70be3-285">Finally, it's important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="70be3-286">Cette propagation est un événement d’intégration, qui peut être publié via un bus d’événements à partir de n’importe quel gestionnaire d’événements de domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-286">That propagation is an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="70be3-287">Conclusions sur les événements de domaine</span><span class="sxs-lookup"><span data-stu-id="70be3-287">Conclusions on domain events</span></span>

<span data-ttu-id="70be3-288">Comme nous l’avons vu, les événements de domaine permettent d’implémenter explicitement les effets secondaires des modifications apportées à votre domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-288">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="70be3-289">Pour utiliser la terminologie DDD, les événements de domaine permettent d’implémenter explicitement des effets secondaires sur un ou plusieurs agrégats.</span><span class="sxs-lookup"><span data-stu-id="70be3-289">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="70be3-290">Si vous le souhaitez, pour une meilleure scalabilité et un impact moindre sur les verrous de base de données, utilisez la cohérence à terme entre les agrégats d’un même domaine.</span><span class="sxs-lookup"><span data-stu-id="70be3-290">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="70be3-291">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="70be3-291">Additional resources</span></span>

- <span data-ttu-id="70be3-292">**Greg Young. What is a Domain Event?**</span><span class="sxs-lookup"><span data-stu-id="70be3-292">**Greg Young. What is a Domain Event?**</span></span> \
  [*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)

- <span data-ttu-id="70be3-293">**Jan Stenberg. Domain Events and Eventual Consistency** \\</span><span class="sxs-lookup"><span data-stu-id="70be3-293">**Jan Stenberg. Domain Events and Eventual Consistency** \\</span></span>
  [*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)

- <span data-ttu-id="70be3-294">**Jimmy Bogard. A better domain events pattern** \\</span><span class="sxs-lookup"><span data-stu-id="70be3-294">**Jimmy Bogard. A better domain events pattern** \\</span></span>
  [*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)

- <span data-ttu-id="70be3-295">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together** \\</span><span class="sxs-lookup"><span data-stu-id="70be3-295">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together** \\</span></span>
  [*https://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)

- <span data-ttu-id="70be3-296">**Jimmy Bogard. Strengthening your domain: Domain Events** \\</span><span class="sxs-lookup"><span data-stu-id="70be3-296">**Jimmy Bogard. Strengthening your domain: Domain Events** \\</span></span>
  [*https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/*](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)

- <span data-ttu-id="70be3-297">**Tony Truong. Domain Events Pattern Example** \\</span><span class="sxs-lookup"><span data-stu-id="70be3-297">**Tony Truong. Domain Events Pattern Example** \\</span></span>
  [*https://www.tonytruong.net/domain-events-pattern-example/*](https://www.tonytruong.net/domain-events-pattern-example/)

- <span data-ttu-id="70be3-298">**Udi Dahan. How to create fully encapsulated Domain Models** \\</span><span class="sxs-lookup"><span data-stu-id="70be3-298">**Udi Dahan. How to create fully encapsulated Domain Models** \\</span></span>
  [*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)

- <span data-ttu-id="70be3-299">**Udi Dahan. Domain Events – Take 2** \\</span><span class="sxs-lookup"><span data-stu-id="70be3-299">**Udi Dahan. Domain Events – Take 2** \\</span></span>
  [*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)

- <span data-ttu-id="70be3-300">**Udi Dahan. Domain Events – Salvation** \\</span><span class="sxs-lookup"><span data-stu-id="70be3-300">**Udi Dahan. Domain Events – Salvation** \\</span></span>
  [*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)

- <span data-ttu-id="70be3-301">**Jan Kronquist. Don’t publish Domain Events, return them!**</span><span class="sxs-lookup"><span data-stu-id="70be3-301">**Jan Kronquist. Don't publish Domain Events, return them!**</span></span> \
  [*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)

- <span data-ttu-id="70be3-302">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures** \\</span><span class="sxs-lookup"><span data-stu-id="70be3-302">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures** \\</span></span>
  [*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)

>[!div class="step-by-step"]
><span data-ttu-id="70be3-303">[Précédent](client-side-validation.md)
>[Suivant](infrastructure-persistence-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="70be3-303">[Previous](client-side-validation.md)
[Next](infrastructure-persistence-layer-design.md)</span></span>