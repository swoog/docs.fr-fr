---
title: Formats de chemin de fichier sur les systèmes Windows
ms.date: 06/28/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, long paths
- long paths
- path formats, Windows
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: ecaae9e1af359ead1c15a9e431eac21e41040efe
ms.sourcegitcommit: bd28ff1e312eaba9718c4f7ea272c2d4781a7cac
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/26/2019
ms.locfileid: "56835822"
---
# <a name="file-path-formats-on-windows-systems"></a><span data-ttu-id="64f13-102">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="64f13-102">File path formats on Windows systems</span></span>

<span data-ttu-id="64f13-103">Dans l’espace de noms <xref:System.IO>, les membres de nombreux types incluent un paramètre `path` qui vous permet de spécifier un chemin absolu ou relatif à une ressource de système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="64f13-103">Members of many of the types in the <xref:System.IO> namespace include a `path` parameter that lets you specify an absolute or relative path to a file system resource.</span></span> <span data-ttu-id="64f13-104">Ce chemin est ensuite passé aux [API de système de fichiers Windows](/windows/desktop/fileio/file-systems).</span><span class="sxs-lookup"><span data-stu-id="64f13-104">This path is then passed to [Windows file system APIs](/windows/desktop/fileio/file-systems).</span></span> <span data-ttu-id="64f13-105">Cette rubrique décrit les formats de chemins de fichier que vous pouvez utiliser dans les systèmes Windows.</span><span class="sxs-lookup"><span data-stu-id="64f13-105">This topic discusses the formats for file paths that you can use on Windows systems.</span></span>

## <a name="traditional-dos-paths"></a><span data-ttu-id="64f13-106">Chemins DOS traditionnels</span><span class="sxs-lookup"><span data-stu-id="64f13-106">Traditional DOS paths</span></span>

<span data-ttu-id="64f13-107">Un chemin DOS standard peut être constitué de trois composants :</span><span class="sxs-lookup"><span data-stu-id="64f13-107">A standard DOS path can consist of three components:</span></span>

- <span data-ttu-id="64f13-108">Une lettre de volume ou de lecteur suivie du séparateur de volumes (`:`).</span><span class="sxs-lookup"><span data-stu-id="64f13-108">A volume or drive letter followed by the volume separator (`:`).</span></span>
- <span data-ttu-id="64f13-109">Un nom de répertoire.</span><span class="sxs-lookup"><span data-stu-id="64f13-109">A directory name.</span></span> <span data-ttu-id="64f13-110">Le [caractère de séparation de répertoires](<xref:System.IO.Path.DirectorySeparatorChar>) sépare les sous-répertoires au sein de la hiérarchie de répertoires imbriqués.</span><span class="sxs-lookup"><span data-stu-id="64f13-110">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="64f13-111">Un nom de fichier facultatif.</span><span class="sxs-lookup"><span data-stu-id="64f13-111">An optional filename.</span></span> <span data-ttu-id="64f13-112">Le [caractère de séparation de répertoires](<xref:System.IO.Path.DirectorySeparatorChar>) sépare le chemin de fichier et le nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="64f13-112">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="64f13-113">Si les trois composants sont présents, le chemin est absolu.</span><span class="sxs-lookup"><span data-stu-id="64f13-113">If all three components are present, the path is absolute.</span></span> <span data-ttu-id="64f13-114">Si aucune lettre de lecteur ou de volume n’est spécifiée et que le [caractère de séparation de répertoires](<xref:System.IO.Path.DirectorySeparatorChar>) précède les noms de répertoires, le chemin est relatif à la racine du lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="64f13-114">If no volume or drive letter is specified and the directory names begins with the [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>), the path is relative from the root of the current drive.</span></span> <span data-ttu-id="64f13-115">Sinon, le chemin est relatif au répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="64f13-115">Otherwise, the path is relative to the current directory.</span></span> <span data-ttu-id="64f13-116">Le tableau suivant présente certains chemins de répertoire et de fichier.</span><span class="sxs-lookup"><span data-stu-id="64f13-116">The following table shows some possible directory and file paths.</span></span>

|<span data-ttu-id="64f13-117">Chemin d’accès</span><span class="sxs-lookup"><span data-stu-id="64f13-117">Path</span></span>  |<span data-ttu-id="64f13-118">Description</span><span class="sxs-lookup"><span data-stu-id="64f13-118">Description</span></span>  |
| -- | -- |
| `C:\Documents\Newsletters\Summer2018.pdf` | <span data-ttu-id="64f13-119">Chemin de fichier absolu à partir de la racine du lecteur C:.</span><span class="sxs-lookup"><span data-stu-id="64f13-119">An absolute file path from the root of drive C:</span></span> |
| `\Program Files\Custom Utilities\StringFinder.exe` | <span data-ttu-id="64f13-120">Chemin absolu à partir de la racine du lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="64f13-120">An absolute path from the root of the current drive.</span></span> |
| `2018\January.xlsx` | <span data-ttu-id="64f13-121">Chemin relatif à un fichier dans un sous-répertoire du répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="64f13-121">A relative path to a file in a subdirectory of the current directory.</span></span> |
| `..\Publications\TravelBrochure.pdf` | <span data-ttu-id="64f13-122">Chemin relatif à un fichier dans un répertoire qui est un pair du répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="64f13-122">A relative path to file in a directory that is a peer of the current directory.</span></span> |
| `C:\Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="64f13-123">Chemin absolu à un fichier à partir de la racine du lecteur C:.</span><span class="sxs-lookup"><span data-stu-id="64f13-123">An absolute path to a file from the root of drive C:</span></span> |
| `C:Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="64f13-124">Chemin relatif à partir du répertoire actif du lecteur C:.</span><span class="sxs-lookup"><span data-stu-id="64f13-124">A relative path from the current directory of the C: drive.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="64f13-125">Notez la différence entre les deux derniers chemins.</span><span class="sxs-lookup"><span data-stu-id="64f13-125">Note the difference between the last two paths.</span></span> <span data-ttu-id="64f13-126">Les deux chemins spécifient le spécificateur de volume facultatif (C: dans les deux cas), mais le premier commence par la racine du volume spécifié, contrairement au second.</span><span class="sxs-lookup"><span data-stu-id="64f13-126">Both specify the optional volume specifier (C: in both cases), but the first begins with the root of the specified volume, whereas the second does not.</span></span> <span data-ttu-id="64f13-127">Le premier chemin est donc un chemin absolu à partir du répertoire racine du lecteur C:, tandis que le second est un chemin relatif à partir du répertoire actif du lecteur C:.</span><span class="sxs-lookup"><span data-stu-id="64f13-127">As result, the first is an absolute path from the root directory of drive C:, whereas the second is a relative path from the current directory of drive C:.</span></span> <span data-ttu-id="64f13-128">L’utilisation involontaire de la deuxième forme à la place de la première est une source courante de bogues impliquant des chemins de fichier Windows.</span><span class="sxs-lookup"><span data-stu-id="64f13-128">Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</span></span>

<span data-ttu-id="64f13-129">Pour déterminer si un chemin de fichier est complet (autrement dit, si le chemin est indépendant du répertoire actif et qu’il reste inchangé quand le répertoire actif change), appelez la méthode <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType>.</span><span class="sxs-lookup"><span data-stu-id="64f13-129">You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> method.</span></span> <span data-ttu-id="64f13-130">Notez qu’un tel chemin peut inclure des segments de répertoire relatifs (`.` et `..`) et toujours être complet si le chemin résolu pointe toujours vers le même emplacement.</span><span class="sxs-lookup"><span data-stu-id="64f13-130">Note that such a path can include relative directory segments (`.` and `..`) and still be fully qualified if the resolved path always points to the same location.</span></span>

<span data-ttu-id="64f13-131">L’exemple suivant illustre la différence entre les chemins absolus et relatifs.</span><span class="sxs-lookup"><span data-stu-id="64f13-131">The following example illustrates the difference between absolute and relative paths.</span></span> <span data-ttu-id="64f13-132">Il suppose que le répertoire D:\FY2018\ existe et que vous n’avez défini aucun répertoire actif pour D:\ à l’invite de commandes avant d’exécuter l’exemple.</span><span class="sxs-lookup"><span data-stu-id="64f13-132">It assumes that the directory D:\FY2018\ exists, and that you haven't set any curent directory for D:\ from the command prompt before running the example.</span></span>

[!code-csharp[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/cs/paths.cs)]
[!code-vb[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/vb/paths.vb)]

## <a name="unc-paths"></a><span data-ttu-id="64f13-133">Chemins UNC</span><span class="sxs-lookup"><span data-stu-id="64f13-133">UNC paths</span></span>

<span data-ttu-id="64f13-134">Les chemins respectant la convention d’affectation de noms (UNC), qui sont utilisés pour accéder aux ressources réseau, ont le format suivant :</span><span class="sxs-lookup"><span data-stu-id="64f13-134">Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</span></span>

- <span data-ttu-id="64f13-135">Un nom de serveur ou d’hôte, précédé de \\\\.</span><span class="sxs-lookup"><span data-stu-id="64f13-135">A server or host name, which is prefaced by \\\\.</span></span> <span data-ttu-id="64f13-136">Le nom du serveur peut être un nom d’ordinateur NetBIOS ou une adresse IP/FQDN (IPv4 et IPv6 sont pris en charge).</span><span class="sxs-lookup"><span data-stu-id="64f13-136">The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</span></span>
- <span data-ttu-id="64f13-137">Un nom de partage, séparé du nom d’hôte par \\.</span><span class="sxs-lookup"><span data-stu-id="64f13-137">A share name, which is separated from the host name by \\.</span></span> <span data-ttu-id="64f13-138">Ensemble, le serveur et le partage forment le volume.</span><span class="sxs-lookup"><span data-stu-id="64f13-138">Together, the server and share name make up the volume.</span></span>
- <span data-ttu-id="64f13-139">Un nom de répertoire.</span><span class="sxs-lookup"><span data-stu-id="64f13-139">A directory name.</span></span> <span data-ttu-id="64f13-140">Le [caractère de séparation de répertoires](<xref:System.IO.Path.DirectorySeparatorChar>) sépare les sous-répertoires au sein de la hiérarchie de répertoires imbriqués.</span><span class="sxs-lookup"><span data-stu-id="64f13-140">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="64f13-141">Un nom de fichier facultatif.</span><span class="sxs-lookup"><span data-stu-id="64f13-141">An optional filename.</span></span> <span data-ttu-id="64f13-142">Le [caractère de séparation de répertoires](<xref:System.IO.Path.DirectorySeparatorChar>) sépare le chemin et le nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="64f13-142">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="64f13-143">Voici quelques exemples de chemins UNC :</span><span class="sxs-lookup"><span data-stu-id="64f13-143">The following are some examples of UNC paths:</span></span>

|<span data-ttu-id="64f13-144">Chemin d’accès</span><span class="sxs-lookup"><span data-stu-id="64f13-144">Path</span></span>  |<span data-ttu-id="64f13-145">Description</span><span class="sxs-lookup"><span data-stu-id="64f13-145">Description</span></span>  |
| -- | -- |
| `\\system07\C$\` | <span data-ttu-id="64f13-146">Répertoire racine du lecteur C: sur `system07`.</span><span class="sxs-lookup"><span data-stu-id="64f13-146">The root directory of the C: drive on `system07`.</span></span> |
| `\\Server2\Share\Test\Foo.txt` | <span data-ttu-id="64f13-147">Fichier Foo.txt dans le répertoire Test du volume \\\\Server2\\Share.</span><span class="sxs-lookup"><span data-stu-id="64f13-147">The Foo.txt file in the Test directory of the \\\\Server2\\Share volume.</span></span>|

<span data-ttu-id="64f13-148">Les chemins UNC doivent toujours être complets.</span><span class="sxs-lookup"><span data-stu-id="64f13-148">UNC paths must always be fully qualified.</span></span> <span data-ttu-id="64f13-149">Ils peuvent inclure des segments de répertoire relatifs (`.` et `..`), mais ils doivent faire partie d’un chemin complet.</span><span class="sxs-lookup"><span data-stu-id="64f13-149">They can include relative directory segments (`.` and `..`), but these must be part of a fully qualified path.</span></span> <span data-ttu-id="64f13-150">Pour utiliser des chemins relatifs, vous devez impérativement mapper un chemin UNC à une lettre de lecteur.</span><span class="sxs-lookup"><span data-stu-id="64f13-150">You can use relative paths only by mapping a UNC path to a drive letter.</span></span>

## <a name="dos-device-paths"></a><span data-ttu-id="64f13-151">Chemins de périphérique DOS</span><span class="sxs-lookup"><span data-stu-id="64f13-151">DOS device paths</span></span>

<span data-ttu-id="64f13-152">Le système d’exploitation Windows a un modèle objet unifié qui pointe vers toutes les ressources, notamment les fichiers.</span><span class="sxs-lookup"><span data-stu-id="64f13-152">The Windows operating system has a unified object model that points to all resources, including files.</span></span> <span data-ttu-id="64f13-153">Ces chemins d’objet sont accessibles à partir de la fenêtre de console et sont exposés à la couche Win32 par le biais d’un dossier spécial de liens symboliques mappés aux chemins DOS et UNC hérités.</span><span class="sxs-lookup"><span data-stu-id="64f13-153">These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</span></span> <span data-ttu-id="64f13-154">Ce dossier spécial est accessible par le biais d’un chemin de périphérique DOS, dont la syntaxe est l’une des suivantes :</span><span class="sxs-lookup"><span data-stu-id="64f13-154">This special folder is accessed via the DOS device path syntax, which is one of:</span></span>

`\\.\C:\Test\Foo.txt`  
`\\?\C:\Test\Foo.txt`

> [!NOTE]
> <span data-ttu-id="64f13-155">La syntaxe des chemins de périphérique DOS est prise en charge sur les implémentations .NET s’exécutant sur Windows à compter de .NET Core 1.1 et .NET Framework 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="64f13-155">DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</span></span>

<span data-ttu-id="64f13-156">Le chemin de périphérique DOS comprend les composants suivants :</span><span class="sxs-lookup"><span data-stu-id="64f13-156">The DOS device path consists of the following components:</span></span>

- <span data-ttu-id="64f13-157">Le spécificateur de chemin de périphérique (`\\.\` ou `\\?\`), qui identifie le chemin comme chemin de périphérique DOS.</span><span class="sxs-lookup"><span data-stu-id="64f13-157">The device path specifier (`\\.\` or `\\?\`), which identifies the path as a DOS device path.</span></span>

   > [!NOTE]
   > <span data-ttu-id="64f13-158">Le spécificateur `\\?\` est pris en charge dans toutes les versions de .NET Core et dans le .NET Framework à compter de la version 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="64f13-158">The `\\?\` is supported in all versions of .NET Core and in the .NET Framework starting with version 4.6.2.</span></span>
   
- <span data-ttu-id="64f13-159">Un lien symbolique vers l’objet de périphérique « réel » (C: dans le cas présent).</span><span class="sxs-lookup"><span data-stu-id="64f13-159">A symbolic link to the "real" device object (C: in this case).</span></span>

   <span data-ttu-id="64f13-160">Le premier segment du chemin de périphérique DOS après le spécificateur de chemin de périphérique identifie le volume ou le lecteur.</span><span class="sxs-lookup"><span data-stu-id="64f13-160">The first segment of the DOS device path after the device path specifier identifies the volume or drive.</span></span> <span data-ttu-id="64f13-161">(Par exemple, `\\?\C:\` et `\\.\BootPartition\`.)</span><span class="sxs-lookup"><span data-stu-id="64f13-161">(For example, `\\?\C:\` and `\\.\BootPartition\`.)</span></span>

   <span data-ttu-id="64f13-162">Il existe un lien spécifique pour les chemins UNC. Celui-ci s’appelle, sans surprise, `UNC`.</span><span class="sxs-lookup"><span data-stu-id="64f13-162">There is a specific link for UNCs that is called, not surprisingly, `UNC`.</span></span> <span data-ttu-id="64f13-163">Exemple :</span><span class="sxs-lookup"><span data-stu-id="64f13-163">For example:</span></span>

  `\\.\UNC\Server\Share\Test\Foo.txt`  
  `\\?\UNC\Server\Share\Test\Foo.txt`

    <span data-ttu-id="64f13-164">Pour les chemins UNC de périphérique, la partie serveur/partage forme le volume.</span><span class="sxs-lookup"><span data-stu-id="64f13-164">For device UNCs, the server/share portion is forms the volume.</span></span> <span data-ttu-id="64f13-165">Par exemple, dans `\\?\server1\e:\utilities\\filecomparer\`, la partie serveur/partage est server1\utilities.</span><span class="sxs-lookup"><span data-stu-id="64f13-165">For example, in `\\?\server1\e:\utilities\\filecomparer\`, the server/share portion is server1\utilities.</span></span> <span data-ttu-id="64f13-166">Ceci est important quand vous appelez une méthode comme <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> avec des segments de répertoire relatifs ; il est impossible de naviguer au-delà du volume.</span><span class="sxs-lookup"><span data-stu-id="64f13-166">This is significant when calling a method such as <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> with relative directory segments; it is never possible to navigate past the volume.</span></span> 

<span data-ttu-id="64f13-167">Par définition, les chemins de périphérique DOS sont complets.</span><span class="sxs-lookup"><span data-stu-id="64f13-167">DOS device paths are fully qualified by definition.</span></span> <span data-ttu-id="64f13-168">Les segments de répertoire relatifs (`.` et `..`) ne sont pas autorisés.</span><span class="sxs-lookup"><span data-stu-id="64f13-168">Relative directory segments (`.` and `..`) are not allowed.</span></span> <span data-ttu-id="64f13-169">Les répertoires actifs ne font jamais partie de ce type de chemin.</span><span class="sxs-lookup"><span data-stu-id="64f13-169">Current directories never enter into their usage.</span></span>

## <a name="example-ways-to-refer-to-the-same-file"></a><span data-ttu-id="64f13-170">Exemple : Comment faire référence au même fichier</span><span class="sxs-lookup"><span data-stu-id="64f13-170">Example: Ways to refer to the same file</span></span>

<span data-ttu-id="64f13-171">L’exemple suivant illustre quelques-unes des méthodes vous permettant de faire référence à un fichier à l’aide des API dans l’espace de noms <xref:System.IO>.</span><span class="sxs-lookup"><span data-stu-id="64f13-171">The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <xref:System.IO> namespace.</span></span> <span data-ttu-id="64f13-172">L’exemple instancie un objet <xref:System.IO.FileInfo> et utilise ses propriétés <xref:System.IO.FileInfo.Name> et <xref:System.IO.FileInfo.Length> pour afficher le nom et la longueur du fichier.</span><span class="sxs-lookup"><span data-stu-id="64f13-172">The example instantiates a <xref:System.IO.FileInfo> object and uses its <xref:System.IO.FileInfo.Name> and <xref:System.IO.FileInfo.Length> properties to display the filename and the length of the file.</span></span>

[!code-csharp[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/cs/file-refs.cs)]
[!code-vb[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/vb/file-refs.vb)]

## <a name="path-normalization"></a><span data-ttu-id="64f13-173">Normalisation des chemins d’accès</span><span class="sxs-lookup"><span data-stu-id="64f13-173">Path normalization</span></span>

<span data-ttu-id="64f13-174">Presque tous les chemins passés aux API Windows sont normalisés.</span><span class="sxs-lookup"><span data-stu-id="64f13-174">Almost all paths passed to Windows APIs are normalized.</span></span> <span data-ttu-id="64f13-175">Durant la normalisation, Windows effectue les étapes suivantes :</span><span class="sxs-lookup"><span data-stu-id="64f13-175">During normalization, Windows performs the following steps:</span></span>

- <span data-ttu-id="64f13-176">Identifie le chemin.</span><span class="sxs-lookup"><span data-stu-id="64f13-176">Identifies the path.</span></span>
- <span data-ttu-id="64f13-177">Applique le répertoire actif aux chemins partiels (relatifs).</span><span class="sxs-lookup"><span data-stu-id="64f13-177">Applies the current directory to partially qualified (relative) paths.</span></span>
- <span data-ttu-id="64f13-178">Applique une mise en forme canonique aux séparateurs de composants et de répertoires.</span><span class="sxs-lookup"><span data-stu-id="64f13-178">Canonicalizes component and directory separators.</span></span>
- <span data-ttu-id="64f13-179">Évalue les composants des répertoires relatifs (`.` pour le répertoire actif et `..` pour le répertoire parent).</span><span class="sxs-lookup"><span data-stu-id="64f13-179">Evaluates relative directory components (`.` for the current directory and `..` for the parent directory).</span></span>
- <span data-ttu-id="64f13-180">Supprime certains caractères.</span><span class="sxs-lookup"><span data-stu-id="64f13-180">Trims certain characters.</span></span>

<span data-ttu-id="64f13-181">Cette normalisation se produit implicitement, mais vous pouvez l’effectuer explicitement en appelant la méthode <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType>, qui inclut dans un wrapper un appel à la [fonction GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="64f13-181">This normalization happens implicitly, but you can do it explicitly by calling the <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> method, which wraps a call to the  [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span> <span data-ttu-id="64f13-182">Vous pouvez également appeler directement la [fonction GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) Windows à l’aide de P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="64f13-182">You can also call the Windows [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) directly using P/Invoke.</span></span>

### <a name="identifying-the-path"></a><span data-ttu-id="64f13-183">Identification du chemin</span><span class="sxs-lookup"><span data-stu-id="64f13-183">Identifying the path</span></span>

<span data-ttu-id="64f13-184">La première étape de normalisation d’un chemin consiste à identifier le type du chemin.</span><span class="sxs-lookup"><span data-stu-id="64f13-184">The first step in path normalization is identifying the type of path.</span></span> <span data-ttu-id="64f13-185">Les chemins appartiennent à l’une des catégories suivantes :</span><span class="sxs-lookup"><span data-stu-id="64f13-185">Paths fall into one of a few categories:</span></span>

- <span data-ttu-id="64f13-186">Chemins de périphérique : commencent par deux séparateurs et un point d’interrogation ou un point (`\\?` ou `\\.`).</span><span class="sxs-lookup"><span data-stu-id="64f13-186">They are device paths; that is, they begin with two separators and a question mark or period (`\\?` or `\\.`).</span></span>
- <span data-ttu-id="64f13-187">Chemins UNC : commencent par deux séparateurs sans point d’interrogation ou point.</span><span class="sxs-lookup"><span data-stu-id="64f13-187">They are UNC paths; that is, they begin with two separators without a question mark or period.</span></span> 
- <span data-ttu-id="64f13-188">Chemins DOS complets : commencent par une lettre de lecteur, un séparateur de volumes et un séparateur de composants (`C:\`).</span><span class="sxs-lookup"><span data-stu-id="64f13-188">They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (`C:\`).</span></span>
- <span data-ttu-id="64f13-189">Chemins désignant un périphérique hérité (`CON`, `LPT1`).</span><span class="sxs-lookup"><span data-stu-id="64f13-189">They designate a legacy device (`CON`, `LPT1`).</span></span>
- <span data-ttu-id="64f13-190">Chemins relatifs à la racine du lecteur actif : commencent par un séparateur de composants unique (`\`).</span><span class="sxs-lookup"><span data-stu-id="64f13-190">They are relative to the root of the current drive; that is, they begin with a single component separator (`\`).</span></span>
- <span data-ttu-id="64f13-191">Chemins relatifs au répertoire actif d’un lecteur spécifié : commencent par une lettre de lecteur, un séparateur de volumes et aucun séparateur de composants (`C:`).</span><span class="sxs-lookup"><span data-stu-id="64f13-191">They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (`C:`).</span></span>
- <span data-ttu-id="64f13-192">Chemins relatifs au répertoire actif : ils commencent par autre chose (`temp\testfile.txt`).</span><span class="sxs-lookup"><span data-stu-id="64f13-192">They are relative to the current directory; that is, they begin with anything else (`temp\testfile.txt`).</span></span>

<span data-ttu-id="64f13-193">Le type du chemin détermine si un répertoire actif est appliqué ou non d’une certaine façon.</span><span class="sxs-lookup"><span data-stu-id="64f13-193">The type of the path determines whether or not a current directory is applied in some way.</span></span> <span data-ttu-id="64f13-194">Il détermine également la « racine » du chemin.</span><span class="sxs-lookup"><span data-stu-id="64f13-194">It also determines what the "root" of the path is.</span></span>

### <a name="handling-legacy-devices"></a><span data-ttu-id="64f13-195">Gestion des périphériques hérités</span><span class="sxs-lookup"><span data-stu-id="64f13-195">Handling legacy devices</span></span>

<span data-ttu-id="64f13-196">Si le chemin est un périphérique DOS hérité comme `CON`, `COM1` ou `LPT1`, il est converti en chemin de périphérique (préfixe `\\.\` ajouté) et retourné.</span><span class="sxs-lookup"><span data-stu-id="64f13-196">If the path is a legacy DOS device such as `CON`, `COM1`, or `LPT1`, it is converted into a device path by prepending `\\.\` and returned.</span></span> 

<span data-ttu-id="64f13-197">Un chemin qui commence par un nom de périphérique hérité est toujours interprété comme périphérique hérité par la méthode <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="64f13-197">A path that begins with a legacy device name is always interpreted as a legacy device by the <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="64f13-198">Par exemple, le chemin de périphérique DOS pour `CON.TXT` est `\\.\CON`, et celui pour `COM1.TXT\file1.txt` est `\\.\COM1`.</span><span class="sxs-lookup"><span data-stu-id="64f13-198">For example, the DOS device path for `CON.TXT` is `\\.\CON`, and the DOS device path for `COM1.TXT\file1.txt` is `\\.\COM1`.</span></span>

### <a name="applying-the-current-directory"></a><span data-ttu-id="64f13-199">Application du répertoire actif</span><span class="sxs-lookup"><span data-stu-id="64f13-199">Applying the current directory</span></span>

<span data-ttu-id="64f13-200">Si un chemin n’est pas complet, Windows applique à celui-ci le répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="64f13-200">If a path isn't fully qualified, Windows applies the current directory to it.</span></span> <span data-ttu-id="64f13-201">Le répertoire actif n’est pas appliqué aux chemins UNC et de périphérique.</span><span class="sxs-lookup"><span data-stu-id="64f13-201">UNCs and device paths do not have the current directory applied.</span></span> <span data-ttu-id="64f13-202">Il n’est pas non plus appliqué à un lecteur complet avec le séparateur C:\\.</span><span class="sxs-lookup"><span data-stu-id="64f13-202">Neither does a full drive with separator C:\\.</span></span>

<span data-ttu-id="64f13-203">Si le chemin commence par un séparateur de composant unique, le lecteur du répertoire actif est appliqué.</span><span class="sxs-lookup"><span data-stu-id="64f13-203">If the path starts with a single component separator, the drive from the current directory is applied.</span></span> <span data-ttu-id="64f13-204">Par exemple, si le chemin de fichier est `\utilities` et le répertoire actif `C:\temp\`, la normalisation produit `C:\utilities`.</span><span class="sxs-lookup"><span data-stu-id="64f13-204">For example, if the file path is `\utilities` and the current directory is `C:\temp\`, normalization produces `C:\utilities`.</span></span>

<span data-ttu-id="64f13-205">Si le chemin commence par une lettre de lecteur, comprend un séparateur de volumes, mais ne contient aucun séparateur de composants, le dernier répertoire actif défini à partir de l’interface de commande pour le lecteur spécifié est appliqué.</span><span class="sxs-lookup"><span data-stu-id="64f13-205">If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</span></span> <span data-ttu-id="64f13-206">Si le dernier répertoire actif n’a pas été défini, seul le lecteur est appliqué.</span><span class="sxs-lookup"><span data-stu-id="64f13-206">If the last current directory was not set, the drive alone is applied.</span></span> <span data-ttu-id="64f13-207">Par exemple, si le chemin de fichier est `D:sources`, le répertoire actif `C:\Documents\` et le dernier répertoire actif sur le lecteur D: `D:\sources\`, le résultat est `D:\sources\sources`.</span><span class="sxs-lookup"><span data-stu-id="64f13-207">For example, if the file path is `D:sources`, the current directory is `C:\Documents\`, and the last current directory on drive D: was `D:\sources\`, the result is `D:\sources\sources`.</span></span> <span data-ttu-id="64f13-208">Ces chemins « relatifs au lecteur » sont une source commune d’erreurs de logique qui affectent les programmes et les scripts.</span><span class="sxs-lookup"><span data-stu-id="64f13-208">These "drive relative" paths are a common source of program and script logic errors.</span></span> <span data-ttu-id="64f13-209">Il est évidemment incorrect d’assumer qu’un chemin commençant par une lettre et un signe deux-points n’est pas relatif.</span><span class="sxs-lookup"><span data-stu-id="64f13-209">Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</span></span>

<span data-ttu-id="64f13-210">Si le chemin commence par un élément autre qu’un séparateur, le lecteur et le répertoire actifs sont appliqués.</span><span class="sxs-lookup"><span data-stu-id="64f13-210">If the path starts with something other than a separator, the current drive and current directory are applied.</span></span> <span data-ttu-id="64f13-211">Par exemple, si le chemin est `filecompare` et le répertoire actif `C:\utilities\`, le résultat est `C:\utilities\filecompare\`.</span><span class="sxs-lookup"><span data-stu-id="64f13-211">For example, if the path is `filecompare` and the current directory is `C:\utilities\`, the result is `C:\utilities\filecompare\`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="64f13-212">Les chemins relatifs sont dangereux dans les applications multithreads (c’est-à-dire dans la plupart des applications), car le répertoire actif est un paramètre par processus.</span><span class="sxs-lookup"><span data-stu-id="64f13-212">Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</span></span> <span data-ttu-id="64f13-213">N’importe quel thread peut changer le répertoire actif à tout moment.</span><span class="sxs-lookup"><span data-stu-id="64f13-213">Any thread can change the current directory at any time.</span></span> <span data-ttu-id="64f13-214">À compter de .NET Core 2.1, vous pouvez appeler la méthode <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> pour obtenir un chemin absolu à partir d’un chemin relatif et le chemin de base (répertoire actif) par rapport auquel vous souhaitez le résoudre.</span><span class="sxs-lookup"><span data-stu-id="64f13-214">Starting with .NET Core 2.1, you can call the <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</span></span> 

### <a name="canonicalizing-separators"></a><span data-ttu-id="64f13-215">Mise en forme canonique des séparateurs</span><span class="sxs-lookup"><span data-stu-id="64f13-215">Canonicalizing separators</span></span>

<span data-ttu-id="64f13-216">Toute barre oblique (`/`) est convertie en séparateur Windows standard, à savoir la barre oblique inverse (`\`).</span><span class="sxs-lookup"><span data-stu-id="64f13-216">All forward slashes (`/`) are converted into the standard Windows separator, the back slash (`\`).</span></span> <span data-ttu-id="64f13-217">Toute série de barres obliques après les deux premières barres obliques est réduite en barre oblique unique.</span><span class="sxs-lookup"><span data-stu-id="64f13-217">If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</span></span>

### <a name="evaluating-relative-components"></a><span data-ttu-id="64f13-218">Évaluation des composants relatifs</span><span class="sxs-lookup"><span data-stu-id="64f13-218">Evaluating relative components</span></span>

<span data-ttu-id="64f13-219">À mesure que le chemin est traité, tout composant ou segment constitué d’un point unique ou double (`.` ou `..`) est évalué :</span><span class="sxs-lookup"><span data-stu-id="64f13-219">As the path is processed, any components or segments that are composed of a single or a double period (`.` or `..`) are evaluated:</span></span> 

- <span data-ttu-id="64f13-220">Pour un point unique, le segment actif est supprimé, car il fait référence au répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="64f13-220">For a single period, the current segment is removed, since it refers to the current directory.</span></span>

- <span data-ttu-id="64f13-221">Pour un point double, le segment actif et le segment parent sont supprimés, car il fait référence au répertoire parent.</span><span class="sxs-lookup"><span data-stu-id="64f13-221">For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</span></span>

   <span data-ttu-id="64f13-222">Les répertoires parents sont uniquement supprimés s’ils ne sont pas situés au-delà de la racine du chemin.</span><span class="sxs-lookup"><span data-stu-id="64f13-222">Parent directories are only removed if they aren't past the root of the path.</span></span> <span data-ttu-id="64f13-223">La racine du chemin varie selon le type de chemin.</span><span class="sxs-lookup"><span data-stu-id="64f13-223">The root of the path depends on the type of path.</span></span> <span data-ttu-id="64f13-224">Il s’agit du lecteur (`C:\`) pour les chemins DOS, du serveur/partage pour les chemins UNC (`\\Server\Share`) et du préfixe du chemin de périphérique pour les chemins de périphérique (`\\?\` ou `\\.\`).</span><span class="sxs-lookup"><span data-stu-id="64f13-224">It is the drive (`C:\`) for DOS paths, the server/share for UNCs (`\\Server\Share`), and the device path prefix for device paths (`\\?\` or `\\.\`).</span></span>

### <a name="trimming-characters"></a><span data-ttu-id="64f13-225">Suppression de caractères</span><span class="sxs-lookup"><span data-stu-id="64f13-225">Trimming characters</span></span>

<span data-ttu-id="64f13-226">Outre les séries de séparateurs et de segments relatifs supprimés précédemment, d’autres caractères sont supprimés durant la normalisation :</span><span class="sxs-lookup"><span data-stu-id="64f13-226">Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</span></span>

- <span data-ttu-id="64f13-227">Si un segment se termine par un point unique, celui-ci est supprimé.</span><span class="sxs-lookup"><span data-stu-id="64f13-227">If a segment ends in a single period, that period is removed.</span></span> <span data-ttu-id="64f13-228">(Un segment constitué d’un point unique ou double est normalisé à l’étape précédente.</span><span class="sxs-lookup"><span data-stu-id="64f13-228">(A segment of a single or double period is normalized in the previous step.</span></span> <span data-ttu-id="64f13-229">Un segment constitué de trois ou quatre points n’est pas normalisé, car il s’agit d’un nom de fichier/répertoire valide.)</span><span class="sxs-lookup"><span data-stu-id="64f13-229">A segment of three or more periods is not normalized and is actually a valid file/directory name.)</span></span>

- <span data-ttu-id="64f13-230">Si le chemin ne se termine pas par un séparateur, tous les points et espaces (U+0020) de fin sont supprimés.</span><span class="sxs-lookup"><span data-stu-id="64f13-230">If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</span></span> <span data-ttu-id="64f13-231">Si le dernier segment est simplement un point simple ou double, il relève de la règle des composants relatifs ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="64f13-231">If the last segment is simply a single or double period, it falls under the relative components rule above.</span></span> 

   <span data-ttu-id="64f13-232">Cette règle signifie que vous pouvez créer un nom de répertoire avec un espace de fin en ajoutant un séparateur de fin après l’espace.</span><span class="sxs-lookup"><span data-stu-id="64f13-232">This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</span></span>  

   > [!IMPORTANT]
   > <span data-ttu-id="64f13-233">**Ne créez jamais** un répertoire ou un nom de fichier avec un espace de fin.</span><span class="sxs-lookup"><span data-stu-id="64f13-233">You should **never** create a directory or filename with a trailing space.</span></span> <span data-ttu-id="64f13-234">Les espaces de fin peuvent rendre l’accès à un répertoire difficile voire impossible, et il arrive fréquemment que des applications échouent quand vous tentez de gérer des répertoires ou des fichiers dont les noms comprennent des espaces de fin.</span><span class="sxs-lookup"><span data-stu-id="64f13-234">Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</span></span>

## <a name="skipping-normalization"></a><span data-ttu-id="64f13-235">Ignorer la normalisation</span><span class="sxs-lookup"><span data-stu-id="64f13-235">Skipping normalization</span></span>

<span data-ttu-id="64f13-236">En règle générale, tout chemin passé à une API Windows est (effectivement) passé à la [fonction GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) et normalisé.</span><span class="sxs-lookup"><span data-stu-id="64f13-236">Normally, any path passed to a Windows API is (effectively) passed to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) and normalized.</span></span> <span data-ttu-id="64f13-237">Il existe toutefois une exception importante : un chemin de périphérique qui commence par un point d’interrogation et non un point.</span><span class="sxs-lookup"><span data-stu-id="64f13-237">There is one important exception: a device path that begins with a question mark instead of a period.</span></span> <span data-ttu-id="64f13-238">À moins qu’il ne commence exactement par `\\?\` (notez l’utilisation de la barre oblique inverse canonique), le chemin est normalisé.</span><span class="sxs-lookup"><span data-stu-id="64f13-238">Unless the path starts exactly with `\\?\` (note the use of the canonical backslash), it is normalized.</span></span>

<span data-ttu-id="64f13-239">Pourquoi ignorer la normalisation ?</span><span class="sxs-lookup"><span data-stu-id="64f13-239">Why would you want to skip normalization?</span></span> <span data-ttu-id="64f13-240">Voici les trois raisons principales :</span><span class="sxs-lookup"><span data-stu-id="64f13-240">There are three major reasons:</span></span>

1. <span data-ttu-id="64f13-241">Accéder aux chemins normalement indisponibles, mais autorisés.</span><span class="sxs-lookup"><span data-stu-id="64f13-241">To get access to paths that are normally unavailable but are legal.</span></span> <span data-ttu-id="64f13-242">Par exemple, il est impossible d’accéder à un fichier ou à un répertoire appelé `hidden.` d’une autre manière.</span><span class="sxs-lookup"><span data-stu-id="64f13-242">A file or directory called `hidden.`, for example, is impossible to access in any other way.</span></span> 

1. <span data-ttu-id="64f13-243">Améliorer le niveau de performance en ignorant la normalisation précédemment effectuée.</span><span class="sxs-lookup"><span data-stu-id="64f13-243">To improve performance by skipping normalization if you've already normalized.</span></span>

1. <span data-ttu-id="64f13-244">Sur le .NET Framework uniquement, ignorer la vérification de la longueur du chemin (`MAX_PATH`) et autoriser les chemins de plus de 259 caractères.</span><span class="sxs-lookup"><span data-stu-id="64f13-244">On the .NET Framework only, to skip the `MAX_PATH` check for path length to allow for paths that are greater than 259 characters.</span></span> <span data-ttu-id="64f13-245">La plupart des API autorisent ceci, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="64f13-245">Most APIs allow this, with some exceptions.</span></span>

> [!NOTE]
> <span data-ttu-id="64f13-246">.NET Core gère implicitement les chemins longs et n’effectue pas la vérification `MAX_PATH`.</span><span class="sxs-lookup"><span data-stu-id="64f13-246">.NET Core handles long paths implicitly and does not perform a `MAX_PATH` check.</span></span> <span data-ttu-id="64f13-247">La vérification `MAX_PATH` s’applique uniquement au .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="64f13-247">The `MAX_PATH` check applies only to the .NET Framework.</span></span>

<span data-ttu-id="64f13-248">La seule différence entre les deux syntaxes de chemin de périphérique tient au fait que vous pouvez ignorer la normalisation et les vérifications de la longueur maximale des chemins ; sinon, elles sont identiques.</span><span class="sxs-lookup"><span data-stu-id="64f13-248">Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</span></span> <span data-ttu-id="64f13-249">Soyez prudent si vous choisissez d’ignorer la normalisation, car vous pouvez facilement créer des chemins difficiles à gérer pour les applications « normales ».</span><span class="sxs-lookup"><span data-stu-id="64f13-249">Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</span></span>

<span data-ttu-id="64f13-250">Les chemins qui commencent par `\\?\` sont toujours normalisés si vous les passez explicitement à la [fonction GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="64f13-250">Paths that start with `\\?\` are still normalized if you explicitly pass them to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span>

<span data-ttu-id="64f13-251">Notez que vous pouvez passer les chemins de plus de `MAX_PATH` caractères à la fonction [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) sans `\\?\`.</span><span class="sxs-lookup"><span data-stu-id="64f13-251">Note that you can paths of more than `MAX_PATH` characters to [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) without `\\?\`.</span></span> <span data-ttu-id="64f13-252">Elle prend en charge les chemins de longueur arbitraire jusqu’à la taille de chaîne maximale gérée par Windows.</span><span class="sxs-lookup"><span data-stu-id="64f13-252">It supports arbitrary length paths up to the maximum string size that Windows can handle.</span></span>

## <a name="case-and-the-windows-file-system"></a><span data-ttu-id="64f13-253">Casse et système de fichiers Windows</span><span class="sxs-lookup"><span data-stu-id="64f13-253">Case and the Windows file system</span></span>

<span data-ttu-id="64f13-254">Le fait que les noms de chemin et de répertoire ne respectent pas la casse est une particularité du système de fichiers Windows que les développeurs et utilisateurs d’autres systèmes d’exploitation trouvent déroutante.</span><span class="sxs-lookup"><span data-stu-id="64f13-254">A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</span></span> <span data-ttu-id="64f13-255">Autrement dit, les noms de répertoire et de fichier reflètent la casse des chaînes utilisée au moment de leur création.</span><span class="sxs-lookup"><span data-stu-id="64f13-255">That is, directory and file names reflect the casing of the strings used when they are created.</span></span> <span data-ttu-id="64f13-256">Par exemple, l’appel de méthode</span><span class="sxs-lookup"><span data-stu-id="64f13-256">For example, the method call</span></span>

```csharp
Directory.Create("TeStDiReCtOrY");
```

```vb
Directory.Create("TeStDiReCtOrY")
```

<span data-ttu-id="64f13-257">crée un répertoire nommé TeStDiReCtOrY.</span><span class="sxs-lookup"><span data-stu-id="64f13-257">creates a directory named TeStDiReCtOrY.</span></span> <span data-ttu-id="64f13-258">Si vous renommez un répertoire ou un fichier pour changer sa casse, le nom du répertoire ou du fichier reflète la casse de la chaîne utilisée au moment du renommage.</span><span class="sxs-lookup"><span data-stu-id="64f13-258">If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</span></span> <span data-ttu-id="64f13-259">Par exemple, le code suivant renomme un fichier nommé test.txt en Test.txt :</span><span class="sxs-lookup"><span data-stu-id="64f13-259">For example, the following code renames a file named test.txt to Test.txt:</span></span>

[!code-csharp[case-and-renaming](~/samples/snippets/standard/io/file-names/cs/rename.cs)]
[!code-vb[case-and-renaming](~/samples/snippets/standard/io/file-names/vb/rename.vb)]

<span data-ttu-id="64f13-260">Toutefois, les comparaisons des noms de répertoire et de fichier ne respectent pas la casse.</span><span class="sxs-lookup"><span data-stu-id="64f13-260">However, directory and file name comparisons are case-insensitive.</span></span> <span data-ttu-id="64f13-261">Si vous recherchez un fichier nommé « test.txt », les API du système de fichiers .NET ignorent la casse dans la comparaison.</span><span class="sxs-lookup"><span data-stu-id="64f13-261">If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</span></span> <span data-ttu-id="64f13-262">Test.txt, TEST.TXT, test.TXT et toute autre combinaison de lettres majuscules et minuscules équivalent à « test.txt ».</span><span class="sxs-lookup"><span data-stu-id="64f13-262">Test.txt, TEST.TXT, test.TXT, and any other combination of upper- and lowercase letters will match "test.txt".</span></span>
