---
title: Choix entre classe et structure
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
author: KrzysztofCwalina
ms.openlocfilehash: a47e43b2387362500d46c8e531f16d004d823c4c
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61778779"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="8c9fa-102">Choix entre classe et structure</span><span class="sxs-lookup"><span data-stu-id="8c9fa-102">Choosing Between Class and Struct</span></span>
<span data-ttu-id="8c9fa-103">Une des décisions de conception de base auxquelles est confronté chaque concepteur de framework est de concevoir un type sous forme de classe (type référence) ou sous forme de struct (type valeur).</span><span class="sxs-lookup"><span data-stu-id="8c9fa-103">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="8c9fa-104">Il est nécessaire de bien comprendre les différences de comportement entre les types référence et les types valeur pour faire ce choix.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-104">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>  
  
 <span data-ttu-id="8c9fa-105">La première différence entre les types référence et les types valeur que nous considérerons est que les types référence sont alloués sur le tas et récupérés par le récupérateur de mémoire, alors que les types valeur sont alloués sur la pile ou en ligne dans les types conteneurs, et désalloués quand la pile se déroule ou quand leur type conteneur est désalloué.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-105">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="8c9fa-106">Par conséquent, les allocations et les désallocations des types valeur sont en général moins coûteuses en ressources que les allocations et désallocations des types référence.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-106">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>  
  
 <span data-ttu-id="8c9fa-107">Ensuite, les tableaux de types référence sont alloués hors ligne, ce qui signifie que les éléments du tableau sont simplement des références à des instances de type référence présentes dans la pile.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-107">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="8c9fa-108">Les tableaux de types valeur sont alloués en ligne, ce qui signifie que les éléments du tableau sont les instances réelles du type valeur.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-108">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="8c9fa-109">Par conséquent, les allocations et les désallocations de tableaux de types valeur sont beaucoup moins coûteuses en ressources que les allocations et les désallocations de tableaux de types référence.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-109">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="8c9fa-110">En outre, dans la plupart des cas, les tableaux de types valeur présentent une bien meilleure localité des références.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-110">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>  
  
 <span data-ttu-id="8c9fa-111">La différence suivante est liée à l’utilisation de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-111">The next difference is related to memory usage.</span></span> <span data-ttu-id="8c9fa-112">Les types valeur subissent un boxing lors du cast en un type référence ou en une des interfaces qu’ils implémentent.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-112">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="8c9fa-113">Ils subissent un unboxing quand ils sont recastés en type valeur.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-113">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="8c9fa-114">Comme les box sont des objets qui sont alloués à la pile et récupérés par le récupérateur de mémoire, trop de boxing et d’unboxing peut avoir un impact négatif sur la pile, sur le récupérateur de mémoire et au final sur les performances de l’application.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-114">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="8c9fa-115">En revanche, aucun boxing de ce type ne se produit quand des types référence sont castés.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-115">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="8c9fa-116">(Pour plus d’informations, consultez [Boxing et Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="8c9fa-116">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>
  
 <span data-ttu-id="8c9fa-117">Ensuite, les affectations de type référence copient la référence, tandis que les affectations de type valeur copient la valeur entière.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-117">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="8c9fa-118">Par conséquent, les affectations de types référence de grande taille sont moins coûteuses en ressources que les affectations de types valeur de grande taille.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-118">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>  
  
 <span data-ttu-id="8c9fa-119">Enfin, les types référence sont passés par référence, tandis que les types valeur sont passés par valeur.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-119">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="8c9fa-120">Les modifications apportées à une instance d’un type référence affectent toutes les références pointant vers l’instance.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-120">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="8c9fa-121">Les instances de types valeur sont copiées quand elles sont passées par valeur.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-121">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="8c9fa-122">Quand une instance d’un type valeur est modifiée, cela n’affecte bien sûr pas ses copies.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-122">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="8c9fa-123">Comme les copies ne sont pas créées explicitement par l’utilisateur, mais sont créées implicitement quand des arguments sont passés ou que des valeurs sont retournées, les types valeur qui peuvent être modifiés peuvent créer de la confusion pour de nombreux utilisateurs.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-123">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="8c9fa-124">Par conséquent, les types valeur devraient être immuables.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-124">Therefore, value types should be immutable.</span></span>  
  
 <span data-ttu-id="8c9fa-125">D’une façon générale, la majorité des types d’un framework devraient être des classes.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-125">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="8c9fa-126">Cependant, il existe certaines situations dans lesquelles les caractéristiques d’un type valeur font qu’il est plus approprié d’utiliser des structs.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-126">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>  
  
 <span data-ttu-id="8c9fa-127">**✓ CONSIDER** de définir un struct au lieu d’une classe si les instances du type sont de petite taille et d’une durée de vie assez courte, ou si elles sont souvent incorporées dans d’autres objets.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-127">**✓ CONSIDER** defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>  
  
 <span data-ttu-id="8c9fa-128">**X AVOID** la définition d’un struct, sauf si le type possède toutes les caractéristiques suivantes :</span><span class="sxs-lookup"><span data-stu-id="8c9fa-128">**X AVOID** defining a struct unless the type has all of the following characteristics:</span></span>  
  
- <span data-ttu-id="8c9fa-129">Il représente logiquement une seule valeur, similaire aux types primitifs (`int`, `double`, etc..).</span><span class="sxs-lookup"><span data-stu-id="8c9fa-129">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>  
  
- <span data-ttu-id="8c9fa-130">Il a une taille d’instance inférieure à 16 octets.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-130">It has an instance size under 16 bytes.</span></span>  
  
- <span data-ttu-id="8c9fa-131">Il est immuable.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-131">It is immutable.</span></span>  
  
- <span data-ttu-id="8c9fa-132">Il n’aura pas à subir fréquemment des opérations de boxing.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-132">It will not have to be boxed frequently.</span></span>  
  
 <span data-ttu-id="8c9fa-133">Dans tous les autres cas, vous devez définir vos types comme classes.</span><span class="sxs-lookup"><span data-stu-id="8c9fa-133">In all other cases, you should define your types as classes.</span></span>  
  
 <span data-ttu-id="8c9fa-134">*Portions © 2005, 2009 Microsoft Corporation. Tous droits réservés.*</span><span class="sxs-lookup"><span data-stu-id="8c9fa-134">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>  
  
 <span data-ttu-id="8c9fa-135">*Réimprimé avec l’autorisation de Pearson éducation, Inc. à partir de [instructions de conception Framework : Conventions, les idiomes et les modèles pour les bibliothèques .NET réutilisable, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina et Brad Abrams, publié le 22 octobre 2008 par Addison-Wesley Professional dans le cadre de la série de développement de Microsoft Windows.*</span><span class="sxs-lookup"><span data-stu-id="8c9fa-135">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8c9fa-136">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="8c9fa-136">See also</span></span>

- [<span data-ttu-id="8c9fa-137">Instructions pour la conception des types</span><span class="sxs-lookup"><span data-stu-id="8c9fa-137">Type Design Guidelines</span></span>](../../../docs/standard/design-guidelines/type.md)
- [<span data-ttu-id="8c9fa-138">Règles de conception de .NET Framework</span><span class="sxs-lookup"><span data-stu-id="8c9fa-138">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)
