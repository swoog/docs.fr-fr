---
title: Vue d’ensemble du modèle asynchrone basé sur des événements
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Event-based Asynchronous Pattern
- ProgressChangedEventArgs class
- BackgroundWorker component
- events [.NET Framework], asynchronous
- Asynchronous Pattern
- AsyncOperationManager class
- threading [.NET Framework], asynchronous features
- AsyncOperation class
- AsyncCompletedEventArgs class
ms.assetid: 792aa8da-918b-458e-b154-9836b97735f3
ms.openlocfilehash: f923ca42e67c76f8b4296089953fada65b645f4f
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64629010"
---
# <a name="event-based-asynchronous-pattern-overview"></a><span data-ttu-id="30fa0-102">Vue d’ensemble du modèle asynchrone basé sur des événements</span><span class="sxs-lookup"><span data-stu-id="30fa0-102">Event-based Asynchronous Pattern Overview</span></span>
<span data-ttu-id="30fa0-103">Les applications qui effectuent de nombreuses tâches simultanément tout en réagissant aux interventions de l’utilisateur nécessitent souvent une conception utilisant plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="30fa0-103">Applications that perform many tasks simultaneously, yet remain responsive to user interaction, often require a design that uses multiple threads.</span></span> <span data-ttu-id="30fa0-104">L’espace de noms <xref:System.Threading> fournit tous les outils nécessaires à la création d’applications multithread de hautes performances, mais l’utilisation de ces outils suppose une connaissance approfondie du génie logiciel multithread.</span><span class="sxs-lookup"><span data-stu-id="30fa0-104">The <xref:System.Threading> namespace provides all the tools necessary to create high-performance multithreaded applications, but using these tools effectively requires significant experience with multithreaded software engineering.</span></span> <span data-ttu-id="30fa0-105">Pour les applications multithread relativement simples, le composant <xref:System.ComponentModel.BackgroundWorker> fournit une solution simple.</span><span class="sxs-lookup"><span data-stu-id="30fa0-105">For relatively simple multithreaded applications, the <xref:System.ComponentModel.BackgroundWorker> component provides a straightforward solution.</span></span> <span data-ttu-id="30fa0-106">Pour les applications asynchrones plus sophistiquées, envisagez l’implémentation d’une classe obéissant au modèle asynchrone basé sur les événements.</span><span class="sxs-lookup"><span data-stu-id="30fa0-106">For more sophisticated asynchronous applications, consider implementing a class that adheres to the Event-based Asynchronous Pattern.</span></span>  
  
 <span data-ttu-id="30fa0-107">Le modèle asynchrone basé sur les événements permet de profiter des avantages des applications multithread tout en masquant de nombreux problèmes complexes inhérents à la conception multithread.</span><span class="sxs-lookup"><span data-stu-id="30fa0-107">The Event-based Asynchronous Pattern makes available the advantages of multithreaded applications while hiding many of the complex issues inherent in multithreaded design.</span></span> <span data-ttu-id="30fa0-108">L’utilisation d’une classe prenant en charge ce modèle peut vous permettre :</span><span class="sxs-lookup"><span data-stu-id="30fa0-108">Using a class that supports this pattern can allow you to:</span></span>  
  
- <span data-ttu-id="30fa0-109">d'effectuer, « en arrière-plan », des tâches de longue durée, telles que des téléchargements et des opérations de base de données, sans interrompre votre application ;</span><span class="sxs-lookup"><span data-stu-id="30fa0-109">Perform time-consuming tasks, such as downloads and database operations, "in the background," without interrupting your application.</span></span>  
  
- <span data-ttu-id="30fa0-110">d'exécuter plusieurs opérations simultanément, en recevant des notifications quand chacune d'elles se termine ;</span><span class="sxs-lookup"><span data-stu-id="30fa0-110">Execute multiple operations simultaneously, receiving notifications when each completes.</span></span>  
  
- <span data-ttu-id="30fa0-111">d'attendre que les ressources soient disponibles sans arrêter (« bloquer ») votre application ;</span><span class="sxs-lookup"><span data-stu-id="30fa0-111">Wait for resources to become available without stopping ("hanging") your application.</span></span>  
  
- <span data-ttu-id="30fa0-112">de communiquer avec les opérations asynchrones en attente à l'aide du modèle d'événements et de délégués connu.</span><span class="sxs-lookup"><span data-stu-id="30fa0-112">Communicate with pending asynchronous operations using the familiar events-and-delegates model.</span></span> <span data-ttu-id="30fa0-113">Pour plus d'informations sur l'utilisation des gestionnaires d'événements et des délégués, consultez la page [Événements](../../../docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="30fa0-113">For more information on using event handlers and delegates, see [Events](../../../docs/standard/events/index.md).</span></span>  
  
 <span data-ttu-id="30fa0-114">Une classe prenant en charge le modèle asynchrone basé sur les événements possède une ou plusieurs méthodes nommées _MethodName_**Async**.</span><span class="sxs-lookup"><span data-stu-id="30fa0-114">A class that supports the Event-based Asynchronous Pattern will have one or more methods named _MethodName_**Async**.</span></span> <span data-ttu-id="30fa0-115">Ces méthodes peuvent refléter des versions synchrones qui exécutent la même opération sur le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30fa0-115">These methods may mirror synchronous versions, which perform the same operation on the current thread.</span></span> <span data-ttu-id="30fa0-116">La classe peut également posséder un événement _MethodName_**Completed** et une méthode _MethodName_**AsyncCancel** (ou simplement **CancelAsync**).</span><span class="sxs-lookup"><span data-stu-id="30fa0-116">The class may also have a _MethodName_**Completed** event and it may have a _MethodName_**AsyncCancel** (or simply **CancelAsync**) method.</span></span>  
  
 <span data-ttu-id="30fa0-117"><xref:System.Windows.Forms.PictureBox> est un composant courant qui prend en charge le modèle asynchrone basé sur les événements.</span><span class="sxs-lookup"><span data-stu-id="30fa0-117"><xref:System.Windows.Forms.PictureBox> is a typical component that supports the Event-based Asynchronous Pattern.</span></span> <span data-ttu-id="30fa0-118">Vous pouvez télécharger une image de façon synchrone en appelant sa méthode <xref:System.Windows.Forms.PictureBox.Load%2A>, mais si l'image est grande ou que la connexion réseau est lente, votre application s'arrête (« se bloque ») jusqu'à ce que l'opération de téléchargement soit terminée et que l'appel à <xref:System.Windows.Forms.PictureBox.Load%2A> soit retourné.</span><span class="sxs-lookup"><span data-stu-id="30fa0-118">You can download an image synchronously by calling its <xref:System.Windows.Forms.PictureBox.Load%2A> method, but if the image is large, or if the network connection is slow, your application will stop ("hang") until the download operation is completed and the call to <xref:System.Windows.Forms.PictureBox.Load%2A> returns.</span></span>  
  
 <span data-ttu-id="30fa0-119">Si vous souhaitez que votre application continue de s'exécuter pendant le chargement de l'image, vous pouvez appeler la méthode <xref:System.Windows.Forms.PictureBox.LoadAsync%2A> et gérer l'événement <xref:System.Windows.Forms.PictureBox.LoadCompleted> tout comme vous le feriez pour tout autre événement.</span><span class="sxs-lookup"><span data-stu-id="30fa0-119">If you want your application to keep running while the image is loading, you can call the <xref:System.Windows.Forms.PictureBox.LoadAsync%2A> method and handle the <xref:System.Windows.Forms.PictureBox.LoadCompleted> event, just as you would handle any other event.</span></span> <span data-ttu-id="30fa0-120">Quand vous appelez la méthode <xref:System.Windows.Forms.PictureBox.LoadAsync%2A>, l'exécution de votre application se poursuit pendant que le téléchargement s'effectue sur un thread séparé (« en arrière-plan »).</span><span class="sxs-lookup"><span data-stu-id="30fa0-120">When you call the <xref:System.Windows.Forms.PictureBox.LoadAsync%2A> method, your application will continue to run while the download proceeds on a separate thread ("in the background").</span></span> <span data-ttu-id="30fa0-121">Votre gestionnaire d'événements est appelé quand l'opération de chargement d'image est terminée, et peut examiner le paramètre <xref:System.ComponentModel.AsyncCompletedEventArgs> pour déterminer si le téléchargement s'est déroulé correctement.</span><span class="sxs-lookup"><span data-stu-id="30fa0-121">Your event handler will be called when the image-loading operation is complete, and your event handler can examine the <xref:System.ComponentModel.AsyncCompletedEventArgs> parameter to determine if the download completed successfully.</span></span>  
  
 <span data-ttu-id="30fa0-122">Le modèle asynchrone basé sur les événements nécessite qu'une opération asynchrone puisse être annulée ; le contrôle <xref:System.Windows.Forms.PictureBox> prend en charge cette exigence avec sa méthode <xref:System.Windows.Forms.PictureBox.CancelAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="30fa0-122">The Event-based Asynchronous Pattern requires that an asynchronous operation can be canceled, and the <xref:System.Windows.Forms.PictureBox> control supports this requirement with its <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> method.</span></span> <span data-ttu-id="30fa0-123">L’appel de <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> soumet une demande d’arrêt du téléchargement en attente et, quand la tâche est annulée, l’événement <xref:System.Windows.Forms.PictureBox.LoadCompleted> est déclenché.</span><span class="sxs-lookup"><span data-stu-id="30fa0-123">Calling <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> submits a request to stop the pending download, and when the task is canceled, the <xref:System.Windows.Forms.PictureBox.LoadCompleted> event is raised.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="30fa0-124">Comme il est possible que le téléchargement se termine au moment où la demande <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> est effectuée, <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> peut ne pas refléter la demande d'annulation.</span><span class="sxs-lookup"><span data-stu-id="30fa0-124">It is possible that the download will finish just as the <xref:System.Windows.Forms.PictureBox.CancelAsync%2A> request is made, so <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> may not reflect the request to cancel.</span></span> <span data-ttu-id="30fa0-125">C’est ce que l’on appelle une *condition de concurrence*, un problème courant en programmation multithread.</span><span class="sxs-lookup"><span data-stu-id="30fa0-125">This is called a *race condition* and is a common issue in multithreaded programming.</span></span> <span data-ttu-id="30fa0-126">Pour plus d'informations sur les problèmes relatifs à la programmation multithread, consultez la page [Meilleures pratiques de threads managés](../../../docs/standard/threading/managed-threading-best-practices.md).</span><span class="sxs-lookup"><span data-stu-id="30fa0-126">For more information on issues in multithreaded programming, see [Managed Threading Best Practices](../../../docs/standard/threading/managed-threading-best-practices.md).</span></span>  
  
## <a name="characteristics-of-the-event-based-asynchronous-pattern"></a><span data-ttu-id="30fa0-127">Caractéristiques du modèle asynchrone basé sur les événements</span><span class="sxs-lookup"><span data-stu-id="30fa0-127">Characteristics of the Event-based Asynchronous Pattern</span></span>  
 <span data-ttu-id="30fa0-128">Le modèle asynchrone basé sur les événements peut prendre plusieurs formes selon la complexité des opérations prises en charge par une classe particulière.</span><span class="sxs-lookup"><span data-stu-id="30fa0-128">The Event-based Asynchronous Pattern may take several forms, depending on the complexity of the operations supported by a particular class.</span></span> <span data-ttu-id="30fa0-129">Les classes les plus simples peuvent avoir une seule méthode _MethodName_**Async** et un événement _MethodName_**Completed** correspondant.</span><span class="sxs-lookup"><span data-stu-id="30fa0-129">The simplest classes may have a single _MethodName_**Async** method and a corresponding _MethodName_**Completed** event.</span></span> <span data-ttu-id="30fa0-130">Les classes plus complexes peuvent posséder plusieurs méthodes _MethodName_**Async**, chacune assortie de l’événement _MethodName_**Completed** correspondant, ainsi que les versions synchrones de ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="30fa0-130">More complex classes may have several _MethodName_**Async** methods, each with a corresponding _MethodName_**Completed** event, as well as synchronous versions of these methods.</span></span> <span data-ttu-id="30fa0-131">Les classes peuvent éventuellement prendre en charge l'annulation, le rapport de progression et les résultats incrémentiels pour chaque méthode asynchrone.</span><span class="sxs-lookup"><span data-stu-id="30fa0-131">Classes can optionally support cancellation, progress reporting, and incremental results for each asynchronous method.</span></span>  
  
 <span data-ttu-id="30fa0-132">Une méthode asynchrone peut également prendre en charge plusieurs appels en attente (plusieurs appels simultanés), ce qui permet à votre code de l'appeler autant de fois que nécessaire avant de terminer d'autres opérations en attente.</span><span class="sxs-lookup"><span data-stu-id="30fa0-132">An asynchronous method may also support multiple pending calls (multiple concurrent invocations), allowing your code to call it any number of times before it completes other pending operations.</span></span> <span data-ttu-id="30fa0-133">La gestion correcte de cette situation peut nécessiter que votre application effectue le suivi de l'achèvement de chaque opération.</span><span class="sxs-lookup"><span data-stu-id="30fa0-133">Correctly handling this situation may require your application to track the completion of each operation.</span></span>  
  
### <a name="examples-of-the-event-based-asynchronous-pattern"></a><span data-ttu-id="30fa0-134">Exemples du modèle asynchrone basé sur les événements</span><span class="sxs-lookup"><span data-stu-id="30fa0-134">Examples of the Event-based Asynchronous Pattern</span></span>  
 <span data-ttu-id="30fa0-135">Les composants <xref:System.Media.SoundPlayer> et <xref:System.Windows.Forms.PictureBox> représentent des implémentations simples du modèle asynchrone basé sur les événements.</span><span class="sxs-lookup"><span data-stu-id="30fa0-135">The <xref:System.Media.SoundPlayer> and <xref:System.Windows.Forms.PictureBox> components represent simple implementations of the Event-based Asynchronous Pattern.</span></span> <span data-ttu-id="30fa0-136">Les composants <xref:System.Net.WebClient> et <xref:System.ComponentModel.BackgroundWorker> représentent des implémentations plus complexes de ce modèle.</span><span class="sxs-lookup"><span data-stu-id="30fa0-136">The <xref:System.Net.WebClient> and <xref:System.ComponentModel.BackgroundWorker> components represent more complex implementations of the Event-based Asynchronous Pattern.</span></span>  
  
 <span data-ttu-id="30fa0-137">Voici un exemple de déclaration de classe conforme au modèle :</span><span class="sxs-lookup"><span data-stu-id="30fa0-137">Below is an example class declaration that conforms to the pattern:</span></span>  
  
```vb  
Public Class AsyncExample  
    ' Synchronous methods.  
    Public Function Method1(ByVal param As String) As Integer   
    Public Sub Method2(ByVal param As Double)   
  
    ' Asynchronous methods.  
    Overloads Public Sub Method1Async(ByVal param As String)   
    Overloads Public Sub Method1Async(ByVal param As String, ByVal userState As Object)   
    Public Event Method1Completed As Method1CompletedEventHandler  
  
    Overloads Public Sub Method2Async(ByVal param As Double)   
    Overloads Public Sub Method2Async(ByVal param As Double, ByVal userState As Object)   
    Public Event Method2Completed As Method2CompletedEventHandler  
  
    Public Sub CancelAsync(ByVal userState As Object)   
  
    Public ReadOnly Property IsBusy () As Boolean  
  
    ' Class implementation not shown.  
End Class  
```  
  
```csharp  
public class AsyncExample  
{  
    // Synchronous methods.  
    public int Method1(string param);  
    public void Method2(double param);  
  
    // Asynchronous methods.  
    public void Method1Async(string param);  
    public void Method1Async(string param, object userState);  
    public event Method1CompletedEventHandler Method1Completed;  
  
    public void Method2Async(double param);  
    public void Method2Async(double param, object userState);  
    public event Method2CompletedEventHandler Method2Completed;  
  
    public void CancelAsync(object userState);  
  
    public bool IsBusy { get; }  
  
    // Class implementation not shown.  
}  
```  
  
 <span data-ttu-id="30fa0-138">La classe `AsyncExample` fictive possède deux méthodes qui prennent en charge les appels synchrones et asynchrones.</span><span class="sxs-lookup"><span data-stu-id="30fa0-138">The fictitious `AsyncExample` class has two methods, both of which support synchronous and asynchronous invocations.</span></span> <span data-ttu-id="30fa0-139">Les surcharges synchrones se comportent comme tout appel de méthode et exécutent l’opération sur le thread appelant ; si l’opération est de longue durée, le délai de retour de l’appel peut être important.</span><span class="sxs-lookup"><span data-stu-id="30fa0-139">The synchronous overloads behave like any method call and execute the operation on the calling thread; if the operation is time-consuming, there may be a noticeable delay before the call returns.</span></span> <span data-ttu-id="30fa0-140">Les surcharges asynchrones démarrent l'opération sur un autre thread, puis elles sont retournées immédiatement, permettant au thread appelant de continuer pendant l'exécution de l'opération « en arrière-plan ».</span><span class="sxs-lookup"><span data-stu-id="30fa0-140">The asynchronous overloads will start the operation on another thread and then return immediately, allowing the calling thread to continue while the operation executes "in the background."</span></span>  
  
### <a name="asynchronous-method-overloads"></a><span data-ttu-id="30fa0-141">Surcharges de méthode asynchrone</span><span class="sxs-lookup"><span data-stu-id="30fa0-141">Asynchronous Method Overloads</span></span>  
 <span data-ttu-id="30fa0-142">Il existe potentiellement deux surcharges pour les opérations asynchrones : l'appel unique et les appels multiples.</span><span class="sxs-lookup"><span data-stu-id="30fa0-142">There are potentially two overloads for the asynchronous operations: single-invocation and multiple-invocation.</span></span> <span data-ttu-id="30fa0-143">Ces deux surcharges se distinguent par leurs signatures de méthode : la surcharge d'appels multiples possède un paramètre supplémentaire appelé `userState`.</span><span class="sxs-lookup"><span data-stu-id="30fa0-143">You can distinguish these two forms by their method signatures: the multiple-invocation form has an extra parameter called `userState`.</span></span> <span data-ttu-id="30fa0-144">Elle permet à votre code d'appeler `Method1Async(string param, object userState)` plusieurs fois sans attendre que les opérations asynchrones en attente se terminent.</span><span class="sxs-lookup"><span data-stu-id="30fa0-144">This form makes it possible for your code to call `Method1Async(string param, object userState)` multiple times without waiting for any pending asynchronous operations to finish.</span></span> <span data-ttu-id="30fa0-145">En revanche, si vous tentez d'appeler `Method1Async(string param)` avant qu'un appel antérieur soit terminé, la méthode lève une <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="30fa0-145">If, on the other hand, you try to call `Method1Async(string param)` before a previous invocation has completed, the method raises an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="30fa0-146">Le paramètre `userState` pour les surcharges d'appels multiples vous permet de différencier les opérations asynchrones.</span><span class="sxs-lookup"><span data-stu-id="30fa0-146">The `userState` parameter for the multiple-invocation overloads allows you to distinguish among asynchronous operations.</span></span> <span data-ttu-id="30fa0-147">Vous indiquez une valeur unique (par exemple, un GUID ou un code de hachage) pour chaque appel à `Method1Async(string param, object userState)` ; quand chacune des opérations est terminée, votre gestionnaire d'événements peut identifier l'instance de l'opération qui a déclenché l'événement d'achèvement.</span><span class="sxs-lookup"><span data-stu-id="30fa0-147">You provide a unique value (for example, a GUID or hash code) for each call to `Method1Async(string param, object userState)`, and when each operation is completed, your event handler can determine which instance of the operation raised the completion event.</span></span>  
  
### <a name="tracking-pending-operations"></a><span data-ttu-id="30fa0-148">Suivi des opérations en attente</span><span class="sxs-lookup"><span data-stu-id="30fa0-148">Tracking Pending Operations</span></span>  
 <span data-ttu-id="30fa0-149">Si vous utilisez les surcharges d’appels multiples, votre code doit conserver une trace des objets `userState` (ID de tâche) pour les tâches en attente.</span><span class="sxs-lookup"><span data-stu-id="30fa0-149">If you use the multiple-invocation overloads, your code will need to keep track of the `userState` objects (task IDs) for pending tasks.</span></span> <span data-ttu-id="30fa0-150">Pour chaque appel à `Method1Async(string param, object userState)`, on génère en général un nouvel objet `userState` unique et on l’ajoute à une collection.</span><span class="sxs-lookup"><span data-stu-id="30fa0-150">For each call to `Method1Async(string param, object userState)`, you will typically generate a new, unique `userState` object and add it to a collection.</span></span> <span data-ttu-id="30fa0-151">Quand la tâche correspondant à cet objet `userState` déclenche l’événement d’achèvement, l’implémentation de votre méthode d’achèvement examine <xref:System.ComponentModel.AsyncCompletedEventArgs.UserState%2A?displayProperty=nameWithType> et le supprime de votre collection.</span><span class="sxs-lookup"><span data-stu-id="30fa0-151">When the task corresponding to this `userState` object raises the completion event, your completion method implementation will examine <xref:System.ComponentModel.AsyncCompletedEventArgs.UserState%2A?displayProperty=nameWithType> and remove it from your collection.</span></span> <span data-ttu-id="30fa0-152">Utilisé de cette manière, le paramètre `userState` joue le rôle d'un ID de tâche.</span><span class="sxs-lookup"><span data-stu-id="30fa0-152">Used this way, the `userState` parameter takes the role of a task ID.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30fa0-153">Vous devez fournir une valeur unique pour `userState` dans vos appels aux surcharges d'appels multiples.</span><span class="sxs-lookup"><span data-stu-id="30fa0-153">You must be careful to provide a unique value for `userState` in your calls to multiple-invocation overloads.</span></span> <span data-ttu-id="30fa0-154">Les ID de tâche non uniques conduisent la classe asynchrone à lever une <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="30fa0-154">Non-unique task IDs will cause the asynchronous class throw an <xref:System.ArgumentException>.</span></span>  
  
### <a name="canceling-pending-operations"></a><span data-ttu-id="30fa0-155">Annulation des opérations en attente</span><span class="sxs-lookup"><span data-stu-id="30fa0-155">Canceling Pending Operations</span></span>  
 <span data-ttu-id="30fa0-156">Il est important de pouvoir annuler des opérations asynchrones à tout moment avant leur achèvement.</span><span class="sxs-lookup"><span data-stu-id="30fa0-156">It is important to be able to cancel asynchronous operations at any time before their completion.</span></span> <span data-ttu-id="30fa0-157">Les classes qui implémentent le modèle asynchrone basé sur les événements comportent une méthode `CancelAsync` (s’il n’existe qu’une seule méthode asynchrone) ou une méthode _MethodName_**AsyncCancel** (s’il en existe plusieurs).</span><span class="sxs-lookup"><span data-stu-id="30fa0-157">Classes that implement the Event-based Asynchronous Pattern will have a `CancelAsync` method (if there is only one asynchronous method) or a _MethodName_**AsyncCancel** method (if there are multiple asynchronous methods).</span></span>  
  
 <span data-ttu-id="30fa0-158">Les méthodes qui autorisent les appels multiples acceptent un paramètre `userState`, qui peut être utilisé pour assurer le suivi de la durée de vie de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="30fa0-158">Methods that allow multiple invocations take a `userState` parameter, which can be used to track the lifetime of each task.</span></span> <span data-ttu-id="30fa0-159">`CancelAsync` accepte un paramètre `userState` qui vous permet d'annuler des tâches en attente particulières.</span><span class="sxs-lookup"><span data-stu-id="30fa0-159">`CancelAsync` takes a `userState` parameter, which allows you to cancel particular pending tasks.</span></span>  
  
 <span data-ttu-id="30fa0-160">Les méthodes qui prennent en charge une seule opération en attente à la fois, comme `Method1Async(string param)`, ne sont pas annulables.</span><span class="sxs-lookup"><span data-stu-id="30fa0-160">Methods that support only a single pending operation at a time, like `Method1Async(string param)`, are not cancelable.</span></span>  
  
### <a name="receiving-progress-updates-and-incremental-results"></a><span data-ttu-id="30fa0-161">Réception des mises à jour de progression et des résultats incrémentiels</span><span class="sxs-lookup"><span data-stu-id="30fa0-161">Receiving Progress Updates and Incremental Results</span></span>  
 <span data-ttu-id="30fa0-162">Une classe obéissant au modèle asynchrone basé sur les événements peut éventuellement fournir un événement pour assurer le suivi de la progression et des résultats incrémentiels.</span><span class="sxs-lookup"><span data-stu-id="30fa0-162">A class that adheres to the Event-based Asynchronous Pattern may optionally provide an event for tracking progress and incremental results.</span></span> <span data-ttu-id="30fa0-163">Celui-ci est généralement appelé `ProgressChanged` ou _MethodName_**ProgressChanged**, et son gestionnaire d’événements correspondant prend un paramètre <xref:System.ComponentModel.ProgressChangedEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="30fa0-163">This will typically be named `ProgressChanged` or _MethodName_**ProgressChanged**, and its corresponding event handler will take a <xref:System.ComponentModel.ProgressChangedEventArgs> parameter.</span></span>  
  
 <span data-ttu-id="30fa0-164">Le gestionnaire d’événements de l’événement `ProgressChanged` peut examiner la propriété <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A?displayProperty=nameWithType> afin de déterminer le pourcentage d’exécution d’une tâche asynchrone.</span><span class="sxs-lookup"><span data-stu-id="30fa0-164">The event handler for the `ProgressChanged` event can examine the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A?displayProperty=nameWithType> property to determine what percentage of an asynchronous task has been completed.</span></span> <span data-ttu-id="30fa0-165">Cette propriété est comprise entre 0 et 100 et peut être utilisée pour mettre à jour la propriété <xref:System.Windows.Forms.ProgressBar.Value%2A> d'une <xref:System.Windows.Forms.ProgressBar>.</span><span class="sxs-lookup"><span data-stu-id="30fa0-165">This property will range from 0 to 100, and it can be used to update the <xref:System.Windows.Forms.ProgressBar.Value%2A> property of a <xref:System.Windows.Forms.ProgressBar>.</span></span> <span data-ttu-id="30fa0-166">Si plusieurs opérations asynchrones sont en attente, vous pouvez utiliser la propriété <xref:System.ComponentModel.ProgressChangedEventArgs.UserState%2A?displayProperty=nameWithType> pour distinguer l'opération qui signale la progression.</span><span class="sxs-lookup"><span data-stu-id="30fa0-166">If multiple asynchronous operations are pending, you can use the <xref:System.ComponentModel.ProgressChangedEventArgs.UserState%2A?displayProperty=nameWithType> property to distinguish which operation is reporting progress.</span></span>  
  
 <span data-ttu-id="30fa0-167">Certaines classes peuvent signaler des résultats incrémentiels au fur et à mesure que les opérations asynchrones sont exécutées.</span><span class="sxs-lookup"><span data-stu-id="30fa0-167">Some classes may report incremental results as asynchronous operations proceed.</span></span> <span data-ttu-id="30fa0-168">Ces résultats sont stockés dans une classe dérivant de <xref:System.ComponentModel.ProgressChangedEventArgs> et apparaissent sous forme de propriétés dans la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="30fa0-168">These results will be stored in a class that derives from <xref:System.ComponentModel.ProgressChangedEventArgs> and they will appear as properties in the derived class.</span></span> <span data-ttu-id="30fa0-169">Vous pouvez accéder à ces résultats dans le gestionnaire d'événements pour l'événement `ProgressChanged`, tout comme vous accéderiez à la propriété <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A>.</span><span class="sxs-lookup"><span data-stu-id="30fa0-169">You can access these results in the event handler for the `ProgressChanged` event, just as you would access the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> property.</span></span> <span data-ttu-id="30fa0-170">Si plusieurs opérations asynchrones sont en attente, vous pouvez utiliser la propriété <xref:System.ComponentModel.ProgressChangedEventArgs.UserState%2A> pour distinguer l'opération qui signale des résultats incrémentiels.</span><span class="sxs-lookup"><span data-stu-id="30fa0-170">If multiple asynchronous operations are pending, you can use the <xref:System.ComponentModel.ProgressChangedEventArgs.UserState%2A> property to distinguish which operation is reporting incremental results.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="30fa0-171">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="30fa0-171">See also</span></span>

- <xref:System.ComponentModel.ProgressChangedEventArgs>
- <xref:System.ComponentModel.BackgroundWorker>
- <xref:System.ComponentModel.AsyncCompletedEventArgs>
- [<span data-ttu-id="30fa0-172">Guide pratique pour utiliser des composants qui prennent en charge le modèle asynchrone basé sur des événements</span><span class="sxs-lookup"><span data-stu-id="30fa0-172">How to: Use Components That Support the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="30fa0-173">Guide pratique pour exécuter une opération en arrière-plan</span><span class="sxs-lookup"><span data-stu-id="30fa0-173">How to: Run an Operation in the Background</span></span>](../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md)
- [<span data-ttu-id="30fa0-174">Guide pratique pour implémenter un formulaire qui utilise une opération d’arrière-plan</span><span class="sxs-lookup"><span data-stu-id="30fa0-174">How to: Implement a Form That Uses a Background Operation</span></span>](../../../docs/framework/winforms/controls/how-to-implement-a-form-that-uses-a-background-operation.md)
- [<span data-ttu-id="30fa0-175">Modèle asynchrone basé sur les événements (EAP)</span><span class="sxs-lookup"><span data-stu-id="30fa0-175">Event-based Asynchronous Pattern (EAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md)
- [<span data-ttu-id="30fa0-176">Meilleures pratiques pour implémenter le modèle asynchrone basé sur les événements</span><span class="sxs-lookup"><span data-stu-id="30fa0-176">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="30fa0-177">Choix du moment auquel implémenter le modèle asynchrone basé sur les événements</span><span class="sxs-lookup"><span data-stu-id="30fa0-177">Deciding When to Implement the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)
