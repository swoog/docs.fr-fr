---
title: Architectures courantes des applications web
description: Architecturer des applications web modernes avec ASP.NET Core et Azure | Explorer les architectures courantes des applications web
author: ardalis
ms.author: wiwagn
ms.date: 06/28/2018
ms.openlocfilehash: 3b0b109b0910eb5763ecab228115b7bc932d4a10
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/10/2018
ms.locfileid: "53129933"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="e4907-103">Architectures courantes des applications web</span><span class="sxs-lookup"><span data-stu-id="e4907-103">Common web application architectures</span></span>

> <span data-ttu-id="e4907-104">« Si vous pensez qu’une bonne architecture est coûteuse, faites l’expérience d’une mauvaise architecture. »</span><span class="sxs-lookup"><span data-stu-id="e4907-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="e4907-105">_- Brian Foote et Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="e4907-105">_- Brian Foote and Joseph Yoder_</span></span>

<span data-ttu-id="e4907-106">La plupart des applications .NET conventionnelles sont déployées sous forme d’unités individuelles qui correspondent à un exécutable ou à une application web unique s’exécutant dans un seul domaine d’application IIS.</span><span class="sxs-lookup"><span data-stu-id="e4907-106">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="e4907-107">C’est le modèle de déploiement le plus simple, qui convient parfaitement à beaucoup d’applications internes et applications publiques de petite taille.</span><span class="sxs-lookup"><span data-stu-id="e4907-107">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="e4907-108">Toutefois, même avec ce déploiement en unités individuelles, la majorité des applications métier non triviales tirent avantage à avoir leur logique séparée en plusieurs couches.</span><span class="sxs-lookup"><span data-stu-id="e4907-108">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="e4907-109">Qu’est-ce qu’une application monolithique ?</span><span class="sxs-lookup"><span data-stu-id="e4907-109">What is a monolithic application?</span></span>

<span data-ttu-id="e4907-110">Une application monolithique est une application qui se comporte de façon totalement autonome.</span><span class="sxs-lookup"><span data-stu-id="e4907-110">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="e4907-111">Elle peut avoir des interactions avec d’autres services ou magasins de données pendant son exécution, mais son comportement est fondamentalement géré en interne. L’ensemble de l’application est généralement déployée comme une seule unité.</span><span class="sxs-lookup"><span data-stu-id="e4907-111">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="e4907-112">Quand une application monolithique doit faire l’objet d’une mise à l’échelle horizontale, en général, l’application entière est dupliquée sur plusieurs serveurs ou machines virtuelles.</span><span class="sxs-lookup"><span data-stu-id="e4907-112">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="e4907-113">Applications tout-en-un</span><span class="sxs-lookup"><span data-stu-id="e4907-113">All-in-one applications</span></span>

<span data-ttu-id="e4907-114">L’architecture d’une application peut se réduire à un seul projet.</span><span class="sxs-lookup"><span data-stu-id="e4907-114">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="e4907-115">Dans cette architecture, toute la logique de l’application est contenue dans un seul projet, compilé dans un assembly unique et déployé comme une seule unité.</span><span class="sxs-lookup"><span data-stu-id="e4907-115">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="e4907-116">Tout nouveau projet ASP.NET Core, créé dans Visual Studio ou à partir de la ligne de commande, est au début une simple application monolithique « tout-en-un ».</span><span class="sxs-lookup"><span data-stu-id="e4907-116">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="e4907-117">Le projet contient le comportement complet de l’application, y compris la logique de présentation, métier et d’accès aux données.</span><span class="sxs-lookup"><span data-stu-id="e4907-117">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="e4907-118">La figure 5-1 montre la structure de fichiers d’une application à projet unique.</span><span class="sxs-lookup"><span data-stu-id="e4907-118">Figure 5-1 shows the file structure of a single-project app.</span></span>

![](./media/image5-1.png)

<span data-ttu-id="e4907-119">**Figure 5-1.**</span><span class="sxs-lookup"><span data-stu-id="e4907-119">**Figure 5-1.**</span></span> <span data-ttu-id="e4907-120">Application ASP.NET Core à projet unique.</span><span class="sxs-lookup"><span data-stu-id="e4907-120">A single project ASP.NET Core app.</span></span>

<span data-ttu-id="e4907-121">Dans un scénario de projet unique, la séparation des préoccupations s’obtient par l’utilisation de dossiers.</span><span class="sxs-lookup"><span data-stu-id="e4907-121">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="e4907-122">Le modèle par défaut inclut des dossiers distincts pour les responsabilités des modèles, vues et contrôleurs du schéma MVC, ainsi que des dossiers supplémentaires pour les services et les données.</span><span class="sxs-lookup"><span data-stu-id="e4907-122">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="e4907-123">Dans cette organisation, les détails de présentation doivent être limités autant que possible au dossier Vues, et les détails d’implémentation de l’accès aux données doivent être limités aux classes stockées dans le dossier Données.</span><span class="sxs-lookup"><span data-stu-id="e4907-123">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="e4907-124">La logique métier doit résider dans les services et les classes contenus dans le dossier Modèles.</span><span class="sxs-lookup"><span data-stu-id="e4907-124">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="e4907-125">La solution monolithique à projet unique est simple, mais elle présente certains inconvénients.</span><span class="sxs-lookup"><span data-stu-id="e4907-125">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="e4907-126">Le nombre de fichiers et de dossiers augmente à mesure que le projet grossit et devient plus complexe.</span><span class="sxs-lookup"><span data-stu-id="e4907-126">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="e4907-127">Les éléments sensibles de l’interface utilisateur (modèles, vues, contrôleurs) résident dans plusieurs dossiers qui ne sont pas regroupés par ordre alphabétique.</span><span class="sxs-lookup"><span data-stu-id="e4907-127">User interface (UI) concerns (models, views, controllers) reside in multiple folders, which aren't grouped together alphabetically.</span></span> <span data-ttu-id="e4907-128">Cela devient un réel problème quand des constructions de niveau interface utilisateur supplémentaires, telles que des filtres ou des classeurs de modèles (ModelBinder), sont ajoutées dans leurs propres dossiers.</span><span class="sxs-lookup"><span data-stu-id="e4907-128">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="e4907-129">La logique métier est répartie entre les dossiers Models et Services, mais les dépendances entre les classes contenues dans ces dossiers ne sont pas clairement indiquées.</span><span class="sxs-lookup"><span data-stu-id="e4907-129">Business logic is scattered between the Models and Services folders, and there's no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="e4907-130">Cette mauvaise organisation au niveau du projet se traduit fréquemment par la création de [code spaghetti](https://deviq.com/spaghetti-code/).</span><span class="sxs-lookup"><span data-stu-id="e4907-130">This lack of organization at the project level frequently leads to [spaghetti code](https://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="e4907-131">Pour résoudre ces problèmes, les applications se transforment souvent en solutions à projets multiples, où chaque projet est censé résider dans une _couche_ spécifique de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-131">To address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular _layer_ of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="e4907-132">Qu’est-ce qu’une architecture en couches ?</span><span class="sxs-lookup"><span data-stu-id="e4907-132">What are layers?</span></span>

<span data-ttu-id="e4907-133">Quand une application devient complexe, un moyen de gérer cette complexité est de scinder l’application selon ses responsabilités ou préoccupations.</span><span class="sxs-lookup"><span data-stu-id="e4907-133">As applications grow in complexity, one way to manage that complexity is to break up the application according to its responsibilities or concerns.</span></span> <span data-ttu-id="e4907-134">Basée sur le principe de séparation des préoccupations, cette solution contribue à maintenir le code base parfaitement organisé à mesure qu’il grossit, ce qui permet aux développeurs de retrouver facilement les fonctionnalités implémentées.</span><span class="sxs-lookup"><span data-stu-id="e4907-134">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="e4907-135">L’architecture en couches offre d’autres avantages que la simple organisation du code.</span><span class="sxs-lookup"><span data-stu-id="e4907-135">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="e4907-136">En effet, l’organisation du code en couches permet également la réutilisation des fonctionnalités communes de bas niveau dans l’ensemble de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-136">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="e4907-137">Cette possibilité est intéressante, car elle réduit la quantité de code à écrire et permet la standardisation de l’application sur une implémentation unique, selon le principe [DRY (« Ne vous répétez pas »)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself).</span><span class="sxs-lookup"><span data-stu-id="e4907-137">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the [don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.</span></span>

<span data-ttu-id="e4907-138">Avec une architecture en couches, les applications peuvent appliquer des restrictions sur les échanges autorisés entre les différentes couches.</span><span class="sxs-lookup"><span data-stu-id="e4907-138">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="e4907-139">Cela contribue à améliorer l’encapsulation.</span><span class="sxs-lookup"><span data-stu-id="e4907-139">This helps to achieve encapsulation.</span></span> <span data-ttu-id="e4907-140">De cette façon, quand une couche est modifiée ou remplacée, seules les couches qui interagissent avec elle sont impactées.</span><span class="sxs-lookup"><span data-stu-id="e4907-140">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="e4907-141">En limitant l’interdépendance des couches, l’impact des modifications peut être atténué afin qu’une modification donnée n’impacte pas l’application entière.</span><span class="sxs-lookup"><span data-stu-id="e4907-141">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="e4907-142">Les couches (et l’encapsulation) facilitent le remplacement des fonctionnalités dans l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-142">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="e4907-143">Par exemple, une application peut initialement utiliser sa propre base de données SQL Server pour la persistance, mais plus tard choisir d’utiliser une stratégie de persistance basée sur le cloud ou située derrière une API web.</span><span class="sxs-lookup"><span data-stu-id="e4907-143">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="e4907-144">Si l’application a correctement encapsulé son implémentation de persistance au sein d’une couche logique, cette couche spécifique de SQL Server peut être remplacée par une nouvelle couche qui implémente la même interface publique.</span><span class="sxs-lookup"><span data-stu-id="e4907-144">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="e4907-145">Outre la possibilité de permuter des implémentations en réponse à des changements ultérieurs dans les exigences, les couches d’application facilitent également la permutation des implémentations pour les besoins de test.</span><span class="sxs-lookup"><span data-stu-id="e4907-145">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="e4907-146">Au lieu d’écrire des tests qui s’exécutent sur la couche des données réelles ou sur la couche de l’interface utilisateur de l’application, vous pouvez remplacer ces couches durant la phase de test par des implémentations fictives qui fournissent des réponses connues aux requêtes.</span><span class="sxs-lookup"><span data-stu-id="e4907-146">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="e4907-147">Cette possibilité simplifie considérablement l’écriture des tests et rend leur exécution beaucoup plus rapide par rapport à l’exécution de tests dans l’infrastructure réelle de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-147">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="e4907-148">La mise en couches logiques est une technique courante pour améliorer l’organisation du code dans les applications d’entreprise. Le code peut être organisé en couches de plusieurs façons.</span><span class="sxs-lookup"><span data-stu-id="e4907-148">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
 > <span data-ttu-id="e4907-149">Les _couches_ représentent une séparation logique au sein de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-149">_Layers_ represent logical separation within the application.</span></span> <span data-ttu-id="e4907-150">Si la logique de l’application est répartie physiquement entre plusieurs serveurs ou processus séparés, ces différentes cibles de déploiement physiques sont appelées _niveaux_.</span><span class="sxs-lookup"><span data-stu-id="e4907-150">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as _tiers_.</span></span> <span data-ttu-id="e4907-151">Il est possible, et relativement courant, de déployer une application en N couches sur un seul niveau.</span><span class="sxs-lookup"><span data-stu-id="e4907-151">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="e4907-152">Applications avec une architecture en N couches conventionnelle</span><span class="sxs-lookup"><span data-stu-id="e4907-152">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="e4907-153">La figure 5-2 illustre l’organisation la plus courante d’une logique d’application en couches.</span><span class="sxs-lookup"><span data-stu-id="e4907-153">The most common organization of application logic into layers is shown in Figure 5-2.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="e4907-154">**Figure 5-2.**</span><span class="sxs-lookup"><span data-stu-id="e4907-154">**Figure 5-2.**</span></span> <span data-ttu-id="e4907-155">Couches d’application classiques.</span><span class="sxs-lookup"><span data-stu-id="e4907-155">Typical application layers.</span></span>

<span data-ttu-id="e4907-156">Ces couches sont souvent abrégées comme ceci : UI (couche d’interface utilisateur), BLL (couche métier) et DAL (couche d’accès aux données).</span><span class="sxs-lookup"><span data-stu-id="e4907-156">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="e4907-157">Avec cette architecture, les utilisateurs effectuent des requêtes par le biais de la couche UI, qui interagit uniquement avec la couche BLL.</span><span class="sxs-lookup"><span data-stu-id="e4907-157">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="e4907-158">La couche BLL, à son tour, peut appeler la couche DAL pour les requêtes d’accès aux données.</span><span class="sxs-lookup"><span data-stu-id="e4907-158">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="e4907-159">La couche UI ne doit pas directement adresser des requêtes à la couche DAL, ni interagir avec persistance directement par d’autres moyens.</span><span class="sxs-lookup"><span data-stu-id="e4907-159">The UI layer shouldn't make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="e4907-160">De même, la couche BLL doit uniquement interagir avec persistance en passant par la couche DAL.</span><span class="sxs-lookup"><span data-stu-id="e4907-160">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="e4907-161">De cette manière, chaque couche a sa propre responsabilité connue.</span><span class="sxs-lookup"><span data-stu-id="e4907-161">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="e4907-162">Cette approche en couches classique a un inconvénient, à savoir que les dépendances de compilation s’exécutent de haut en bas.</span><span class="sxs-lookup"><span data-stu-id="e4907-162">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="e4907-163">Autrement dit, la couche UI dépend de la couche BLL, qui dépend elle-même de la couche DAL.</span><span class="sxs-lookup"><span data-stu-id="e4907-163">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="e4907-164">La couche BLL, qui contient généralement la logique la plus importante de l’application, est dépendante des détails d’implémentation de l’accès aux données (et souvent de l’existence d’une base de données).</span><span class="sxs-lookup"><span data-stu-id="e4907-164">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="e4907-165">Il est souvent difficile de tester la logique métier dans ce type d’architecture, car il faut utiliser une base de données de test.</span><span class="sxs-lookup"><span data-stu-id="e4907-165">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="e4907-166">Le principe d’inversion des dépendances peut être une solution à ce problème, comme vous le verrez dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="e4907-166">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="e4907-167">La figure 5-3 montre un exemple de solution qui scinde l’application en trois projets par responsabilité (ou couche).</span><span class="sxs-lookup"><span data-stu-id="e4907-167">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

![](./media/image5-3.png)

<span data-ttu-id="e4907-168">**Figure 5-3.**</span><span class="sxs-lookup"><span data-stu-id="e4907-168">**Figure 5-3.**</span></span> <span data-ttu-id="e4907-169">Application monolithique simple constituée de trois projets.</span><span class="sxs-lookup"><span data-stu-id="e4907-169">A simple monolithic application with three projects.</span></span>

<span data-ttu-id="e4907-170">Même si cette application utilise plusieurs projets à des fins d’organisation, elle reste déployée en tant qu’unité simple et ses clients interagissent avec elle en la considérant comme une application web unique.</span><span class="sxs-lookup"><span data-stu-id="e4907-170">Although this application uses several projects for organizational purposes, it's still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="e4907-171">Cela simplifie nettement le processus de déploiement.</span><span class="sxs-lookup"><span data-stu-id="e4907-171">This allows for very simple deployment process.</span></span> <span data-ttu-id="e4907-172">La figure 5-4 montre comment une application de ce type peut être hébergée en utilisant Azure.</span><span class="sxs-lookup"><span data-stu-id="e4907-172">Figure 5-4 shows how such an app might be hosted using Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="e4907-173">**Figure 5-4.**</span><span class="sxs-lookup"><span data-stu-id="e4907-173">**Figure 5-4.**</span></span> <span data-ttu-id="e4907-174">Déploiement simple d’une application web Azure</span><span class="sxs-lookup"><span data-stu-id="e4907-174">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="e4907-175">Quand l’application doit grossir, des solutions de déploiement plus complexes et robustes peuvent être nécessaires.</span><span class="sxs-lookup"><span data-stu-id="e4907-175">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="e4907-176">La figure 5-5 montre un exemple de plan de déploiement plus complexe qui prend en charge des fonctionnalités supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="e4907-176">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="e4907-177">**Figure 5-5.**</span><span class="sxs-lookup"><span data-stu-id="e4907-177">**Figure 5-5.**</span></span> <span data-ttu-id="e4907-178">Déploiement d’une application web sur Azure App Service</span><span class="sxs-lookup"><span data-stu-id="e4907-178">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="e4907-179">En interne, l’organisation de ce projet en plusieurs projets par responsabilité facilite la maintenance de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-179">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="e4907-180">Il est possible d’augmenter ou de diminuer la taille des instances de cette unité pour tirer parti de l’extensibilité à la demande sur le cloud.</span><span class="sxs-lookup"><span data-stu-id="e4907-180">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="e4907-181">L’augmentation de la taille des instances revient à ajouter de l’UC, de la mémoire, de l’espace disque ou d’autres ressources sur le ou les serveurs qui hébergent votre application.</span><span class="sxs-lookup"><span data-stu-id="e4907-181">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="e4907-182">La diminution de la taille des instances revient à ajouter des instances supplémentaires de ces serveurs (physiques ou virtuels).</span><span class="sxs-lookup"><span data-stu-id="e4907-182">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="e4907-183">Quand votre application est hébergée sur plusieurs instances, un équilibreur de charge assigne les requêtes aux différentes instances de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-183">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="e4907-184">L’approche la plus simple pour mettre à l’échelle une application web dans Azure est de configurer la mise à l’échelle manuellement dans le plan App Service de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-184">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="e4907-185">La figure 5-6 illustre le tableau de bord Azure qui permet de configurer le nombre d’instances au service d’une application.</span><span class="sxs-lookup"><span data-stu-id="e4907-185">Figure 5-6 shows the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="e4907-186">**Figure 5-6.**</span><span class="sxs-lookup"><span data-stu-id="e4907-186">**Figure 5-6.**</span></span> <span data-ttu-id="e4907-187">Mise à l’échelle du plan App Service dans Azure.</span><span class="sxs-lookup"><span data-stu-id="e4907-187">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="e4907-188">Architecture propre</span><span class="sxs-lookup"><span data-stu-id="e4907-188">Clean architecture</span></span>

<span data-ttu-id="e4907-189">Les applications conçues selon le principe d’inversion des dépendances et les principes DDD (conception pilotée par le domaine) présentent au final plus ou moins la même architecture.</span><span class="sxs-lookup"><span data-stu-id="e4907-189">Applications that follow the Dependency Inversion Principle as well as the Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="e4907-190">Les noms donnés à cette architecture ont beaucoup varié au fil des années.</span><span class="sxs-lookup"><span data-stu-id="e4907-190">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="e4907-191">Au début, on l’a nommée architecture hexagonale, puis architecture ports-adaptateurs.</span><span class="sxs-lookup"><span data-stu-id="e4907-191">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="e4907-192">Plus récemment, on l’a appelée [architecture en oignon](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) ou [architecture propre](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="e4907-192">More recently, it's been cited as the [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="e4907-193">Cette dernière désignation, architecture propre, est celle utilisée pour qualifier l’architecture utilisée dans ce livre électronique.</span><span class="sxs-lookup"><span data-stu-id="e4907-193">The latter name, Clean Architecture, is used as the name for this architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="e4907-194">Ce terme s’applique aussi bien aux applications conçues selon les principes DDD qu’à celles qui ne le sont pas.</span><span class="sxs-lookup"><span data-stu-id="e4907-194">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="e4907-195">Les premières peuvent être désignées sous le terme combiné « architecture DDD propre ».</span><span class="sxs-lookup"><span data-stu-id="e4907-195">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="e4907-196">L’architecture propre met la logique métier et le modèle d’application au centre même de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-196">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="e4907-197">Au lieu que la logique métier dépende des préoccupations de l’accès aux données ou d’une autre infrastructure, cette dépendance est inversée : les détails de l’infrastructure et de l’implémentation dépendent du noyau de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-197">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="e4907-198">Cela s’obtient par la définition d’abstractions, ou interfaces, dans la couche Noyau de l’application, lesquels sont ensuite implémentés par les types définis dans la couche Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="e4907-198">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="e4907-199">Cette architecture est souvent représentée sous la forme d’une série de cercles concentriques, à l’image des couches d’un oignon.</span><span class="sxs-lookup"><span data-stu-id="e4907-199">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="e4907-200">La figure 5-7 montre un exemple de ce style de représentation architecturale.</span><span class="sxs-lookup"><span data-stu-id="e4907-200">Figure 5-7 shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="e4907-201">**Figure 5-7.**</span><span class="sxs-lookup"><span data-stu-id="e4907-201">**Figure 5-7.**</span></span> <span data-ttu-id="e4907-202">Architecture propre ; représentation des couches en oignon</span><span class="sxs-lookup"><span data-stu-id="e4907-202">Clean Architecture; onion view</span></span>

<span data-ttu-id="e4907-203">Dans ce diagramme, le flux des dépendances va du cercle extérieur vers le cercle le plus intérieur.</span><span class="sxs-lookup"><span data-stu-id="e4907-203">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="e4907-204">La couche Noyau de l’application tire son nom de sa position au cœur de ce diagramme.</span><span class="sxs-lookup"><span data-stu-id="e4907-204">The Application Core takes its name from its position at the core of this diagram.</span></span> <span data-ttu-id="e4907-205">Par ailleurs, comme vous pouvez constater sur le diagramme, la couche Noyau de l’application n’a aucune dépendance vis-à-vis des autres couches de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-205">And you can see on the diagram that the Application Core has no dependencies on other application layers.</span></span> <span data-ttu-id="e4907-206">Les entités et les interfaces de l’application se trouvent au centre même du diagramme.</span><span class="sxs-lookup"><span data-stu-id="e4907-206">The application's entities and interfaces are at the very center.</span></span> <span data-ttu-id="e4907-207">Juste après vers l’extérieur, mais toujours dans la couche Noyau de l’application, viennent les services de domaine, qui implémentent généralement les interfaces définies dans le cercle central.</span><span class="sxs-lookup"><span data-stu-id="e4907-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="e4907-208">À l’extérieur de la couche Noyau de l’application, les couches Interface utilisateur et Infrastructure dépendent toutes deux de la couche Noyau de l’application, mais elles ne dépendent pas (nécessairement) l’une de l’autre.</span><span class="sxs-lookup"><span data-stu-id="e4907-208">Outside of the Application Core, both the UI and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="e4907-209">La figure 5-8-X illustre un diagramme de couches horizontal plus classique, qui reflète mieux la dépendance entre la couche Interface utilisateur et les autres couches.</span><span class="sxs-lookup"><span data-stu-id="e4907-209">Figure 5-8 shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="e4907-210">**Figure 5-8.**</span><span class="sxs-lookup"><span data-stu-id="e4907-210">**Figure 5-8.**</span></span> <span data-ttu-id="e4907-211">Architecture propre ; représentation horizontale des couches</span><span class="sxs-lookup"><span data-stu-id="e4907-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="e4907-212">Notez que les flèches pleines représentent les dépendances à la compilation, tandis que la flèche en pointillé représente une dépendance à l’exécution uniquement.</span><span class="sxs-lookup"><span data-stu-id="e4907-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="e4907-213">Dans une architecture propre, la couche Interface utilisateur interagit avec les interfaces définies dans la couche Noyau de l’application au moment de la compilation. Dans l’idéal, elle ne doit pas avoir connaissance des types d’implémentation définis dans la couche Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="e4907-213">With the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally shouldn't know about the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="e4907-214">Or, au moment de l’exécution, ces types d’implémentation sont nécessaires à l’exécution de l’application. Ils doivent donc être définis et transmis aux interfaces de la couche Noyau de l’application via l’injection de dépendances.</span><span class="sxs-lookup"><span data-stu-id="e4907-214">At run time, however, these implementation types are required for the app to execute, so they need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="e4907-215">La figure 5-9 est une représentation plus détaillée de l’architecture d’une application ASP.NET Core conçue selon ces recommandations.</span><span class="sxs-lookup"><span data-stu-id="e4907-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![Architecture ASPNET Core](./media/image5-9.png)

<span data-ttu-id="e4907-217">**Figure 5-9**.</span><span class="sxs-lookup"><span data-stu-id="e4907-217">**Figure 5-9.**</span></span> <span data-ttu-id="e4907-218">Diagramme d’une architecture ASP.NET Core propre.</span><span class="sxs-lookup"><span data-stu-id="e4907-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="e4907-219">Comme la couche Noyau de l’application ne dépend pas de la couche Infrastructure, il est très facile d’écrire des tests unitaires automatisés pour cette couche.</span><span class="sxs-lookup"><span data-stu-id="e4907-219">Because the Application Core doesn't depend on Infrastructure, it's very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="e4907-220">Les figures 5-10 et 5-11 montrent comment les tests s’intègrent à cette architecture.</span><span class="sxs-lookup"><span data-stu-id="e4907-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="e4907-222">**Figure 5-10.**</span><span class="sxs-lookup"><span data-stu-id="e4907-222">**Figure 5-10.**</span></span> <span data-ttu-id="e4907-223">Tests unitaires, couche Noyau de l’application isolée.</span><span class="sxs-lookup"><span data-stu-id="e4907-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="e4907-225">**Figure 5-11.**</span><span class="sxs-lookup"><span data-stu-id="e4907-225">**Figure 5-11.**</span></span> <span data-ttu-id="e4907-226">Tests d’intégration, implémentations dans Infrastructure avec des dépendances externes.</span><span class="sxs-lookup"><span data-stu-id="e4907-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="e4907-227">Comme la couche Interface utilisateur n’a pas de dépendance directe vis-à-vis des types définis dans le projet Infrastructure, il est tout aussi simple de permuter les implémentations, que ce soit pour faciliter les tests ou pour répondre à une évolution des exigences de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it's likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="e4907-228">Grâce à la prise en charge et à l’utilisation intégrée de l’injection de dépendances dans une application ASP.NET Core, cette architecture est la plus performante pour organiser des applications monolithiques non triviales.</span><span class="sxs-lookup"><span data-stu-id="e4907-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="e4907-229">Dans les applications monolithiques, les projets Noyau de l’application, Infrastructure et Interface utilisateur sont tous exécutés comme une seule application.</span><span class="sxs-lookup"><span data-stu-id="e4907-229">For monolithic applications the Application Core, Infrastructure, and UI projects are all run as a single application.</span></span> <span data-ttu-id="e4907-230">La figure 5-12 illustre un exemple d’architecture d’exécution d’une application.</span><span class="sxs-lookup"><span data-stu-id="e4907-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![Architecture ASPNET Core 2](./media/image5-12.png)

<span data-ttu-id="e4907-232">**Figure 5-12.**</span><span class="sxs-lookup"><span data-stu-id="e4907-232">**Figure 5-12.**</span></span> <span data-ttu-id="e4907-233">Exemple d’architecture d’exécution d’une application ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="e4907-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="e4907-234">Organisation du code dans une architecture propre</span><span class="sxs-lookup"><span data-stu-id="e4907-234">Organizing code in Clean Architecture</span></span>

<span data-ttu-id="e4907-235">Dans une architecture propre, les responsabilités de chaque projet sont clairement établies.</span><span class="sxs-lookup"><span data-stu-id="e4907-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="e4907-236">À cet effet, certains types sont communs à chaque projet et vous trouverez souvent plusieurs dossiers correspondant à ces types dans le projet en question.</span><span class="sxs-lookup"><span data-stu-id="e4907-236">As such, certain types belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="e4907-237">La couche Noyau de l’application contient le modèle métier, qui définit les entités, les services et les interfaces.</span><span class="sxs-lookup"><span data-stu-id="e4907-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="e4907-238">Ces interfaces renferment les abstractions des opérations à effectuer dans la couche Infrastructure, comme l’accès aux données, les accès au système de fichiers, les appels réseau, etc. Les services ou interfaces définis dans cette couche doivent parfois interagir avec des types qui ne sont pas des entités et qui n’ont pas de dépendance sur les couches Interface utilisateur ou Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="e4907-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="e4907-239">Ils peuvent alors être définis comme objets de transfert de données (DTO).</span><span class="sxs-lookup"><span data-stu-id="e4907-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

### <a name="application-core-types"></a><span data-ttu-id="e4907-240">Types de la couche Noyau de l’application</span><span class="sxs-lookup"><span data-stu-id="e4907-240">Application Core types</span></span>

- <span data-ttu-id="e4907-241">Entités (classes persistantes du modèle métier)</span><span class="sxs-lookup"><span data-stu-id="e4907-241">Entities (business model classes that are persisted)</span></span>
- <span data-ttu-id="e4907-242">Interfaces</span><span class="sxs-lookup"><span data-stu-id="e4907-242">Interfaces</span></span>
- <span data-ttu-id="e4907-243">Services</span><span class="sxs-lookup"><span data-stu-id="e4907-243">Services</span></span>
- <span data-ttu-id="e4907-244">Objets DTO</span><span class="sxs-lookup"><span data-stu-id="e4907-244">DTOs</span></span>

<span data-ttu-id="e4907-245">Le projet Infrastructure inclut généralement des implémentations de l’accès aux données.</span><span class="sxs-lookup"><span data-stu-id="e4907-245">The Infrastructure project typically includes data access implementations.</span></span> <span data-ttu-id="e4907-246">Dans une application web ASP.NET Core conventionnelle, ces implémentations comprennent la classe DbContext d’Entity Framework (EF), les objets `Migration` EF Core qui ont été définis, ainsi que les classes d’implémentation de l’accès aux données.</span><span class="sxs-lookup"><span data-stu-id="e4907-246">In a typical ASP.NET Core web application, these implementations include the Entity Framework (EF) DbContext, any EF Core `Migration` objects that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="e4907-247">La méthode la plus courante pour abstraire le code d’implémentation de l’accès aux données est d’utiliser le [modèle de conception de référentiel](https://deviq.com/repository-pattern/).</span><span class="sxs-lookup"><span data-stu-id="e4907-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](https://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="e4907-248">En plus des implémentations de l’accès aux données, le projet Infrastructure doit contenir les implémentations des services qui interagissent avec les préoccupations de l’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="e4907-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="e4907-249">Ces services doivent implémenter les interfaces définies dans la couche Noyau de l’application, et la couche Infrastructure doit donc référencer le projet Noyau de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

### <a name="infrastructure-types"></a><span data-ttu-id="e4907-250">Types de la couche Infrastructure</span><span class="sxs-lookup"><span data-stu-id="e4907-250">Infrastructure types</span></span>

- <span data-ttu-id="e4907-251">Types EF Core (`DbContext`, `Migration`)</span><span class="sxs-lookup"><span data-stu-id="e4907-251">EF Core types (`DbContext`, `Migration`)</span></span>
- <span data-ttu-id="e4907-252">Types d’implémentation de l’accès aux données (référentiels)</span><span class="sxs-lookup"><span data-stu-id="e4907-252">Data access implementation types (Repositories)</span></span>
- <span data-ttu-id="e4907-253">Services spécifiques de l’infrastructure (par exemple, `FileLogger` ou `SmtpNotifier`)</span><span class="sxs-lookup"><span data-stu-id="e4907-253">Infrastructure-specific services (for example, `FileLogger` or `SmtpNotifier`)</span></span>

<span data-ttu-id="e4907-254">Dans une application ASP.NET Core MVC, la couche Interface utilisateur est le point d’entrée de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-254">The user interface layer in an ASP.NET Core MVC application is the entry point for the application.</span></span> <span data-ttu-id="e4907-255">Ce projet doit référencer le projet Noyau de l’application, et ses types doivent interagir avec l’infrastructure uniquement par le biais des interfaces définies dans la couche Noyau de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="e4907-256">Les instanciations directes des types de la couche Infrastructure (ou les appels statiques à ces types) ne doivent pas être autorisées dans la couche Interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="e4907-256">No direct instantiation of or static calls to the Infrastructure layer types should be allowed in the UI layer.</span></span>

### <a name="ui-layer-types"></a><span data-ttu-id="e4907-257">Types de la couche Interface utilisateur</span><span class="sxs-lookup"><span data-stu-id="e4907-257">UI layer types</span></span>

- <span data-ttu-id="e4907-258">Contrôleurs</span><span class="sxs-lookup"><span data-stu-id="e4907-258">Controllers</span></span>
- <span data-ttu-id="e4907-259">Filtres</span><span class="sxs-lookup"><span data-stu-id="e4907-259">Filters</span></span>
- <span data-ttu-id="e4907-260">Affichages</span><span class="sxs-lookup"><span data-stu-id="e4907-260">Views</span></span>
- <span data-ttu-id="e4907-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="e4907-261">ViewModels</span></span>
- <span data-ttu-id="e4907-262">Démarrage</span><span class="sxs-lookup"><span data-stu-id="e4907-262">Startup</span></span>

<span data-ttu-id="e4907-263">La classe Démarrage est responsable de la configuration de l’application, mais aussi de la transmission des types d’implémentation jusqu’aux interfaces, pour permettre le fonctionnement correct de l’injection de dépendances au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="e4907-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="e4907-264">Pour configurer l’injection de dépendances dans la section ConfigureServices du fichier Startup.cs associé au projet Interface utilisateur, celui-ci doit référencer le projet Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="e4907-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="e4907-265">Cette dépendance peut très facilement être supprimée en utilisant un conteneur d’injection de dépendances personnalisé.</span><span class="sxs-lookup"><span data-stu-id="e4907-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="e4907-266">Dans cet exemple, l’approche la plus simple est d’autoriser le projet Interface utilisateur à référencer le projet Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="e4907-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="e4907-267">Conteneurs et applications monolithiques</span><span class="sxs-lookup"><span data-stu-id="e4907-267">Monolithic applications and containers</span></span>

<span data-ttu-id="e4907-268">Vous pouvez créer une application (ou service) web unique et monolithique, et la déployer en tant que conteneur.</span><span class="sxs-lookup"><span data-stu-id="e4907-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="e4907-269">En interne, l’application peut ne pas être monolithique, mais être organisée en bibliothèques, composants ou couches.</span><span class="sxs-lookup"><span data-stu-id="e4907-269">Within the application, it might not be monolithic but organized into several libraries, components, or layers.</span></span> <span data-ttu-id="e4907-270">D’un point de vue externe, l’application est considérée comme un conteneur unique, de la même façon qu’un processus, une application web ou un service unique.</span><span class="sxs-lookup"><span data-stu-id="e4907-270">Externally, it's a single container like a single process, single web application, or single service.</span></span>

<span data-ttu-id="e4907-271">Pour gérer ce modèle, vous déployez un seul conteneur pour représenter l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="e4907-272">Pour effectuer une mise à l’échelle, vous ajoutez simplement des copies supplémentaires avec un équilibreur de charge en frontal.</span><span class="sxs-lookup"><span data-stu-id="e4907-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="e4907-273">Cette simplicité provient de la gestion d’un seul déploiement dans un seul conteneur ou une seule machine virtuelle.</span><span class="sxs-lookup"><span data-stu-id="e4907-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="e4907-274">Vous pouvez inclure plusieurs couches internes, composants ou bibliothèques dans chaque conteneur, comme illustré dans la figure 5-13.</span><span class="sxs-lookup"><span data-stu-id="e4907-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-13.</span></span> <span data-ttu-id="e4907-275">Cependant, d’après le principe des conteneurs selon lequel « _un conteneur fait une chose et la fait dans un seul processus_ », ce modèle monolithique peut être une source de conflit.</span><span class="sxs-lookup"><span data-stu-id="e4907-275">But, following the container principle of _"a container does one thing, and does it in one process_", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="e4907-276">Cette approche présente des inconvénients si/quand l’application grandit, nécessitant sa mise à l’échelle.</span><span class="sxs-lookup"><span data-stu-id="e4907-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="e4907-277">Si l’application entière est mise à l’échelle, cela n’est pas vraiment un problème.</span><span class="sxs-lookup"><span data-stu-id="e4907-277">If the entire application scales, it's not really a problem.</span></span> <span data-ttu-id="e4907-278">Toutefois, dans la plupart des cas, la mise à l’échelle est nécessaire pour quelques parties de l’application seulement, mais elle est inutile pour d’autres composants moins utilisés.</span><span class="sxs-lookup"><span data-stu-id="e4907-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="e4907-279">Dans l’exemple classique du commerce électronique, c’est probablement le composant des informations produit qui a le plus besoin d’être mis à l’échelle.</span><span class="sxs-lookup"><span data-stu-id="e4907-279">Using the typical eCommerce example, what you likely need to scale is the product information component.</span></span> <span data-ttu-id="e4907-280">Les clients qui recherchent des produits sont beaucoup plus nombreux que ceux qui en achètent.</span><span class="sxs-lookup"><span data-stu-id="e4907-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="e4907-281">Plus de clients utilisent leur panier d’achat que ceux qui utilisent le pipeline de paiement.</span><span class="sxs-lookup"><span data-stu-id="e4907-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="e4907-282">Moins de clients ajoutent des commentaires ou consultent leur historique d’achat.</span><span class="sxs-lookup"><span data-stu-id="e4907-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="e4907-283">De même, seule une poignée d’employés, d’une seule région, doivent généralement gérer le contenu et les campagnes marketing.</span><span class="sxs-lookup"><span data-stu-id="e4907-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="e4907-284">La mise à l’échelle de la conception monolithique déploie tout le code plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="e4907-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="e4907-285">En plus du problème de la mise à l’échelle globale, quand des modifications sont apportées à un seul composant, il faut refaire un test complet de l’application entière et redéployer intégralement toutes les instances.</span><span class="sxs-lookup"><span data-stu-id="e4907-285">In addition to the "scale everything" problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="e4907-286">L’approche architecturale monolithique est fréquemment choisie pour le développement dans les organisations.</span><span class="sxs-lookup"><span data-stu-id="e4907-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="e4907-287">Beaucoup de ces organisations sont satisfaites des résultats obtenus, mais certaines se heurtent aux limites de ce modèle d’architecture.</span><span class="sxs-lookup"><span data-stu-id="e4907-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="e4907-288">Les organisations ont souvent conçu leurs applications d’après ce modèle, car les outils et l’infrastructure étaient trop complexes pour concevoir des architectures orientées services (SOA). Par ailleurs, elles ne voyaient pas la nécessité de changer de modèle tant que leur application ne grossissait pas trop.</span><span class="sxs-lookup"><span data-stu-id="e4907-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service-oriented architectures (SOA), and they didn't see the need until the app grew.</span></span> <span data-ttu-id="e4907-289">Si vous vous heurtez aux limites de l’approche monolithique, la prochaine étape logique pour vous est peut-être de scinder votre application pour mieux tirer parti des conteneurs et des microservices.</span><span class="sxs-lookup"><span data-stu-id="e4907-289">If you find you're hitting the limits of the monolithic approach, breaking up the app to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="e4907-290">Le déploiement d’applications monolithiques dans Microsoft Azure est possible en utilisant des machines virtuelles dédiées pour chaque instance.</span><span class="sxs-lookup"><span data-stu-id="e4907-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="e4907-291">Avec [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), vous pouvez facilement mettre à l’échelle les machines virtuelles.</span><span class="sxs-lookup"><span data-stu-id="e4907-291">Using [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="e4907-292">[Azure App Service](https://azure.microsoft.com/services/app-service/) peut également exécuter des applications monolithiques et facilement mettre à l’échelle des instances sans nécessiter une gestion des machines virtuelles.</span><span class="sxs-lookup"><span data-stu-id="e4907-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="e4907-293">Azure App Service peut également exécuter des instances uniques de conteneurs Docker, ce qui simplifie le déploiement.</span><span class="sxs-lookup"><span data-stu-id="e4907-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="e4907-294">Avec Docker, vous pouvez déployer une seule machine virtuelle comme hôte Docker et exécuter plusieurs instances.</span><span class="sxs-lookup"><span data-stu-id="e4907-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="e4907-295">Vous pouvez gérer la mise à l’échelle à l’aide de l’équilibreur de charge Azure, comme indiqué dans la figure 5-14.</span><span class="sxs-lookup"><span data-stu-id="e4907-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="e4907-296">Le déploiement sur les différents hôtes peut être géré avec les techniques de déploiement traditionnelles.</span><span class="sxs-lookup"><span data-stu-id="e4907-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="e4907-297">Les hôtes Docker peuvent être gérés à l’aide de commandes exécutées manuellement, telles que **docker run**, ou de manière automatisée, comme les pipelines de livraison continue.</span><span class="sxs-lookup"><span data-stu-id="e4907-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="e4907-298">Application monolithique déployée comme conteneur</span><span class="sxs-lookup"><span data-stu-id="e4907-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="e4907-299">L’utilisation de conteneurs pour gérer les déploiements d’applications monolithiques présente des avantages.</span><span class="sxs-lookup"><span data-stu-id="e4907-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="e4907-300">La mise à l’échelle des instances des conteneurs est beaucoup plus rapide et facile que le déploiement de machines virtuelles supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="e4907-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="e4907-301">Même si vous utilisez des groupes de machines virtuelles identiques pour mettre à l’échelle des machines virtuelles, leur instanciation prend du temps.</span><span class="sxs-lookup"><span data-stu-id="e4907-301">Even when using virtual machine scale sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="e4907-302">Quand une machine virtuelle est déployée en tant qu’instance de l’application, la configuration de l’application est gérée en interne par la machine virtuelle.</span><span class="sxs-lookup"><span data-stu-id="e4907-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="e4907-303">Le déploiement de mises à jour comme images Docker est beaucoup plus rapide et efficace du point de vue du réseau.</span><span class="sxs-lookup"><span data-stu-id="e4907-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="e4907-304">Les images Docker démarrent généralement en quelques secondes, ce qui accélère les lancements.</span><span class="sxs-lookup"><span data-stu-id="e4907-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="e4907-305">La suppression d’une instance Docker se fait simplement en exécutant une commande `docker stop`. Cette opération prend normalement moins d’une seconde.</span><span class="sxs-lookup"><span data-stu-id="e4907-305">Tearing down a Docker instance is as easy as issuing a `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="e4907-306">Comme les conteneurs sont immuables de par leur conception même, il n’y a pas de risques d’endommagement des machines virtuelles, au contraire des scripts de mise à jour qui peuvent oublier de prendre en compte une configuration ou un fichier spécifique sur le disque.</span><span class="sxs-lookup"><span data-stu-id="e4907-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="e4907-307">_Vous pouvez utiliser des conteneurs Docker pour effectuer un déploiement monolithique d’applications web simples. Cela a pour effet d’améliorer les pipelines d’intégration continue et de déploiement continu et cela contribuer à la réussite du déploiement en production. Fini les « Comment cela se fait-il que cela fonctionne sur ma machine, mais pas en production ? »_</span><span class="sxs-lookup"><span data-stu-id="e4907-307">_You can use Docker containers for monolithic deployment of simpler web applications. This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success. No more “It works in my machine, why does it not work in production?”_</span></span>

<span data-ttu-id="e4907-308">Une architecture basée sur des microservices présente de nombreux avantages, mais ces avantages se payent par une complexité accrue.</span><span class="sxs-lookup"><span data-stu-id="e4907-308">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="e4907-309">Dans certains cas, les inconvénients prennent le pas sur les avantages et il est préférable d’utiliser une application à déploiement monolithique s’exécutant dans un petit nombre de conteneurs, voire dans un seul conteneur.</span><span class="sxs-lookup"><span data-stu-id="e4907-309">In some cases, the costs outweigh the benefits, a monolithic deployment application running in a single container or in just a few containers is a better option.</span></span>

<span data-ttu-id="e4907-310">Il n’est pas toujours évident de décomposer une application monolithique en plusieurs microservices bien distincts.</span><span class="sxs-lookup"><span data-stu-id="e4907-310">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="e4907-311">Les microservices doivent fonctionner indépendamment les uns des autres pour optimiser la résilience de l’application.</span><span class="sxs-lookup"><span data-stu-id="e4907-311">Microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="e4907-312">Si vous ne pouvez pas proposer l’application par tranches de fonctionnalités indépendantes, la diviser ne fait qu’ajouter de la complexité.</span><span class="sxs-lookup"><span data-stu-id="e4907-312">If you can't deliver independent feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="e4907-313">Une application n’est pas pour autant nécessairement amenée à mettre à l’échelle les fonctionnalités de façon indépendante.</span><span class="sxs-lookup"><span data-stu-id="e4907-313">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="e4907-314">Bon nombre d’applications, quand elles ont besoin d’une mise à l’échelle qui va au-delà d’une instance unique, peuvent le faire par le biais du processus relativement simple de clonage intégral de cette instance.</span><span class="sxs-lookup"><span data-stu-id="e4907-314">Many applications, when they need to scale beyond a single instance, can do so through the relatively simple process of cloning that entire instance.</span></span> <span data-ttu-id="e4907-315">Le travail supplémentaire que demande la séparation de l’application en services discrets offre peu d’avantages, alors que la mise à l’échelle d’instances complètes de l’application est simple et économique.</span><span class="sxs-lookup"><span data-stu-id="e4907-315">The additional work to separate the application into discrete services provides minimal benefit when scaling full instances of the application is simple and cost-effective.</span></span>

<span data-ttu-id="e4907-316">Au stade initial du développement d’une application, vous n’avez peut-être pas une idée précise de là où se trouvent les limites fonctionnelles naturelles.</span><span class="sxs-lookup"><span data-stu-id="e4907-316">Early in the development of an application, you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="e4907-317">Même à un stade de développement où le produit est viable, il est possible que cette séparation naturelle ne se dégage toujours pas.</span><span class="sxs-lookup"><span data-stu-id="e4907-317">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span> <span data-ttu-id="e4907-318">Certaines de ces conditions peuvent être passagères.</span><span class="sxs-lookup"><span data-stu-id="e4907-318">Some of these conditions might be temporary.</span></span> <span data-ttu-id="e4907-319">Vous pouvez commencer par créer une application monolithique et séparer par la suite certaines fonctionnalités en les développant et les déployant sous forme de microservices.</span><span class="sxs-lookup"><span data-stu-id="e4907-319">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="e4907-320">D’autres conditions peuvent être essentielles à l’espace de problème de l’application, ce qui signifie que l’application risque de ne jamais être divisée en plusieurs microservices.</span><span class="sxs-lookup"><span data-stu-id="e4907-320">Other conditions might be essential to the application’s problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="e4907-321">Séparer une application en divers processus distincts induit aussi des coûts.</span><span class="sxs-lookup"><span data-stu-id="e4907-321">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="e4907-322">Il est plus complexe de séparer des fonctionnalités en différents processus.</span><span class="sxs-lookup"><span data-stu-id="e4907-322">There's more complexity in separating features into different processes.</span></span> <span data-ttu-id="e4907-323">Les protocoles de communication deviennent plus complexes.</span><span class="sxs-lookup"><span data-stu-id="e4907-323">The communication protocols become more complex.</span></span> <span data-ttu-id="e4907-324">Au lieu d’appeler des méthodes, vous devez utiliser des communications asynchrones entre les services.</span><span class="sxs-lookup"><span data-stu-id="e4907-324">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="e4907-325">Quand il s’agit de déplacer une architecture de microservices, vous devez ajouter la plupart des blocs de construction implémentés dans la version de microservices de l’application eShopOnContainers : gestion du bus d’événements, résilience des messages et nouvelles tentatives, cohérence éventuelle, etc.</span><span class="sxs-lookup"><span data-stu-id="e4907-325">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="e4907-326">L’[application de référence eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb), bien plus simple, prend en charge l’utilisation de conteneurs monolithiques uniques.</span><span class="sxs-lookup"><span data-stu-id="e4907-326">The much simpler [eShopOnWeb reference application](https://github.com/dotnet-architecture/eShopOnWeb) supports single-container monolithic container usage.</span></span> <span data-ttu-id="e4907-327">L’application comprend deux applications web : une utilisant le modèle MVC classique et une autre utilisant Razor Pages.</span><span class="sxs-lookup"><span data-stu-id="e4907-327">The application includes two web applications: one using traditional MVC and another using Razor Pages.</span></span> <span data-ttu-id="e4907-328">Les deux peuvent être lancées à partir de la racine de la solution à l’aide des commandes `docker-compose build` et `docker-compose up`.</span><span class="sxs-lookup"><span data-stu-id="e4907-328">Both can be launched from the solution root using the `docker-compose build` and `docker-compose up` commands.</span></span> <span data-ttu-id="e4907-329">Cette commande configure des conteneurs distincts pour chaque instance web, en utilisant le `Dockerfile` situé dans la racine de chaque projet web et exécute chaque conteneur sur un port distinct.</span><span class="sxs-lookup"><span data-stu-id="e4907-329">This command configures separate containers for each web instance, using the `Dockerfile` found in each web project's root, and runs each container on a separate port.</span></span> <span data-ttu-id="e4907-330">Vous pouvez télécharger la source de cette application sur GitHub et l’exécuter localement.</span><span class="sxs-lookup"><span data-stu-id="e4907-330">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="e4907-331">Même cette application monolithique gagne à être déployée dans un environnement de conteneurs.</span><span class="sxs-lookup"><span data-stu-id="e4907-331">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="e4907-332">Tout d’abord, un déploiement en conteneur signifie que chaque instance de l’application s’exécute dans le même environnement.</span><span class="sxs-lookup"><span data-stu-id="e4907-332">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="e4907-333">Cela inclut l’environnement de développement dans lequel les tests de la première heure et le développement ont été réalisés.</span><span class="sxs-lookup"><span data-stu-id="e4907-333">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="e4907-334">L’équipe de développement peut exécuter l’application dans un environnement à conteneurs qui correspond à l’environnement de production.</span><span class="sxs-lookup"><span data-stu-id="e4907-334">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="e4907-335">De plus, la montée en charge des applications en conteneur est moins coûteuse.</span><span class="sxs-lookup"><span data-stu-id="e4907-335">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="e4907-336">L’environnement à conteneurs permet un meilleur partage des ressources que les environnements à machines virtuelles classiques.</span><span class="sxs-lookup"><span data-stu-id="e4907-336">Using a container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="e4907-337">Enfin, la mise en conteneur de l’application contraint à établir une séparation entre la logique métier et le serveur de stockage.</span><span class="sxs-lookup"><span data-stu-id="e4907-337">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="e4907-338">À mesure que l’application monte en charge, les différents conteneurs dépendent tous d’un même support de stockage physique.</span><span class="sxs-lookup"><span data-stu-id="e4907-338">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="e4907-339">Il s’agit généralement d’un serveur à haute disponibilité exécutant une base de données SQL Server.</span><span class="sxs-lookup"><span data-stu-id="e4907-339">This storage medium would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="docker-support"></a><span data-ttu-id="e4907-340">Prise en charge de Docker</span><span class="sxs-lookup"><span data-stu-id="e4907-340">Docker support</span></span>

<span data-ttu-id="e4907-341">Le projet `eShopOnWeb` s’exécute sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="e4907-341">The `eShopOnWeb` project runs on .NET Core.</span></span> <span data-ttu-id="e4907-342">Par conséquent, il peut s’exécuter dans des conteneurs Linux ou Windows.</span><span class="sxs-lookup"><span data-stu-id="e4907-342">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="e4907-343">Notez que pour le déploiement de Docker, vous devez utiliser le même type d’hôte pour SQL Server.</span><span class="sxs-lookup"><span data-stu-id="e4907-343">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="e4907-344">Les conteneurs Linux offrent un plus faible encombrement et sont à privilégier.</span><span class="sxs-lookup"><span data-stu-id="e4907-344">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="e4907-345">Vous pouvez utiliser Visual Studio 2017 pour ajouter la prise en charge de Docker à une application existante en cliquant avec le bouton droit sur un projet dans l’**Explorateur de solutions** et en choisissant **Ajouter** > **Prise en charge de Docker** .</span><span class="sxs-lookup"><span data-stu-id="e4907-345">You can use Visual Studio 2017 to add Docker support to an existing application by right-clicking on a project in **Solution Explorer** and choosing **Add** > **Docker Support**.</span></span> <span data-ttu-id="e4907-346">Les fichiers nécessaires sont alors ajoutés et le projet est modifié pour pouvoir les utiliser.</span><span class="sxs-lookup"><span data-stu-id="e4907-346">This adds the files required and modifies the project to use them.</span></span> <span data-ttu-id="e4907-347">Ces fichiers sont déjà en place dans l’exemple `eShopOnWeb` actuel.</span><span class="sxs-lookup"><span data-stu-id="e4907-347">The current `eShopOnWeb` sample already has these files in place.</span></span>

<span data-ttu-id="e4907-348">Le fichier `docker-compose.yml` au niveau de la solution contient des informations sur les images à générer et les conteneurs à lancer.</span><span class="sxs-lookup"><span data-stu-id="e4907-348">The solution-level `docker-compose.yml` file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="e4907-349">Ce fichier vous permet d’utiliser la commande `docker-compose` pour lancer les deux versions de l’application web en même temps.</span><span class="sxs-lookup"><span data-stu-id="e4907-349">The file allows you to use the `docker-compose` command to launch both versions of the web application at the same time.</span></span> <span data-ttu-id="e4907-350">Vous pouvez aussi l’utiliser pour configurer des dépendances, telles qu’un conteneur de base de données distinct.</span><span class="sxs-lookup"><span data-stu-id="e4907-350">You can also use it to configure dependencies, such as a separate database container.</span></span>

```yml
version: '3'

services:
  eshopwebrazor:
    image: eshopwebrazor
    build:
      context: .
      dockerfile: src/WebRazorPages/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5107:5107"

  eshopwebmvc:
    image: eshopwebmvc
    build:
      context: .
      dockerfile: src/Web/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5106:5106"

networks:
  default:
    external:
      name: nat
```

<span data-ttu-id="e4907-351">Le fichier `docker-compose.yml` référence le `Dockerfile` dans les projets `Web` et `WebRazorPages`.</span><span class="sxs-lookup"><span data-stu-id="e4907-351">The `docker-compose.yml` file references the `Dockerfile` in the `Web` and `WebRazorPages` projects.</span></span> <span data-ttu-id="e4907-352">Le `Dockerfile` sert à spécifier le conteneur de base qui sera utilisé et la façon dont l’application sera configurée dans ce dernier.</span><span class="sxs-lookup"><span data-stu-id="e4907-352">The `Dockerfile` is used to specify which base container will be used and how the application will be configured on it.</span></span> <span data-ttu-id="e4907-353">Voici le `Dockerfile` de `WebRazorPages` :</span><span class="sxs-lookup"><span data-stu-id="e4907-353">The `WebRazorPages`' `Dockerfile`:</span></span>

```
FROM microsoft/dotnet:2.1-aspnetcore-runtime AS base
WORKDIR /app
EXPOSE 80

FROM microsoft/aspnetcore-build:2.1.300-preview1 AS build
RUN npm install -g bower@1.8.4
WORKDIR /src
COPY . .
WORKDIR /src/src/WebRazorPages
RUN dotnet restore -nowarn:msb3202,nu1503
RUN dotnet build --no-restore -c Release -o /app

FROM build AS publish
RUN dotnet publish --no-restore -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "Microsoft.eShopWeb.RazorPages.dll"]
```

### <a name="troubleshooting-docker-problems"></a><span data-ttu-id="e4907-354">Résolution des problèmes liés à Docker</span><span class="sxs-lookup"><span data-stu-id="e4907-354">Troubleshooting Docker problems</span></span>

<span data-ttu-id="e4907-355">Une fois exécutée, l’application en conteneur continue de s’exécuter jusqu’à ce que vous l’arrêtiez.</span><span class="sxs-lookup"><span data-stu-id="e4907-355">Once you run the containerized application, it continues to run until you stop it.</span></span> <span data-ttu-id="e4907-356">Vous pouvez identifier les conteneurs qui s’exécutent avec la commande `docker ps`.</span><span class="sxs-lookup"><span data-stu-id="e4907-356">You can view which containers are running with the `docker ps` command.</span></span> <span data-ttu-id="e4907-357">Vous pouvez arrêter un conteneur en cours d’exécution à l’aide de la commande `docker stop` et en spécifiant son ID.</span><span class="sxs-lookup"><span data-stu-id="e4907-357">You can stop a running container by using the `docker stop` command and specifying the container ID.</span></span>

<span data-ttu-id="e4907-358">Notez que les conteneurs Docker en cours d’exécution peuvent être liés à des ports que vous pouvez tenter d’utiliser dans votre environnement de développement.</span><span class="sxs-lookup"><span data-stu-id="e4907-358">Note that running Docker containers may be bound to ports you might otherwise try to use in your development environment.</span></span> <span data-ttu-id="e4907-359">Si vous essayez d’exécuter ou de déboguer une application en utilisant le même port qu’un conteneur Docker en cours d’exécution, vous obtiendrez une erreur indiquant que le serveur ne peut pas se lier à ce port.</span><span class="sxs-lookup"><span data-stu-id="e4907-359">If you try to run or debug an application using the same port as a running Docker container, you'll get an error stating that the server can't bind to that port.</span></span> <span data-ttu-id="e4907-360">Une fois encore, l’arrêt du conteneur devrait résoudre le problème.</span><span class="sxs-lookup"><span data-stu-id="e4907-360">Once again, stopping the container should resolve the issue.</span></span>

<span data-ttu-id="e4907-361">Si vous voulez ajouter la prise en charge de Docker à votre application à l’aide de Visual Studio, veillez à ce que Docker s’exécute pendant l’opération.</span><span class="sxs-lookup"><span data-stu-id="e4907-361">If you want to add Docker support to your application using Visual Studio, make sure Docker is running when you do so.</span></span> <span data-ttu-id="e4907-362">L’Assistant ne fonctionnera pas correctement si Docker n’est pas en cours d’exécution au moment de démarrer l’Assistant.</span><span class="sxs-lookup"><span data-stu-id="e4907-362">The wizard won't run correctly if Docker isn't running when you start the wizard.</span></span> <span data-ttu-id="e4907-363">Par ailleurs, l’Assistant examine votre choix de conteneur actuel pour ajouter la prise en charge appropriée de Docker.</span><span class="sxs-lookup"><span data-stu-id="e4907-363">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="e4907-364">Si vous voulez ajouter la prise en charge des conteneurs Windows, vous devez exécuter l’Assistant pendant que Docker s’exécute avec les conteneurs Windows configurés.</span><span class="sxs-lookup"><span data-stu-id="e4907-364">If you want to add support for Windows Containers, you need to run the wizard while you have Docker running with Windows Containers configured.</span></span> <span data-ttu-id="e4907-365">Si vous voulez ajouter la prise en charge des conteneurs Linux, exécutez l’Assistant pendant que Docker s’exécute avec les conteneurs Linux configurés.</span><span class="sxs-lookup"><span data-stu-id="e4907-365">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="e4907-366">Informations de référence sur les architectures web courantes</span><span class="sxs-lookup"><span data-stu-id="e4907-366">References – Common web architectures</span></span>
>
> - <span data-ttu-id="e4907-367">**L’architecture propre**</span><span class="sxs-lookup"><span data-stu-id="e4907-367">**The Clean Architecture**</span></span>  
>   <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - <span data-ttu-id="e4907-368">**L’architecture en oignon**</span><span class="sxs-lookup"><span data-stu-id="e4907-368">**The Onion Architecture**</span></span>  
>   <https://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - <span data-ttu-id="e4907-369">**Le modèle référentiel**</span><span class="sxs-lookup"><span data-stu-id="e4907-369">**The Repository Pattern**</span></span>  
>   <https://deviq.com/repository-pattern/>
> - <span data-ttu-id="e4907-370">**Exemple d’une solution d’architecture propre**</span><span class="sxs-lookup"><span data-stu-id="e4907-370">**Clean Architecture Solution Sample**</span></span>  
>   <https://github.com/ardalis/cleanarchitecture>
> - <span data-ttu-id="e4907-371">**Architecting Microservices (livre électronique)**</span><span class="sxs-lookup"><span data-stu-id="e4907-371">**Architecting Microservices e-book**</span></span>  
>   <https://aka.ms/MicroservicesEbook>

>[!div class="step-by-step"]
><span data-ttu-id="e4907-372">[Précédent](architectural-principles.md)
>[Suivant](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="e4907-372">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>