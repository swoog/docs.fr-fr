---
title: Bien démarrer avec l’analyse de la syntaxe (API Roslyn)
description: Une introduction à la façon de parcourir et d’interroger les arborescences de syntaxe.
author: billwagner
ms.author: wiwagn
ms.date: 02/05/2018
ms.topic: conceptual
ms.prod: .net
ms.technology: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: 90d6542122dd8c579c63f5f003441ce63a7ca5e9
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/28/2018
---
# <a name="get-started-with-syntax-analysis"></a><span data-ttu-id="496d2-103">Bien démarrer avec l’analyse de la syntaxe</span><span class="sxs-lookup"><span data-stu-id="496d2-103">Get started with syntax analysis</span></span>

<span data-ttu-id="496d2-104">Dans ce tutoriel, vous allez explorer **l’API Syntaxe**.</span><span class="sxs-lookup"><span data-stu-id="496d2-104">In this tutorial, you'll explore the **Syntax API**.</span></span> <span data-ttu-id="496d2-105">L’API Syntaxe fournit un accès aux structures de données qui décrivent un programme C# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="496d2-105">The Syntax API provides access to the data structures that describe a C# or Visual Basic program.</span></span> <span data-ttu-id="496d2-106">Ces structures de données ont suffisamment d’informations détaillées pour pouvoir représenter entièrement n’importe quel programme, quelle que soit sa taille.</span><span class="sxs-lookup"><span data-stu-id="496d2-106">These data structures have enough detail that they can fully represent any program of any size.</span></span> <span data-ttu-id="496d2-107">Ces structures peuvent décrire des programmes complets qui se compilent et s’exécutent correctement.</span><span class="sxs-lookup"><span data-stu-id="496d2-107">These structures can describe complete programs that compile and run correctly.</span></span> <span data-ttu-id="496d2-108">Elles peuvent aussi décrire des programmes incomplets, au fil de leur écriture dans l’éditeur.</span><span class="sxs-lookup"><span data-stu-id="496d2-108">They can also describe incomplete programs, as you write them, in the editor.</span></span>

<span data-ttu-id="496d2-109">Pour permettre cette expression détaillée, les structures de données et les API qui composent l’API Syntaxe sont nécessairement complexes.</span><span class="sxs-lookup"><span data-stu-id="496d2-109">To enable this rich expression, the data structures and APIs that make up the Syntax API are necessarily complex.</span></span> <span data-ttu-id="496d2-110">Commençons par ce à quoi ressemble la structure de données pour le programme habituel « Hello World » :</span><span class="sxs-lookup"><span data-stu-id="496d2-110">Let's start with what the data structure looks like for the typical "Hello World" program:</span></span>

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="496d2-111">Considérez le texte du programme précédent.</span><span class="sxs-lookup"><span data-stu-id="496d2-111">Look at the text of the previous program.</span></span> <span data-ttu-id="496d2-112">Vous reconnaissez des éléments familiers.</span><span class="sxs-lookup"><span data-stu-id="496d2-112">You recognize familiar elements.</span></span> <span data-ttu-id="496d2-113">Le texte entier représente un même fichier source, ou une **unité de compilation**.</span><span class="sxs-lookup"><span data-stu-id="496d2-113">The entire text represents a single source file, or a **compilation unit**.</span></span> <span data-ttu-id="496d2-114">Les trois premières lignes de ce fichier source sont des **directives using**.</span><span class="sxs-lookup"><span data-stu-id="496d2-114">The first three lines of that source file are **using directives**.</span></span> <span data-ttu-id="496d2-115">Le reste de la source est contenue dans une **déclaration d’espace de noms**.</span><span class="sxs-lookup"><span data-stu-id="496d2-115">The remaining source is contained in a **namespace declaration**.</span></span> <span data-ttu-id="496d2-116">La déclaration d’espace de noms contient une **déclaration de classe** enfant.</span><span class="sxs-lookup"><span data-stu-id="496d2-116">The namespace declaration contains a child **class declaration**.</span></span> <span data-ttu-id="496d2-117">La déclaration de classe contient une **déclaration de méthode**.</span><span class="sxs-lookup"><span data-stu-id="496d2-117">The class declaration contains one **method declaration**.</span></span>

<span data-ttu-id="496d2-118">L’API Syntaxe crée une arborescence dont la racine représente l’unité de compilation.</span><span class="sxs-lookup"><span data-stu-id="496d2-118">The Syntax API creates a tree structure with the root representing the compilation unit.</span></span> <span data-ttu-id="496d2-119">Les nœuds de l’arborescence représentent les directives using, la déclaration d’espace de noms et tous les autres éléments du programme.</span><span class="sxs-lookup"><span data-stu-id="496d2-119">Nodes in the tree represent the using directives, namespace declaration and all the other elements of the program.</span></span> <span data-ttu-id="496d2-120">L’ arborescence continue jusqu’aux niveaux les plus bas : la chaîne « Hello World! »</span><span class="sxs-lookup"><span data-stu-id="496d2-120">The tree structure continues down to the lowest levels: the string "Hello World!"</span></span> <span data-ttu-id="496d2-121">est un **jeton de littéral de chaîne** qui est un descendant d’un **argument**.</span><span class="sxs-lookup"><span data-stu-id="496d2-121">is a **string literal token** that is a descendent of an **argument**.</span></span> <span data-ttu-id="496d2-122">L’API Syntaxe fournit l’accès à la structure du programme.</span><span class="sxs-lookup"><span data-stu-id="496d2-122">The Syntax API provides access to the structure of the program.</span></span> <span data-ttu-id="496d2-123">Vous pouvez rechercher des utilisations spécifiques du code, parcourir toute l’arborescence pour comprendre le code et créer des arborescences en modifiant l’arborescence existante.</span><span class="sxs-lookup"><span data-stu-id="496d2-123">You can query for specific code practices, walk the entire tree to understand the code, and create new trees by modifying the existing tree.</span></span>

<span data-ttu-id="496d2-124">Cette brève description fournit une vue d’ensemble des types d’informations accessibles avec l’API Syntaxe.</span><span class="sxs-lookup"><span data-stu-id="496d2-124">That brief description provides an overview of the kind of information accessible using the Syntax API.</span></span> <span data-ttu-id="496d2-125">L’API Syntaxe n’est rien de plus qu’une API formelle qui décrit les constructions de code familières que vous connaissez en C#.</span><span class="sxs-lookup"><span data-stu-id="496d2-125">The Syntax API is nothing more than a formal API that describes the familiar code constructs you know from C#.</span></span> <span data-ttu-id="496d2-126">Les fonctionnalités complètes incluent des informations sur la façon dont le code est mis en forme, notamment les sauts de ligne, les espaces et l’indentation.</span><span class="sxs-lookup"><span data-stu-id="496d2-126">The full capabilities include information about how the code is formatted including line breaks, whitespace, and indenting.</span></span> <span data-ttu-id="496d2-127">Avec ces informations, vous pouvez représenter entièrement le code comme étant écrit et lu par des programmeurs ou par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="496d2-127">Using this information, you can fully represent the code as written and read by human programmers or the compiler.</span></span> <span data-ttu-id="496d2-128">L’utilisation de cette structure vous permet d’interagir avec le code source à un niveau qui est vraiment significatif.</span><span class="sxs-lookup"><span data-stu-id="496d2-128">Using this structure enables you to interact with the source code on a deeply meaningful level.</span></span> <span data-ttu-id="496d2-129">Il ne s’agit plus de chaînes de texte, mais de données qui représentent la structure d’un programme C#.</span><span class="sxs-lookup"><span data-stu-id="496d2-129">It's no longer text strings, but data that represents the structure of a C# program.</span></span>

<span data-ttu-id="496d2-130">Pour commencer, vous devez installer le kit **.NET Compiler Platform SDK** :</span><span class="sxs-lookup"><span data-stu-id="496d2-130">To get started, you'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-syntax-trees"></a><span data-ttu-id="496d2-131">Présentation des arborescences de syntaxe</span><span class="sxs-lookup"><span data-stu-id="496d2-131">Understanding syntax trees</span></span>

<span data-ttu-id="496d2-132">Vous utilisez l’API Syntaxe pour les analyses de la structure du code C#.</span><span class="sxs-lookup"><span data-stu-id="496d2-132">You use the Syntax API for any analysis of the structure of C# code.</span></span> <span data-ttu-id="496d2-133">**L’API Syntaxe** expose les analyseurs, les arborescences de syntaxe, et des utilitaires pour l’analyse et la construction d’arborescences de syntaxe.</span><span class="sxs-lookup"><span data-stu-id="496d2-133">The **Syntax API** exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees.</span></span> <span data-ttu-id="496d2-134">C’est ainsi que vous recherchez le code pour des éléments de syntaxe spécifiques ou que vous lisez le code d’un programme.</span><span class="sxs-lookup"><span data-stu-id="496d2-134">It's how you search code for specific syntax elements or read the code for a program.</span></span>

<span data-ttu-id="496d2-135">Une arborescence de syntaxe est une structure de données utilisée par les compilateurs C# et Visual Basic pour comprendre les programmes C# et Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="496d2-135">A syntax tree is a data structure used by the C# and Visual Basic compilers to understand C# and Visual Basic programs.</span></span> <span data-ttu-id="496d2-136">Les arborescences de syntaxe sont produites par le même analyseur que celui qui s’exécute quand un projet est généré ou qu’un développeur appuie sur F5.</span><span class="sxs-lookup"><span data-stu-id="496d2-136">Syntax trees are produced by the same parser that runs when a project is built or a developer hits F5.</span></span> <span data-ttu-id="496d2-137">Les arborescences de syntaxe sont parfaitement fidèles au langage : chaque élément d’information d’un fichier de code est représenté dans l’arborescence.</span><span class="sxs-lookup"><span data-stu-id="496d2-137">The syntax trees have full-fidelity with the language; every bit of information in a code file is represented in the tree.</span></span> <span data-ttu-id="496d2-138">L’écriture d’une arborescence de syntaxe en texte reproduit le texte d’origine exact qui a été analysé.</span><span class="sxs-lookup"><span data-stu-id="496d2-138">Writing a syntax tree to text reproduces the exact original text that was parsed.</span></span> <span data-ttu-id="496d2-139">Les arborescences de syntaxe sont également **immuables** : une fois créée, une arborescence de syntaxe ne peut jamais être modifiée.</span><span class="sxs-lookup"><span data-stu-id="496d2-139">The syntax trees are also **immutable**; once created a syntax tree can never be changed.</span></span> <span data-ttu-id="496d2-140">Les consommateurs des arborescences peuvent les analyser sur plusieurs threads, sans verrous ou d’autres mesures liées à la simultanéité des accès, sachant que les données ne changent jamais.</span><span class="sxs-lookup"><span data-stu-id="496d2-140">Consumers of the trees can analyze the trees on multiple threads, without locks or other concurrency measures, knowing the data never changes.</span></span> <span data-ttu-id="496d2-141">Vous pouvez utiliser des API pour créer des arborescences qui sont le résultat de la modification d’une arborescence existante.</span><span class="sxs-lookup"><span data-stu-id="496d2-141">You can use APIs to create new trees that are the result of modifying an existing tree.</span></span>

<span data-ttu-id="496d2-142">Les quatre principaux blocs de construction des arborescences de syntaxe sont :</span><span class="sxs-lookup"><span data-stu-id="496d2-142">The four primary building blocks of syntax trees are:</span></span>

* <span data-ttu-id="496d2-143">La classe <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, une instance de celle-ci représentant une arborescence d’analyse entière.</span><span class="sxs-lookup"><span data-stu-id="496d2-143">The <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> class, an instance of which represents an entire parse tree.</span></span> <span data-ttu-id="496d2-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> est une classe abstraite avec des dérivés spécifiques à un langage.</span><span class="sxs-lookup"><span data-stu-id="496d2-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> is an abstract class that has language-specific derivatives.</span></span> <span data-ttu-id="496d2-145">Vous utilisez les méthodes d’analyse de la classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (ou <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) pour analyser du texte dans C# ou VB.</span><span class="sxs-lookup"><span data-stu-id="496d2-145">You use the parse methods of the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) class to parse text in C# or VB.</span></span>
* <span data-ttu-id="496d2-146">La classe <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>, dont les instances représentent des constructions syntaxiques, comme des déclarations, des instructions, des clauses et des expressions.</span><span class="sxs-lookup"><span data-stu-id="496d2-146">The <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span>
* <span data-ttu-id="496d2-147">La structure <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType>, qui représente un mot clé, un identificateur, un opérateur ou un signe de ponctuation individuel.</span><span class="sxs-lookup"><span data-stu-id="496d2-147">The <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> structure, which represents an individual keyword, identifier, operator, or punctuation.</span></span>
* <span data-ttu-id="496d2-148">Enfin, la structure <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType>, qui représente les éléments d’information non significatifs du point de vue syntaxique, comme l’espace entre des jetons, des directives de prétraitement et des commentaires.</span><span class="sxs-lookup"><span data-stu-id="496d2-148">And lastly the <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> structure, which represents syntactically insignificant bits of information such as the whitespace between tokens, preprocessing directives, and comments.</span></span>

<span data-ttu-id="496d2-149">Tout cela, les jetons et les nœuds sont composés de façon hiérarchique pour former une arborescence représentant complètement tous les éléments d’un fragment de code Visual Basic ou C#.</span><span class="sxs-lookup"><span data-stu-id="496d2-149">Trivia, tokens, and nodes are composed hierarchically to form a tree that completely represents everything in a fragment of Visual Basic or C# code.</span></span> <span data-ttu-id="496d2-150">Vous pouvez voir cette structure en utilisant la fenêtre **Visualiseur de syntaxe**.</span><span class="sxs-lookup"><span data-stu-id="496d2-150">You can see this structure using the **Syntax Visualizer** window.</span></span> <span data-ttu-id="496d2-151">Dans Visual Studio, choisissez **Affichage** > **Autres fenêtres** > **Visualiseur de syntaxe**.</span><span class="sxs-lookup"><span data-stu-id="496d2-151">In Visual Studio, choose **View** > **Other Windows** > **Syntax Visualizer**.</span></span> <span data-ttu-id="496d2-152">Par exemple, le fichier source C# précédent examiné avec le **Visualiseur de syntaxe** se présente comme dans la figure suivante :</span><span class="sxs-lookup"><span data-stu-id="496d2-152">For example, the preceding C# source file examined using the **Syntax Visualizer** looks like the following figure:</span></span>

<span data-ttu-id="496d2-153">**SyntaxNode** : Bleu | **SyntaxToken** : Vert | **SyntaxTrivia** : Rouge ![Fichier de code C#](media/walkthrough-csharp-syntax-figure1.png)</span><span class="sxs-lookup"><span data-stu-id="496d2-153">**SyntaxNode**: Blue | **SyntaxToken**: Green | **SyntaxTrivia**: Red ![C# Code File](media/walkthrough-csharp-syntax-figure1.png)</span></span>

<span data-ttu-id="496d2-154">En parcourant cette arborescence, vous pouvez trouver les instructions, expressions, jetons ou espaces, quels qu’ils soient, dans un fichier de code.</span><span class="sxs-lookup"><span data-stu-id="496d2-154">By navigating this tree structure, you can find any statement, expression, token, or bit of whitespace in a code file.</span></span>

<span data-ttu-id="496d2-155">Vous pouvez rechercher n’importe quel élément dans un fichier de code à l’aide des API Syntaxe, mais la plupart des scénarios concernent l’examen de petits extraits de code, ou la recherche d’instructions ou de fragments particuliers.</span><span class="sxs-lookup"><span data-stu-id="496d2-155">While you can find anything in a code file using the Syntax APIs, most scenarios involve examining small snippets of code, or searching for particular statements or fragments.</span></span> <span data-ttu-id="496d2-156">Les deux exemples qui suivent montrent des utilisations classiques d’exploration de la structure du code ou de recherche d’instructions individuelles.</span><span class="sxs-lookup"><span data-stu-id="496d2-156">The two examples that follow show typical uses to browse the structure of code, or search for single statements.</span></span>

## <a name="traversing-trees"></a><span data-ttu-id="496d2-157">Exploration des arborescences</span><span class="sxs-lookup"><span data-stu-id="496d2-157">Traversing trees</span></span>

<span data-ttu-id="496d2-158">Vous pouvez examiner les nœuds d’une arborescence de syntaxe de deux façons.</span><span class="sxs-lookup"><span data-stu-id="496d2-158">You can examine the nodes in a syntax tree in two ways.</span></span> <span data-ttu-id="496d2-159">Vous pouvez parcourir l’arborescence pour examiner chaque nœud, ou vous pouvez rechercher des éléments ou des nœuds spécifiques.</span><span class="sxs-lookup"><span data-stu-id="496d2-159">You can traverse the tree to examine each node, or you can query for specific elements or nodes.</span></span>

### <a name="manual-traversal"></a><span data-ttu-id="496d2-160">Exploration manuelle</span><span class="sxs-lookup"><span data-stu-id="496d2-160">Manual traversal</span></span>

<span data-ttu-id="496d2-161">Vous pouvez trouver le code complet de cet exemple dans [notre dépôt GitHub](https://github.com/dotnet/docs/tree/master/samples/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="496d2-161">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/docs/tree/master/samples/csharp/roslyn-sdk/SyntaxQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="496d2-162">Les types de l’arborescence de syntaxe utilisent l’héritage pour décrire les différents éléments de syntaxe qui sont valides à différents emplacements du programme.</span><span class="sxs-lookup"><span data-stu-id="496d2-162">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="496d2-163">Utiliser ces API signifie souvent effectuer un cast des propriétés ou des membres de collection vers des types dérivés spécifiques.</span><span class="sxs-lookup"><span data-stu-id="496d2-163">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="496d2-164">Dans les exemples suivants, l’affectation et les casts sont des instructions distinctes, qui utilisent des variables typées explicitement.</span><span class="sxs-lookup"><span data-stu-id="496d2-164">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="496d2-165">Vous pouvez lire le code pour voir les types de retour de l’API et le type à l’exécution des objets retournés.</span><span class="sxs-lookup"><span data-stu-id="496d2-165">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="496d2-166">Dans la pratique, il est plus courant d’utiliser des variables typées implicitement et de se baser sur des noms d’API pour décrire le type des objets examinés.</span><span class="sxs-lookup"><span data-stu-id="496d2-166">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="496d2-167">Créez un projet C# **Outil d’analyse du code autonome** :</span><span class="sxs-lookup"><span data-stu-id="496d2-167">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="496d2-168">Dans Visual Studio, choisissez **Fichier** > **Nouveau** > **Projet** pour afficher la boîte de dialogue Nouveau projet.</span><span class="sxs-lookup"><span data-stu-id="496d2-168">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="496d2-169">Sous **Visual C#** > **Extensibilité**, choisissez **Outil d’analyse du code autonome**.</span><span class="sxs-lookup"><span data-stu-id="496d2-169">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="496d2-170">Nommez votre projet « **SyntaxTreeManualTraversal** » et cliquez sur OK.</span><span class="sxs-lookup"><span data-stu-id="496d2-170">Name your project "**SyntaxTreeManualTraversal**" and click OK.</span></span>

<span data-ttu-id="496d2-171">Vous allez analyser le programme simple « Hello World! »</span><span class="sxs-lookup"><span data-stu-id="496d2-171">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="496d2-172">montré précédemment.</span><span class="sxs-lookup"><span data-stu-id="496d2-172">program shown earlier.</span></span>
<span data-ttu-id="496d2-173">Ajoutez le texte pour le programme Hello World en tant que constante dans votre classe `Program` :</span><span class="sxs-lookup"><span data-stu-id="496d2-173">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program text](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="496d2-174">Ensuite, ajoutez le code suivant pour générer **l’arborescence de syntaxe** pour le texte du code dans la constante `programText`.</span><span class="sxs-lookup"><span data-stu-id="496d2-174">Next, add the following code to build the **syntax tree** for the code text in the `programText` constant.</span></span>  <span data-ttu-id="496d2-175">Ajoutez la ligne suivante à votre méthode `Main` :</span><span class="sxs-lookup"><span data-stu-id="496d2-175">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="496d2-176">Ces deux lignes créent l’arborescence et en récupèrent le nœud racine.</span><span class="sxs-lookup"><span data-stu-id="496d2-176">Those two lines create the tree and retrieve the root node of that tree.</span></span> <span data-ttu-id="496d2-177">Vous pouvez maintenant examiner les nœuds de l’arborescence.</span><span class="sxs-lookup"><span data-stu-id="496d2-177">You can now examine the nodes in the tree.</span></span> <span data-ttu-id="496d2-178">Ajoutez ces lignes à votre méthode `Main` pour afficher certaines des propriétés du nœud racine de l’arborescence :</span><span class="sxs-lookup"><span data-stu-id="496d2-178">Add these lines to your `Main` method to display some of the properties of the root node in the tree:</span></span>

[!code-csharp[Examine the root node](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#3 "Examine the root node")]

<span data-ttu-id="496d2-179">Exécutez l’application pour voir ce que votre code a découvert sur le nœud racine de cette arborescence.</span><span class="sxs-lookup"><span data-stu-id="496d2-179">Run the application to see what your code has discovered about the root node in this tree.</span></span>

<span data-ttu-id="496d2-180">En règle générale, vous explorez l’arborescence pour en savoir plus sur le code.</span><span class="sxs-lookup"><span data-stu-id="496d2-180">Typically, you'd traverse the tree to learn about the code.</span></span> <span data-ttu-id="496d2-181">Dans cet exemple, vous analysez du code que vous connaissez pour explorer les API.</span><span class="sxs-lookup"><span data-stu-id="496d2-181">In this example, you're analyzing code you know to explore the APIs.</span></span> <span data-ttu-id="496d2-182">Ajoutez le code suivant pour examiner le premier membre du nœud `root` :</span><span class="sxs-lookup"><span data-stu-id="496d2-182">Add the following code to examine the first member of the `root` node:</span></span>

[!code-csharp[Find the first member](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#4 "Find the first member")]

<span data-ttu-id="496d2-183">Ce membre est une <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="496d2-183">That member is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="496d2-184">Il représente tous les éléments de l’étendue de la déclaration `namespace HelloWorld`.</span><span class="sxs-lookup"><span data-stu-id="496d2-184">It represents everything in the scope of the `namespace HelloWorld` declaration.</span></span> <span data-ttu-id="496d2-185">Ajoutez le code suivant pour examiner les nœuds qui sont déclarés à l’intérieur de l’espace de noms `HelloWorld` :</span><span class="sxs-lookup"><span data-stu-id="496d2-185">Add the following code to examine what nodes are declared inside the `HelloWorld` namespace:</span></span>

[!code-csharp[Find the class declaration](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#5 "Find the class declaration")]

<span data-ttu-id="496d2-186">Exécutez le programme pour voir ce que vous avez découvert.</span><span class="sxs-lookup"><span data-stu-id="496d2-186">Run the program to see what you've learned.</span></span>

<span data-ttu-id="496d2-187">Maintenant que vous savez que la déclaration est une <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, déclarez une nouvelle variable de ce type pour examiner la déclaration de la classe.</span><span class="sxs-lookup"><span data-stu-id="496d2-187">Now that you know the declaration is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare a new variable of that type to examine the class declaration.</span></span> <span data-ttu-id="496d2-188">Cette classe contient seulement un membre : la méthode `Main`.</span><span class="sxs-lookup"><span data-stu-id="496d2-188">This class only contains one member: the `Main` method.</span></span> <span data-ttu-id="496d2-189">Ajoutez le code suivant pour rechercher la méthode `Main` et en effectuer un cast en <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="496d2-189">Add the following code to find the `Main` method, and cast it to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span></span>

[!code-csharp[Find the main declaration](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#6 "Find the main declaration")]

<span data-ttu-id="496d2-190">Le nœud de la déclaration de la méthode contient toutes les informations syntaxiques relatives à la méthode.</span><span class="sxs-lookup"><span data-stu-id="496d2-190">The method declaration node contains all the syntactic information about the method.</span></span> <span data-ttu-id="496d2-191">Affichons le type de retour de la méthode `Main`, le nombre et les types des arguments, et le texte du corps de la méthode.</span><span class="sxs-lookup"><span data-stu-id="496d2-191">Let's display the return type of the `Main` method, the number and types of the arguments, and the body text of the method.</span></span> <span data-ttu-id="496d2-192">Ajoutez le code suivant :</span><span class="sxs-lookup"><span data-stu-id="496d2-192">Add the following code:</span></span>

[!code-csharp[Examine the syntax of the main method](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#7 "Display information about the main method")]

<span data-ttu-id="496d2-193">Exécutez le programme pour voir toutes les informations que vous avez découvertes sur ce programme :</span><span class="sxs-lookup"><span data-stu-id="496d2-193">Run the program to see all the information you've discovered about this program:</span></span>

```text
The tree is a CompilationUnit node.
The tree has 1 elements in it.
The tree has 4 using statements. They are:
        System
        System.Collections
        System.Linq
        System.Text
The first member is a NamespaceDeclaration.
There are 1 members declared in this namespace.
The first member is a ClassDeclaration.
There are 1 members declared in the Program class.
The first member is a MethodDeclaration.
The return type of the Main method is void.
The method has 1 parameters.
The type of the args parameter is string[].
The body text of the Main method follows:
        {
            Console.WriteLine("Hello, World!");
        }
```

### <a name="query-methods"></a><span data-ttu-id="496d2-194">Méthodes de requête</span><span class="sxs-lookup"><span data-stu-id="496d2-194">Query methods</span></span>

<span data-ttu-id="496d2-195">En plus de parcourir les arborescences, vous pouvez aussi explorer l’arborescence de syntaxe avec les méthodes de requête définies sur <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="496d2-195">In addition to traversing trees, you can also explore the syntax tree using the query methods defined on <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="496d2-196">Ces méthodes sont normalement immédiatement familières à toute personne connaissant XPath.</span><span class="sxs-lookup"><span data-stu-id="496d2-196">These methods should be immediately familiar to anyone familiar with XPath.</span></span> <span data-ttu-id="496d2-197">Vous pouvez utiliser ces méthodes avec LINQ pour rechercher rapidement des éléments dans une arborescence.</span><span class="sxs-lookup"><span data-stu-id="496d2-197">You can use these methods with LINQ to quickly find things in a tree.</span></span> <span data-ttu-id="496d2-198"><xref:Microsoft.CodeAnalysis.SyntaxNode> a des méthodes de requête comme <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> et <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span><span class="sxs-lookup"><span data-stu-id="496d2-198">The <xref:Microsoft.CodeAnalysis.SyntaxNode> has query methods such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span></span>

<span data-ttu-id="496d2-199">Vous pouvez utiliser ces méthodes de requête pour rechercher l’argument de la méthode `Main`, au lieu de naviguer dans l’arborescence.</span><span class="sxs-lookup"><span data-stu-id="496d2-199">You can use these query methods to find the argument to the `Main` method as an alternative to navigating the tree.</span></span> <span data-ttu-id="496d2-200">Ajoutez le code suivant dans le bas de votre nouvelle méthode `Main` :</span><span class="sxs-lookup"><span data-stu-id="496d2-200">Add the following code to the bottom of your `Main` method:</span></span>

[!code-csharp[Query the tree for the arguments to Main](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#8 "Query the tree for the arguments to Main")]

<span data-ttu-id="496d2-201">La première instruction utilise une expression LINQ et la méthode <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> pour localiser le même paramètre que dans l’exemple précédent.</span><span class="sxs-lookup"><span data-stu-id="496d2-201">The first statement uses a LINQ expression and the <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> method to locate the same parameter as in the previous example.</span></span>

<span data-ttu-id="496d2-202">Exécutez le programme : vous voyez que l’expression LINQ a trouvé le même paramètre que quand vous avez exploré manuellement l’arborescence.</span><span class="sxs-lookup"><span data-stu-id="496d2-202">Run the program, and you can see that the LINQ expression found the same parameter as manually navigating the tree.</span></span>

<span data-ttu-id="496d2-203">L’exemple utilise des instructions `WriteLine` pour afficher des informations sur les arborescences de syntaxe au fil de leur exploration.</span><span class="sxs-lookup"><span data-stu-id="496d2-203">The sample uses `WriteLine` statements to display information about the syntax trees as they are traversed.</span></span> <span data-ttu-id="496d2-204">Vous pouvez aussi découvrir beaucoup plus d’informations en exécutant le programme sous le débogueur.</span><span class="sxs-lookup"><span data-stu-id="496d2-204">You can also learn much more by running the finished program under the debugger.</span></span> <span data-ttu-id="496d2-205">Vous pouvez examiner plus de propriétés et de méthodes qui font partie de l’arborescence de syntaxe créée pour le programme « Hello World ».</span><span class="sxs-lookup"><span data-stu-id="496d2-205">You can examine more of the properties and methods that are part of the syntax tree created for the hello world program.</span></span>

## <a name="syntax-walkers"></a><span data-ttu-id="496d2-206">Parcoureurs de syntaxe</span><span class="sxs-lookup"><span data-stu-id="496d2-206">Syntax walkers</span></span>

<span data-ttu-id="496d2-207">Vous voulez souvent rechercher tous les nœuds d’un type spécifique dans une arborescence de syntaxe, par exemple toutes les déclarations de propriété dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="496d2-207">Often you want to find all nodes of a specific type in a syntax tree, for example, every property declaration in a file.</span></span> <span data-ttu-id="496d2-208">En étendant la classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> et en remplaçant la méthode <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)>, vous traitez chaque déclaration de propriété d’une arborescence de syntaxe sans connaître préalablement sa structure.</span><span class="sxs-lookup"><span data-stu-id="496d2-208">By extending the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> class and overriding the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> method, you process every property declaration in a syntax tree without knowing its structure beforehand.</span></span> <span data-ttu-id="496d2-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> est un type spécifique de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor>, qui visite de façon récursive un nœud et chacun de ses enfants.</span><span class="sxs-lookup"><span data-stu-id="496d2-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> is a specific kind of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> that recursively visits a node and each of its children.</span></span>

<span data-ttu-id="496d2-210">Cet exemple implémente un <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> qui examine une arborescence de syntaxe.</span><span class="sxs-lookup"><span data-stu-id="496d2-210">This example implements a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines a syntax tree.</span></span> <span data-ttu-id="496d2-211">Il collecte les directives `using` qu’il trouve et qui n’importent pas un espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="496d2-211">It collects `using` directives it finds that aren't importing a `System` namespace.</span></span>

<span data-ttu-id="496d2-212">Créez un projet C# **Outil d’analyse du code autonome** et nommez-le « **SyntaxWalker** ».</span><span class="sxs-lookup"><span data-stu-id="496d2-212">Create a new C# **Stand-Alone Code Analysis Tool** project; name it "**SyntaxWalker**."</span></span>

<span data-ttu-id="496d2-213">Vous pouvez trouver le code complet de cet exemple dans [notre dépôt GitHub](https://github.com/dotnet/docs/tree/master/samples/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="496d2-213">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/docs/tree/master/samples/csharp/roslyn-sdk/SyntaxQuickStart).</span></span> <span data-ttu-id="496d2-214">L’exemple sur GitHub contient les deux projets décrits dans ce tutoriel.</span><span class="sxs-lookup"><span data-stu-id="496d2-214">The sample on GitHub contains both projects described in this tutorial.</span></span>

<span data-ttu-id="496d2-215">Comme dans l’exemple précédent, vous pouvez définir une constante de chaîne pour contenir le texte du programme que vous voulez analyser :</span><span class="sxs-lookup"><span data-stu-id="496d2-215">As in the previous sample, you can define a string constant to hold the text of the program you're going to analyze:</span></span>

[!code-csharp[Define the code text to analyzer](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#1 "Define the program text to analyze")]

<span data-ttu-id="496d2-216">Ce texte source contient des directives `using` réparties dans quatre emplacements différents : le niveau fichier, dans l’espace de noms du plus haut niveau et dans les deux espaces de noms imbriqués.</span><span class="sxs-lookup"><span data-stu-id="496d2-216">This source text contains `using` directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces.</span></span> <span data-ttu-id="496d2-217">Cet exemple met en évidence un scénario de base pour l’utilisation de la classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> pour interroger du code.</span><span class="sxs-lookup"><span data-stu-id="496d2-217">This example highlights a core scenario for using the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> class to query code.</span></span> <span data-ttu-id="496d2-218">Il serait fastidieux de visiter chaque nœud dans l’arborescence de syntaxe racine pour trouver les déclarations using.</span><span class="sxs-lookup"><span data-stu-id="496d2-218">It would be cumbersome to visit every node in the root syntax tree to find using declarations.</span></span> <span data-ttu-id="496d2-219">Au lieu de cela, vous créez une classe dérivée et vous remplacez la méthode qui est appelée seulement quand le nœud actuel de l’arborescence est une directive using.</span><span class="sxs-lookup"><span data-stu-id="496d2-219">Instead, you create a derived class and override the method that gets called only when the current node in the tree is a using directive.</span></span> <span data-ttu-id="496d2-220">Votre visiteur n’effectue aucun travail sur les autres types de nœuds.</span><span class="sxs-lookup"><span data-stu-id="496d2-220">Your visitor does not do any work on any other node types.</span></span> <span data-ttu-id="496d2-221">Cette même méthode examine chacune des instructions `using` et génère une collection des espaces de noms qui ne figurent pas dans l’espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="496d2-221">This single method examines each of the `using` statements and builds a collection of the namespaces that aren't in the `System` namespace.</span></span> <span data-ttu-id="496d2-222">Vous créez un <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> qui examine toutes les instructions `using`, mais uniquement les instructions `using`.</span><span class="sxs-lookup"><span data-stu-id="496d2-222">You build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines all the `using` statements, but only the `using` statements.</span></span>

<span data-ttu-id="496d2-223">Maintenant que vous avez défini le texte du programme, vous devez créer un `SyntaxTree` et obtenir la racine de cette arborescence :</span><span class="sxs-lookup"><span data-stu-id="496d2-223">Now that you've defined the program text, you need to create a `SyntaxTree` and get the root of that tree:</span></span>

[!code-csharp[Create the Syntax tree and access the root](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#2 "Create the Syntax tree and access the root node.")]

<span data-ttu-id="496d2-224">Ensuite, créez une classe.</span><span class="sxs-lookup"><span data-stu-id="496d2-224">Next, create a new class.</span></span> <span data-ttu-id="496d2-225">Dans Visual Studio, choisissez **Projet** > **Ajouter un nouvel élément**.</span><span class="sxs-lookup"><span data-stu-id="496d2-225">In Visual Studio, choose **Project** > **Add New Item**.</span></span> <span data-ttu-id="496d2-226">Dans la boîte de dialogue **Ajouter un nouvel élément**, tapez *UsingCollector.cs* comme nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="496d2-226">In the **Add New Item** dialog type *UsingCollector.cs* as the filename.</span></span>

<span data-ttu-id="496d2-227">Vous implémentez la fonctionnalité de visiteur `using` dans la classe `UsingCollector`.</span><span class="sxs-lookup"><span data-stu-id="496d2-227">You implement the `using` visitor functionality in the `UsingCollector` class.</span></span> <span data-ttu-id="496d2-228">Commencez par faire de la classe `UsingCollector` une dérivée <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span><span class="sxs-lookup"><span data-stu-id="496d2-228">Start by making the `UsingCollector` class derive from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span></span>

[!code-csharp[Declare the base class for the using collector](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#3 "Declare the base class for the UsingCollector")]

<span data-ttu-id="496d2-229">Vous avez besoin d’un stockage pour contenir les nœuds d’espace de noms que vous collectez.</span><span class="sxs-lookup"><span data-stu-id="496d2-229">You need storage to hold the namespace nodes that you're collecting.</span></span>  <span data-ttu-id="496d2-230">Déclarez une propriété publique en lecture seule dans la classe `UsingCollector` ; vous utilisez cette variable pour stocker les nœuds <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> que vous trouvez :</span><span class="sxs-lookup"><span data-stu-id="496d2-230">Declare a public read-only property in the `UsingCollector` class; you use this variable to store the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nodes you find:</span></span>

[!code-csharp[Declare storage for the using syntax nodes](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#4 "Declare storage for the using syntax nodes")]

<span data-ttu-id="496d2-231">La classe de base, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>, implémente la logique pour visiter chaque nœud de l’arborescence de syntaxe.</span><span class="sxs-lookup"><span data-stu-id="496d2-231">The base class, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implements the logic to visit each node in the syntax tree.</span></span> <span data-ttu-id="496d2-232">La classe dérivée remplace les méthodes appelées pour les nœuds spécifiques qui vous intéressent.</span><span class="sxs-lookup"><span data-stu-id="496d2-232">The derived class overrides the methods called for the specific nodes you're interested in.</span></span> <span data-ttu-id="496d2-233">Dans ce cas, vous êtes intéressé par toutes les directives `using`.</span><span class="sxs-lookup"><span data-stu-id="496d2-233">In this case, you're interested in any `using` directive.</span></span> <span data-ttu-id="496d2-234">Cela signifie que vous devez remplacer la méthode <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>.</span><span class="sxs-lookup"><span data-stu-id="496d2-234">That means you must override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> method.</span></span> <span data-ttu-id="496d2-235">Le seul argument de cette méthode est un objet <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="496d2-235">The one argument to this method is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="496d2-236">Utiliser des visiteurs a un avantage important : ils appellent les méthodes remplacées avec des arguments déjà castés au type de nœud spécifique.</span><span class="sxs-lookup"><span data-stu-id="496d2-236">That's an important advantage to using the visitors: they call the overridden methods with arguments already cast to the specific node type.</span></span> <span data-ttu-id="496d2-237">La classe <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> a une propriété <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> qui stocke le nom de l’espace de noms importé.</span><span class="sxs-lookup"><span data-stu-id="496d2-237">The <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> class has a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> property that stores the name of the namespace being imported.</span></span> <span data-ttu-id="496d2-238">Il s’agit d’une <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="496d2-238">It is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="496d2-239">Ajoutez le code suivant dans le remplacement de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> :</span><span class="sxs-lookup"><span data-stu-id="496d2-239">Add the following code in the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> override:</span></span>

[!code-csharp[Examine using nodes for the System namespace](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#5 "Examine all using nodes for the System namespace.")]

<span data-ttu-id="496d2-240">Comme avec l’exemple précédent, vous avez ajouté différentes instructions `WriteLine` pour faciliter la compréhension de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="496d2-240">As with the earlier example, you've added a variety of `WriteLine` statements to aid in understanding of this method.</span></span> <span data-ttu-id="496d2-241">Vous pouvez voir quand elle est appelée, ainsi que les arguments qui lui sont passés à chaque fois.</span><span class="sxs-lookup"><span data-stu-id="496d2-241">You can see when it's called, and what arguments are passed to it each time.</span></span>

<span data-ttu-id="496d2-242">Enfin, vous devez ajouter deux lignes de code pour créer le `UsingCollector` et faire en sorte qu’il visite le nœud racine, en collectant toutes les instructions `using`.</span><span class="sxs-lookup"><span data-stu-id="496d2-242">Finally, you need to add two lines of code to create the `UsingCollector` and have it visit the root node, collecting all the `using` statements.</span></span> <span data-ttu-id="496d2-243">Ensuite, ajoutez une boucle `foreach` pour afficher toutes les instructions `using` trouvées par votre collecteur :</span><span class="sxs-lookup"><span data-stu-id="496d2-243">Then, add a `foreach` loop to display all the `using` statements your collector found:</span></span>

[!code-csharp[Create the UsingCollector and visit the root node.](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#6 "Create the UsingCollector and visit the root node.")]

<span data-ttu-id="496d2-244">Compilez et exécutez le programme.</span><span class="sxs-lookup"><span data-stu-id="496d2-244">Compile and run the program.</span></span> <span data-ttu-id="496d2-245">Vous devez voir la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="496d2-245">You should see the following output:</span></span>

```console
        VisitUsingDirective called with System.
        VisitUsingDirective called with System.Collections.Generic.
        VisitUsingDirective called with System.Linq.
        VisitUsingDirective called with System.Text.
        VisitUsingDirective called with Microsoft.CodeAnalysis.
                Success. Adding Microsoft.CodeAnalysis.
        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.
                Success. Adding Microsoft.CodeAnalysis.CSharp.
        VisitUsingDirective called with Microsoft.
                Success. Adding Microsoft.
        VisitUsingDirective called with System.ComponentModel.
        VisitUsingDirective called with Microsoft.Win32.
                Success. Adding Microsoft.Win32.
        VisitUsingDirective called with System.Runtime.InteropServices.
        VisitUsingDirective called with System.CodeDom.
        VisitUsingDirective called with Microsoft.CSharp.
                Success. Adding Microsoft.CSharp.
Microsoft.CodeAnalysis
Microsoft.CodeAnalysis.CSharp
Microsoft
Microsoft.Win32
Microsoft.CSharp
Press any key to continue . . .
```

<span data-ttu-id="496d2-246">Félicitations !</span><span class="sxs-lookup"><span data-stu-id="496d2-246">Congratulations!</span></span> <span data-ttu-id="496d2-247">Vous avez utilisé **l’API Syntaxe** pour rechercher des types spécifiques d’instructions et de déclarations C# dans du code source C#.</span><span class="sxs-lookup"><span data-stu-id="496d2-247">You've used the **Syntax API** to locate specific kinds of C# statements and declarations in C# source code.</span></span>
