---
title: Critères spéciaux - Guide C#
description: En savoir plus sur les expressions de critères spéciaux en langage C#
keywords: .NET, .NET Core, C#
ms.date: 01/24/2017
ms.author: wiwagn
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: a0f80fc2c019cefa81506d9dcdeabc57a1e98c2b
ms.sourcegitcommit: 86adcc06e35390f13c1e372c36d2e044f1fc31ef
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/26/2018
---
# <a name="pattern-matching"></a><span data-ttu-id="f8fb0-104">Critères spéciaux</span><span class="sxs-lookup"><span data-stu-id="f8fb0-104">Pattern Matching</span></span> #

<span data-ttu-id="f8fb0-105">Les modèles vérifient qu’une valeur a une certaine *forme* et peuvent *extraire* des informations de la valeur quand celle-ci a la forme correspondante.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-105">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="f8fb0-106">Les critères spéciaux offrent une syntaxe plus concise pour les algorithmes que vous utilisez déjà aujourd’hui.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-106">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="f8fb0-107">Vous pouvez déjà créer des algorithmes de critères spéciaux à l’aide de la syntaxe existante.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-107">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="f8fb0-108">Pour cela, vous écrivez des instructions `if` ou `switch` qui testent une valeur.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-108">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="f8fb0-109">Ensuite, quand ces instructions correspondent, vous extrayez et utilisez les informations de cette valeur.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-109">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="f8fb0-110">Les nouveaux éléments de syntaxe étendent les instructions que vous connaissez déjà : `is` et `switch`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-110">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="f8fb0-111">Ces nouvelles extensions permettent à la fois de tester une valeur et d’extraire les informations de cette valeur.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-111">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="f8fb0-112">Dans cette rubrique, nous allons examiner la nouvelle syntaxe et montrer de quelle manière l’utiliser pour rendre votre code plus lisible et concis.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-112">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="f8fb0-113">Les critères spéciaux permettent l’utilisation d’idiomes où le code et les données sont séparés, contrairement aux conceptions orientées objet où les données et les méthodes qui les manipulent sont étroitement couplées.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-113">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="f8fb0-114">Pour illustrer ces nouveaux idiomes, nous allons manipuler des structures représentant des formes géométriques à l’aide d’instructions de critères spéciaux.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-114">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="f8fb0-115">Vous savez probablement déjà concevoir des hiérarchies de classes et créer des [méthodes virtuelles et méthodes substituées](methods.md#inherited) pour personnaliser le comportement d’un objet en fonction du type de runtime de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-115">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="f8fb0-116">Ces techniques ne sont pas possibles avec des données qui ne sont pas structurées dans une hiérarchie de classes.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-116">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="f8fb0-117">Quand les données et les méthodes sont séparées, vous avez besoin d’autres outils.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-117">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="f8fb0-118">Les nouvelles constructions de *critères spéciaux* utilisent une syntaxe simplifiée pour examiner les données et manipuler le flux de contrôle en fonction de la condition de ces données.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-118">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="f8fb0-119">Vous écrivez déjà des instructions `if` et `switch` qui testent la valeur d’une variable.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-119">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="f8fb0-120">Vous écrivez déjà des instructions `is` qui testent le type d’une variable.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-120">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="f8fb0-121">Les *critères spéciaux* ajoutent de nouvelles fonctionnalités à ces instructions.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-121">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="f8fb0-122">Dans cette rubrique, vous allez créer une méthode qui calcule la surface de différentes formes géométriques.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-122">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="f8fb0-123">Pour cela, vous n’allez pas utiliser les techniques orientées objet, ni créer une hiérarchie de classes pour les différentes formes, comme vous le faites habituellement.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-123">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="f8fb0-124">Vous allez utiliser des *critères spéciaux* à la place.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-124">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="f8fb0-125">Pour bien illustrer le fait qu’il n’y a pas d’héritage, vous allez définir chaque forme comme un `struct` au lieu d’une classe.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-125">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="f8fb0-126">Notez que des types de `struct` différents ne peuvent pas spécifier un type de base commun défini par l’utilisateur, ce qui explique pourquoi l’héritage n’est pas une conception possible.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-126">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="f8fb0-127">Tout au long de cet exemple, comparez ce code avec le même code structuré comme une hiérarchie d’objets.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-127">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="f8fb0-128">Quand les données à interroger et à manipuler ne sont pas une hiérarchie de classes, les critères spéciaux permettent des conceptions très élégantes.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-128">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="f8fb0-129">Au lieu de commencer avec une définition de forme abstraite et d’ajouter ensuite différentes classes de formes spécifiques, écrivez d’abord les définitions de données simples pour chacune des formes géométriques :</span><span class="sxs-lookup"><span data-stu-id="f8fb0-129">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="f8fb0-130">À partir de ces structures, écrivez une méthode qui calcule la surface d’une forme.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-130">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="f8fb0-131">Expression du modèle de type `is`</span><span class="sxs-lookup"><span data-stu-id="f8fb0-131">The `is` type pattern expression</span></span>

<span data-ttu-id="f8fb0-132">Avant C# 7.0, vous deviez tester chaque type dans une série d’instructions `if` et `is` :</span><span class="sxs-lookup"><span data-stu-id="f8fb0-132">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="f8fb0-133">Le code ci-dessus est une expression standard du *modèle de type* : vous testez une variable pour déterminer son type et vous effectuez une action différente en fonction de ce type.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-133">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="f8fb0-134">Vous pouvez simplifier ce code en ajoutant des extensions à l’expression `is` pour assigner une variable si le test réussit :</span><span class="sxs-lookup"><span data-stu-id="f8fb0-134">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="f8fb0-135">Dans cette version mise à jour, l’expression `is` teste la variable et l’assigne à une nouvelle variable du type approprié.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-135">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="f8fb0-136">Remarquez également que cette version inclut le type `Rectangle`, qui est un `struct`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-136">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="f8fb0-137">La nouvelle expression `is` peut être utilisée avec des types valeur et des types référence.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-137">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="f8fb0-138">Les règles de langage des expressions de critères spéciaux vous aident à éviter une utilisation incorrecte des résultats d’une expression de correspondance.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-138">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="f8fb0-139">Dans l’exemple ci-dessus, les variables `s`, `c` et `r` sont uniquement dans la portée et assignées de manière définitive quand les expressions de critères spéciaux respectives retournent le résultat `true`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-139">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="f8fb0-140">Si vous essayez d’utiliser l’une de ces variables à un autre emplacement, votre code génère des erreurs de compilateur.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-140">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="f8fb0-141">Examinons ces deux règles en détail, en commençant par la portée.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-141">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="f8fb0-142">La variable `c` est dans la portée uniquement dans la branche `else` de la première instruction `if`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-142">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="f8fb0-143">La variable `s` est dans la portée dans la méthode `ComputeArea`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-143">The variable `s` is in scope in the method `ComputeArea`.</span></span> <span data-ttu-id="f8fb0-144">Cela est dû au fait que chaque branche d’une instruction `if` établit une portée distincte pour les variables,</span><span class="sxs-lookup"><span data-stu-id="f8fb0-144">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="f8fb0-145">ce que ne fait pas l’instruction `if` proprement dite.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-145">However, the `if` statement itself does not.</span></span> <span data-ttu-id="f8fb0-146">Cela signifie que les variables déclarées dans l’instruction `if` sont dans la même portée que l’instruction `if` (la méthode, dans le cas présent). Ce comportement n’est pas propre aux critères spéciaux. C’est le comportement défini pour les portées de variables et pour les instructions `if` et `else`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-146">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="f8fb0-147">Les variables `c` et `s` sont assignées quand les instructions `if` respectives ont la valeur true, selon la règle d’assignation définitive quand le résultat est true.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-147">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="f8fb0-148">Les exemples de cette rubrique utilisent la construction recommandée où une expression de critères spéciaux `is` assigne de manière définitive la variable de correspondance dans la branche `true` de l’instruction `if`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-148">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="f8fb0-149">Vous pourriez inverser la logique en écrivant `if (!(shape is Square s))`. La variable `s` serait alors assignée de manière définitive uniquement dans la branche `false`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-149">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="f8fb0-150">Cette pratique est possible dans C#, mais elle est déconseillée, car elle repose sur une logique plus compliquée à suivre.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-150">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="f8fb0-151">Ces règles limitent le risque d’accéder accidentellement au résultat d’une expression de critères spéciaux dont le test n’a pas réussi.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-151">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="f8fb0-152">Utilisation des instructions de critères spéciaux `switch`</span><span class="sxs-lookup"><span data-stu-id="f8fb0-152">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="f8fb0-153">Au fil du temps, vous aurez peut-être besoin de prendre en charge d’autres types de formes.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-153">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="f8fb0-154">Si vous avez de plus en plus de conditions à tester, utiliser les expressions de critères spéciaux `is` peut devenir compliqué.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-154">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="f8fb0-155">En plus de nécessiter des instructions `if` pour chaque type à vérifier, les expressions `is` permettent uniquement de vérifier si l’entrée correspond à un type unique.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-155">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="f8fb0-156">Dans ce cas, les expressions de critères spéciaux `switch` sont plus adaptées.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-156">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="f8fb0-157">L’instruction `switch` standard était une expression de modèle, qui prenait en charge le modèle de constante.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-157">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="f8fb0-158">Vous pouviez comparer une variable à n’importe quelle constante utilisée dans une instruction `case` :</span><span class="sxs-lookup"><span data-stu-id="f8fb0-158">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="f8fb0-159">Le seul modèle pris en charge par l’instruction `switch` était le modèle de constante.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-159">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="f8fb0-160">De plus, il était limité aux types numériques et au type `string`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-160">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="f8fb0-161">Ces restrictions ayant été supprimées, vous pouvez maintenant écrire une instruction `switch` en utilisant le modèle de type :</span><span class="sxs-lookup"><span data-stu-id="f8fb0-161">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="f8fb0-162">L’instruction de critères spéciaux `switch` utilise une syntaxe qui est familière aux développeurs ayant utilisé l’instruction `switch` de style C standard.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-162">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="f8fb0-163">Chaque instruction `case` est évaluée, et le code en-dessous de la condition qui correspond à la variable d’entrée est exécuté.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-163">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="f8fb0-164">L’exécution du code ne continue pas d’une expression case à la suivante, car la syntaxe de l’instruction `case` nécessite que chaque `case` se termine par un `break`, `return` ou `goto`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-164">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="f8fb0-165">Les instructions `goto` pour accéder à une autre étiquette sont valides uniquement pour le modèle de constante, l’instruction switch standard.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-165">The `goto` statements to jump to another label are valid only for the constant pattern, the classic switch statement.</span></span>

<span data-ttu-id="f8fb0-166">Il y a de nouvelles règles importantes qui régissent l’instruction `switch`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-166">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="f8fb0-167">Les restrictions sur le type de la variable dans l’expression `switch` ont été supprimées.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-167">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="f8fb0-168">Vous pouvez maintenant utiliser tous les types, comme le type `object` dans cet exemple.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-168">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="f8fb0-169">Les expressions case ne sont plus limitées à des valeurs de constante.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-169">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="f8fb0-170">Avec la suppression de cette limitation, la réorganisation des sections `switch` peut changer le comportement d’un programme.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-170">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="f8fb0-171">Quand les expressions étaient limitées à des valeurs de constante, une seule étiquette `case` pouvait correspondre à la valeur de l’expression `switch`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-171">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="f8fb0-172">La conséquence de cette règle, associée à la règle selon laquelle une section `switch` ne devait pas passer à la section suivante, était que les sections `switch` pouvaient être réorganisées dans n’importe quel ordre sans que cela change le comportement du programme.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-172">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="f8fb0-173">Maintenant, avec les expressions `switch` généralisées, l’ordre de chaque section est important.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-173">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="f8fb0-174">Les expressions `switch` sont évaluées dans l’ordre textuel.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-174">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="f8fb0-175">L’exécution passe à la première étiquette `switch` qui correspond à l’expression `switch`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-175">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="f8fb0-176">Notez que l’expression case `default` est exécutée uniquement si aucune autre étiquette case ne correspond.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-176">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="f8fb0-177">L’expression case `default` est évaluée en dernier, quel que soit son ordre textuel.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-177">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="f8fb0-178">S’il n’existe aucune expression case `default` et aucune correspondance avec les autres instructions `case`, l’exécution continue à l’instruction qui suit l’instruction `switch`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-178">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="f8fb0-179">Aucun code d’étiquettes `case` n’est exécuté.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-179">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="f8fb0-180">Clauses `when` dans les expressions `case`</span><span class="sxs-lookup"><span data-stu-id="f8fb0-180">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="f8fb0-181">Vous pouvez créer des expressions case spéciales pour les formes de surface 0 en ajoutant une clause `when` dans l’étiquette `case`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-181">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="f8fb0-182">Un carré avec une longueur de côté de 0, ou un cercle de rayon 0, a une surface égale à 0.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-182">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="f8fb0-183">Vous spécifiez cette condition en ajoutant une clause `when` dans l’étiquette `case` :</span><span class="sxs-lookup"><span data-stu-id="f8fb0-183">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="f8fb0-184">Cette modification illustre quelques points importants relatifs à la nouvelle syntaxe.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-184">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="f8fb0-185">Tout d’abord, plusieurs étiquettes `case` peuvent être appliquées à une même section `switch`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-185">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="f8fb0-186">Le bloc d’instructions est exécuté quand l’une de ces étiquettes est `true`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-186">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="f8fb0-187">Dans ce cas, si l’expression `switch` est un cercle ou un carré de surface 0, la méthode retourne la constante 0.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-187">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="f8fb0-188">Cet exemple introduit deux variables différentes dans les deux étiquettes `case` du premier bloc `switch`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-188">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="f8fb0-189">Notez que les instructions de ce bloc `switch` n’utilisent ni la variable `c` (pour le cercle), ni la variable `s` (pour le carré).</span><span class="sxs-lookup"><span data-stu-id="f8fb0-189">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="f8fb0-190">Aucune de ces variables n’est assignée de manière définitive dans ce bloc `switch`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-190">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="f8fb0-191">Si l’une de ces étiquettes case correspond, cela signifie qu’une des variables a été assignée.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-191">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="f8fb0-192">Toutefois, il est impossible de déterminer *laquelle* de ces variables a été assignée au moment de la compilation, car les deux étiquettes case peuvent correspondre au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-192">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="f8fb0-193">Pour cette raison, la plupart du temps quand vous utilisez plusieurs étiquettes `case` dans le même bloc, vous ne devez pas introduire une nouvelle variable dans l’instruction `case`, ou vous devez utiliser uniquement la variable dans la clause `when`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-193">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="f8fb0-194">Après avoir ajouté ces formes de surface 0, ajoutez deux autres types de formes, un rectangle et un triangle :</span><span class="sxs-lookup"><span data-stu-id="f8fb0-194">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="f8fb0-195">Avec cet ensemble de modifications, vous avez ajouté des étiquettes `case` pour l’expression case dégénérée, ainsi que des étiquettes et des blocs pour chacune des nouvelles formes.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-195">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="f8fb0-196">Enfin, vous pouvez ajouter une expression case `null` pour garantir que l’argument n’est pas `null` :</span><span class="sxs-lookup"><span data-stu-id="f8fb0-196">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="f8fb0-197">Le comportement spécial pour le modèle `null` est intéressant, car la constante `null` du modèle n’a pas de type, mais elle peut être convertie en un type référence ou un type Nullable.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-197">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="f8fb0-198">Plutôt que de convertir une valeur `null` en un type quelconque, le langage définit qu’une valeur `null` ne correspond à aucun modèle de type, quel que soit le type de la variable au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-198">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="f8fb0-199">En raison de ce comportement, le nouveau modèle de type basé sur `switch` est cohérent par rapport à l’instruction `is` : les instructions `is` retournent toujours `false` quand la valeur vérifiée est `null`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-199">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="f8fb0-200">Il s’avère aussi plus simple : une fois que vous avez vérifié le type, vous n’avez pas besoin d’effectuer de contrôle de valeur null supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-200">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="f8fb0-201">Vous pouvez le constater par le fait qu’aucun contrôle de valeur null ne figure dans les blocs d’expression case des exemples ci-dessus : ces contrôles ne sont pas nécessaires dans la mesure où la correspondance du modèle de type est l’assurance d’une valeur non null.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-201">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="f8fb0-202">Déclarations `var` dans les expressions `case`</span><span class="sxs-lookup"><span data-stu-id="f8fb0-202">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="f8fb0-203">L’introduction de `var` comme l’une des expressions de correspondance fournit de nouvelles règles pour les critères spéciaux.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-203">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="f8fb0-204">La première règle est que la déclaration `var` suit les règles standard d’inférence de type, à savoir que le type est supposé être le type statique de l’expression switch.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-204">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="f8fb0-205">Avec cette règle, il y a toujours correspondance du type.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-205">From that rule, the type always matches.</span></span>

<span data-ttu-id="f8fb0-206">La deuxième règle est qu’une déclaration `var` n’a pas la vérification de valeur Null que d’autres expressions de modèle de type incluent.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-206">The second rule is that a `var` declaration does not have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="f8fb0-207">La variable peut donc être Null, et une vérification de valeur Null est alors nécessaire.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-207">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="f8fb0-208">Ces deux règles signifient que, dans de nombreux cas, une déclaration `var` dans une expression `case` remplit les mêmes conditions qu’une expression `default`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-208">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="f8fb0-209">Étant donné qu’une expression case non définie par défaut est toujours préférée à l’expression case `default`, l’expression case `default` n’est jamais exécutée.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-209">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="f8fb0-210">Le compilateur n’émet pas d’avertissement pour signaler qu’une expression case `default` écrite ne peut pas s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-210">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="f8fb0-211">Cela est cohérent avec le comportement actuel de l’instruction `switch` où tous les cas possibles ont été répertoriés.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-211">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="f8fb0-212">La troisième règle présente les cas où l’utilisation d’une expression case `var` peut être appropriée.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-212">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="f8fb0-213">Imaginez que vous utilisez des critères spéciaux où l’entrée est une chaîne et que vous recherchez des valeurs de commande connues.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-213">Imagine that you are doing a pattern match where the input is a string and you are searching for known command values.</span></span> <span data-ttu-id="f8fb0-214">Vous pouvez écrire un code similaire à celui-ci :</span><span class="sxs-lookup"><span data-stu-id="f8fb0-214">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="f8fb0-215">L’instruction case `var` correspond à une valeur `null`, une chaîne vide ou une chaîne composée uniquement d’espaces blancs.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-215">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="f8fb0-216">Dans le code ci-dessus, l’utilisation de l’opérateur `?.` empêche la levée accidentelle d’une exception <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-216">Notice that the preceding code uses the `?.` operator to ensure that it does not accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="f8fb0-217">L’instruction case `default` gère toutes les autres valeurs de chaîne qui ne sont pas comprises par cet analyseur de commande.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-217">The `default` case handles any other string values that are not understood by this command parser.</span></span>

<span data-ttu-id="f8fb0-218">Il s’agit d’un exemple où vous pouvez envisager d’utiliser une expression case `var` différente d’une expression `default`.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-218">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="f8fb0-219">Conclusions</span><span class="sxs-lookup"><span data-stu-id="f8fb0-219">Conclusions</span></span>

<span data-ttu-id="f8fb0-220">Les *constructions de critères spéciaux* vous permettent de gérer facilement le flux de contrôle entre différents types et variables qui ne sont pas liés par une hiérarchie d’héritage.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-220">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="f8fb0-221">Vous pouvez également contrôler la logique pour utiliser n’importe quelle condition testée sur la variable.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-221">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="f8fb0-222">Ces constructions permettent d’utiliser les modèles et les idiomes dont vous aurez davantage besoin à mesure que vous créez d’autres applications distribuées, où les données et les méthodes qui les manipulent sont séparées.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-222">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="f8fb0-223">Vous remarquerez que les structures de formes utilisées dans cet exemple ne contiennent pas de méthodes, mais uniquement des propriétés en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-223">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="f8fb0-224">Les critères spéciaux peuvent être utilisés avec tous les types de données.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-224">Pattern Matching works with any data type.</span></span> <span data-ttu-id="f8fb0-225">Vous écrivez des expressions qui examinent l’objet et vous prenez des décisions de flux de contrôle en fonction de ces conditions.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-225">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="f8fb0-226">Comparez le code de cet exemple avec la conception qui résulterait de la création d’une hiérarchie de classes pour une `Shape` abstraite et des formes dérivées spécifiques, chacune avec sa propre implémentation d’une méthode virtuelle pour calculer la surface.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-226">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="f8fb0-227">Les expressions de critères spéciaux vous seront souvent d’une grande utilité quand vous manipulerez des données et souhaiterez gérer les questions de stockage de données de façon distincte des questions de comportement.</span><span class="sxs-lookup"><span data-stu-id="f8fb0-227">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

