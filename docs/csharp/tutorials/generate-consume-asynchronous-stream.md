---
title: Générer et consommer des flux asynchrones
description: Ce tutoriel avancé illustre des scénarios où la génération et la consommation de flux asynchrones permet de travailler plus naturellement avec des séquences de données pouvant être générées de façon asynchrone.
ms.date: 02/10/2019
ms.custom: mvc
ms.openlocfilehash: 0fa7c778ca9ce0f0124fcc520dd4de65f2f92ea8
ms.sourcegitcommit: 558d78d2a68acd4c95ef23231c8b4e4c7bac3902
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/09/2019
ms.locfileid: "59308547"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="16ed2-103">Tutoriel : Générer et consommer des flux asynchrones à l’aide de C# 8.0 et de .NET Core 3.0</span><span class="sxs-lookup"><span data-stu-id="16ed2-103">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="16ed2-104">C# 8.0 introduit des **flux asynchrones**, ce qui permet de modéliser une source de données en diffusion en continu lorsque les éléments du flux de données peuvent être récupérés ou générés de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="16ed2-104">C# 8.0 introduces **async streams**, which model a streaming source of data when the elements in the data stream may be retrieved or generated asynchronously.</span></span> <span data-ttu-id="16ed2-105">Les flux asynchrones sont basés sur de nouvelles interfaces introduites dans .NET Standard 2.1 et implémentées dans .NET Core 3.0 afin de fournir un modèle de programmation naturel pour les sources de données asynchrones en diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="16ed2-105">Async streams rely on new interfaces introduced in .NET Standard 2.1 and implemented in .NET Core 3.0 to provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="16ed2-106">Dans ce tutoriel, vous allez apprendre à :</span><span class="sxs-lookup"><span data-stu-id="16ed2-106">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
> * <span data-ttu-id="16ed2-107">créer une source de données qui génère une séquence d’éléments de données de façon asynchrone ;</span><span class="sxs-lookup"><span data-stu-id="16ed2-107">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> * <span data-ttu-id="16ed2-108">consommer cette source de données de façon asynchrone ;</span><span class="sxs-lookup"><span data-stu-id="16ed2-108">Consume that data source asynchronously.</span></span>
> * <span data-ttu-id="16ed2-109">reconnaître quand l’interface et la source de données nouvelles sont préférables aux séquences de données synchrones précédentes.</span><span class="sxs-lookup"><span data-stu-id="16ed2-109">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="16ed2-110">Prérequis</span><span class="sxs-lookup"><span data-stu-id="16ed2-110">Prerequisites</span></span>

<span data-ttu-id="16ed2-111">Vous devez configurer votre ordinateur de façon à exécuter .NET Core, avec le compilateur C# 8.0 bêta.</span><span class="sxs-lookup"><span data-stu-id="16ed2-111">You’ll need to set up your machine to run .NET Core, including the C# 8.0 beta compiler.</span></span> <span data-ttu-id="16ed2-112">Le compilateur bêta C# 8 est disponible à compter de [Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) ou de la dernière version du [Kit SDK .NET Core 3.0 Preview](https://dotnet.microsoft.com/download/dotnet-core/3.0).</span><span class="sxs-lookup"><span data-stu-id="16ed2-112">The C# 8 beta compiler is available starting with [Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the latest [.NET Core 3.0 preview SDK](https://dotnet.microsoft.com/download/dotnet-core/3.0).</span></span> <span data-ttu-id="16ed2-113">Les flux asynchrones sont tout d’abord disponibles dans .NET Core 3.0, préversion 1.</span><span class="sxs-lookup"><span data-stu-id="16ed2-113">Async streams are first available in .NET Core 3.0 preview 1.</span></span>

<span data-ttu-id="16ed2-114">Vous devrez créer un [jeton d’accès GitHub](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) afin de pouvoir accéder au point de terminaison GitHub GraphQL.</span><span class="sxs-lookup"><span data-stu-id="16ed2-114">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="16ed2-115">Sélectionnez les autorisations suivantes pour votre jeton d’accès GitHub :</span><span class="sxs-lookup"><span data-stu-id="16ed2-115">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="16ed2-116">repo:status</span><span class="sxs-lookup"><span data-stu-id="16ed2-116">repo:status</span></span>
- <span data-ttu-id="16ed2-117">public_repo</span><span class="sxs-lookup"><span data-stu-id="16ed2-117">public_repo</span></span>

<span data-ttu-id="16ed2-118">Enregistrez le jeton d’accès à un endroit sûr afin de pouvoir l’utiliser pour accéder au point de terminaison de l’API GitHub.</span><span class="sxs-lookup"><span data-stu-id="16ed2-118">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="16ed2-119">Sécurisez votre jeton d’accès personnel.</span><span class="sxs-lookup"><span data-stu-id="16ed2-119">Keep your personal access token secure.</span></span> <span data-ttu-id="16ed2-120">Tous les logiciels disposant de votre jeton d’accès personnel peuvent effectuer des appels d’API GitHub à l’aide de vos droits d’accès.</span><span class="sxs-lookup"><span data-stu-id="16ed2-120">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="16ed2-121">Ce tutoriel suppose de connaître C# et .NET, y compris Visual Studio ou l’interface CLI .NET Core.</span><span class="sxs-lookup"><span data-stu-id="16ed2-121">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="16ed2-122">Exécutez l’application de démarrage</span><span class="sxs-lookup"><span data-stu-id="16ed2-122">Run the starter application</span></span>

<span data-ttu-id="16ed2-123">Vous pouvez obtenir le code pour l’application de démarrage utilisée dans ce tutoriel dans notre référentiel [dotnet/samples](https://github.com/dotnet/samples), dossier [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start).</span><span class="sxs-lookup"><span data-stu-id="16ed2-123">You can get the code for the starter application used in this tutorial from our [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start) folder.</span></span>

<span data-ttu-id="16ed2-124">L’application de démarrage est une application console qui utilise l’interface [GitHub GraphQL](https://developer.github.com/v4/) pour récupérer des problèmes récents écrits dans le référentiel [dotnet/docs](https://github.com/dotnet/docs).</span><span class="sxs-lookup"><span data-stu-id="16ed2-124">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="16ed2-125">Commencez par examiner le code suivant pour la méthode `Main` de l’application de démarrage :</span><span class="sxs-lookup"><span data-stu-id="16ed2-125">Start by looking at the following code for the starter app `Main` method:</span></span>

[!code-csharp[StarterAppMain](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#StarterAppMain)]

<span data-ttu-id="16ed2-126">Vous pouvez soit définir une variable d’environnement `GitHubKey` sur votre jeton d’accès personnel, soit remplacer le dernier argument dans l’appel par `GenEnvVariable` avec votre jeton d’accès personnel.</span><span class="sxs-lookup"><span data-stu-id="16ed2-126">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="16ed2-127">Ne placez pas votre code d’accès dans le code source si vous envisagez d’enregistrer la source avec d’autres utilisateurs, ou de la placer dans un référentiel de code source partagé.</span><span class="sxs-lookup"><span data-stu-id="16ed2-127">Don't put your access code in source code if you'll be saving the source with others, or putting it in a shared source repository.</span></span>

<span data-ttu-id="16ed2-128">Après la création du client de GitHub, le code dans `Main` crée un objet de rapport de progression et un jeton d’annulation.</span><span class="sxs-lookup"><span data-stu-id="16ed2-128">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="16ed2-129">Une fois que ces objets sont créés, `Main` appelle `runPagedQueryAsync` pour récupérer les 250 problèmes créés les plus récents.</span><span class="sxs-lookup"><span data-stu-id="16ed2-129">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="16ed2-130">Une fois cette tâche terminée, les résultats sont affichés.</span><span class="sxs-lookup"><span data-stu-id="16ed2-130">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="16ed2-131">Lorsque vous exécutez l’application de démarrage, vous pouvez faire quelques observations importantes concernant son fonctionnement.</span><span class="sxs-lookup"><span data-stu-id="16ed2-131">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="16ed2-132">Vous voyez la progression signalée pour chaque page retournée à partir de GitHub.</span><span class="sxs-lookup"><span data-stu-id="16ed2-132">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="16ed2-133">Vous pouvez observer un temps de pause avant le retour de chaque nouvelle page de problèmes par GitHub.</span><span class="sxs-lookup"><span data-stu-id="16ed2-133">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="16ed2-134">Enfin, les problèmes ne sont affichés que lorsque les 10 pages ont été récupérées à partir de GitHub.</span><span class="sxs-lookup"><span data-stu-id="16ed2-134">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="16ed2-135">Examinez l’implémentation</span><span class="sxs-lookup"><span data-stu-id="16ed2-135">Examine the implementation</span></span>

<span data-ttu-id="16ed2-136">L’implémentation révèle pourquoi vous avez observé le comportement décrit dans la section précédente.</span><span class="sxs-lookup"><span data-stu-id="16ed2-136">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="16ed2-137">Examinez the code for `runPagedQueryAsync` :</span><span class="sxs-lookup"><span data-stu-id="16ed2-137">Examine the code for `runPagedQueryAsync`:</span></span>

[!code-csharp[RunPagedQueryStarter](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#RunPagedQuery)]

<span data-ttu-id="16ed2-138">Concentrons-nous sur l’algorithme de pagination et sur la structure asynchrone du code précédent.</span><span class="sxs-lookup"><span data-stu-id="16ed2-138">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="16ed2-139">(Vous pouvez consulter la [documentation GitHub GraphQL](https://developer.github.com/v4/guides/) pour en savoir plus sur l’API GraphQL GitHub.) La méthode `runPagedQueryAsync` énumère les problèmes du plus récent au plus ancien.</span><span class="sxs-lookup"><span data-stu-id="16ed2-139">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="16ed2-140">Elle a besoin de 25 problèmes par page et examine la structure `pageInfo` de la réponse pour continuer avec la page précédente.</span><span class="sxs-lookup"><span data-stu-id="16ed2-140">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="16ed2-141">Cela suit la prise en charge standard de la pagination de GraphQL pour les réponses multipages.</span><span class="sxs-lookup"><span data-stu-id="16ed2-141">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="16ed2-142">La réponse inclut un objet `pageInfo` qui contient une valeur `hasPreviousPages` et une valeur `startCursor` utilisées pour demander la page précédente.</span><span class="sxs-lookup"><span data-stu-id="16ed2-142">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="16ed2-143">Les problèmes se trouvent dans le tableau `nodes`.</span><span class="sxs-lookup"><span data-stu-id="16ed2-143">The issues are in the `nodes` array.</span></span> <span data-ttu-id="16ed2-144">La méthode `runPagedQueryAsync` ajoute ces nœuds à un tableau qui contient tous les résultats de toutes les pages.</span><span class="sxs-lookup"><span data-stu-id="16ed2-144">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="16ed2-145">Après la récupération et la restauration d’une page de résultats, `runPagedQueryAsync` signale la progression et vérifie l’annulation.</span><span class="sxs-lookup"><span data-stu-id="16ed2-145">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="16ed2-146">Si l’annulation a été demandée, `runPagedQueryAsync` lève une <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="16ed2-146">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="16ed2-147">Plusieurs éléments de ce code peuvent être améliorés.</span><span class="sxs-lookup"><span data-stu-id="16ed2-147">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="16ed2-148">Plus important encore, `runPagedQueryAsync` doit allouer du stockage pour tous les problèmes retournés.</span><span class="sxs-lookup"><span data-stu-id="16ed2-148">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="16ed2-149">Cet exemple s’arrête à 250 problèmes, car la récupération de tous les problèmes ouverts nécessiterait beaucoup plus de mémoire pour stocker tous les problèmes récupérées.</span><span class="sxs-lookup"><span data-stu-id="16ed2-149">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="16ed2-150">De plus, les protocoles pour la prise en charge de la progression et de l’annulation rendent l’algorithme plus difficile à comprendre lors de sa première lecture.</span><span class="sxs-lookup"><span data-stu-id="16ed2-150">In addition, the protocols for supporting progress and supporting cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="16ed2-151">Vous devez rechercher la classe de progression pour trouver le rapport de progression.</span><span class="sxs-lookup"><span data-stu-id="16ed2-151">You must look for the progress class to find where progress is reported.</span></span> <span data-ttu-id="16ed2-152">Vous devez également suivre les communications via le <xref:System.Threading.CancellationTokenSource> et son <xref:System.Threading.CancellationToken> associé pour comprendre où l’annulation est demandée et où elle est accordée.</span><span class="sxs-lookup"><span data-stu-id="16ed2-152">You also have to trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="16ed2-153">Les flux asynchrones sont mieux adaptés</span><span class="sxs-lookup"><span data-stu-id="16ed2-153">Async streams provide a better way</span></span>

<span data-ttu-id="16ed2-154">Les flux asynchrones et la prise en charge associée du langage résolvent tous ces problèmes.</span><span class="sxs-lookup"><span data-stu-id="16ed2-154">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="16ed2-155">Le code qui génère la séquence peut désormais utiliser `yield return` pour retourner des éléments dans une méthode qui a été déclarée avec le modificateur `async`.</span><span class="sxs-lookup"><span data-stu-id="16ed2-155">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="16ed2-156">Vous pouvez consommer un flux asynchrone à l’aide une boucle `await foreach` tout comme vous consommez n’importe quelle séquence à l’aide d’une boucle `foreach`.</span><span class="sxs-lookup"><span data-stu-id="16ed2-156">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="16ed2-157">Ces nouvelles fonctionnalités de langage dépendent de trois nouvelles interfaces ajoutées à .NET Standard 2.1 et implémentées dans .NET Core 3.0 :</span><span class="sxs-lookup"><span data-stu-id="16ed2-157">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

```csharp
namespace System.Collections.Generic
{
    public interface IAsyncEnumerable<out T>
    {
        IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default);
    }

    public interface IAsyncEnumerator<out T> : IAsyncDisposable
    {
        T Current { get; }

        ValueTask<bool> MoveNextAsync();
    }
}

namespace System
{
    public interface IAsyncDisposable
    {
        ValueTask DisposeAsync();
    }
}
```

<span data-ttu-id="16ed2-158">Ces trois interfaces sont très certainement familières à la plupart des développeurs C#.</span><span class="sxs-lookup"><span data-stu-id="16ed2-158">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="16ed2-159">Elles se comportent de manière similaire à leurs équivalents synchrones :</span><span class="sxs-lookup"><span data-stu-id="16ed2-159">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="16ed2-160">Il est possible que le type <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType> ne soit pas familier.</span><span class="sxs-lookup"><span data-stu-id="16ed2-160">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="16ed2-161">Le struct `ValueTask` fournit une API similaire à la classe <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="16ed2-161">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> `ValueTask` <span data-ttu-id="16ed2-162">est utilisé dans ces interfaces pour des raisons de performances.</span><span class="sxs-lookup"><span data-stu-id="16ed2-162">is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="16ed2-163">Convertir en flux asynchrones</span><span class="sxs-lookup"><span data-stu-id="16ed2-163">Convert to async streams</span></span>

<span data-ttu-id="16ed2-164">Ensuite, convertissez la méthode `runPagedQueryAsync` pour générer un flux asynchrone.</span><span class="sxs-lookup"><span data-stu-id="16ed2-164">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="16ed2-165">Tout d’abord, modifiez la signature de `runPagedQueryAsync` pour retourner un `IAsyncEnumerable<JToken>` et supprimer les objets de jeton d’annulation et de progression de la liste de paramètres comme indiqué dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="16ed2-165">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

[!code-csharp[FinishedSignature](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#UpdateSignature)]

<span data-ttu-id="16ed2-166">Le code de démarrage traite chaque page lorsqu’elle est récupérée, comme indiqué dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="16ed2-166">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

[!code-csharp[StarterPaging](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#ProcessPage)]

<span data-ttu-id="16ed2-167">Remplacez ces trois lignes par le code suivant :</span><span class="sxs-lookup"><span data-stu-id="16ed2-167">Replace those three lines with the following code:</span></span>

[!code-csharp[FinishedPaging](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#YieldReturnPage)]

<span data-ttu-id="16ed2-168">Vous pouvez également supprimer la déclaration de `finalResults` plus tôt dans cette méthode et l’instruction `return` qui suit la boucle que vous avez modifiée.</span><span class="sxs-lookup"><span data-stu-id="16ed2-168">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="16ed2-169">Vous avez terminé les modifications permettant de générer un flux asynchrone.</span><span class="sxs-lookup"><span data-stu-id="16ed2-169">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="16ed2-170">La méthode terminée doit ressembler au code ci-dessous :</span><span class="sxs-lookup"><span data-stu-id="16ed2-170">The finished method should resemble the code below:</span></span>

[!code-csharp[FinishedGenerate](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#GenerateAsyncStream)]

<span data-ttu-id="16ed2-171">Ensuite, vous modifiez le code qui utilise la collection pour consommer le flux de données asynchrone.</span><span class="sxs-lookup"><span data-stu-id="16ed2-171">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="16ed2-172">Recherchez dans `Main` le code suivant, qui traite l’ensemble des problèmes :</span><span class="sxs-lookup"><span data-stu-id="16ed2-172">Find the following code in `Main` that processes the collection of issues:</span></span>

[!code-csharp[EnumerateOldStyle](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#EnumerateOldStyle)]

<span data-ttu-id="16ed2-173">Remplacez-le par la boucle `await foreach` suivante :</span><span class="sxs-lookup"><span data-stu-id="16ed2-173">Replace that code with the following `await foreach` loop:</span></span>

[!code-csharp[FinishedEnumerateAsyncStream](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#EnumerateAsyncStream)]

<span data-ttu-id="16ed2-174">Vous pouvez obtenir le code du tutoriel terminé dans le référentiel [dotnet/samples](https://github.com/dotnet/samples), dossier [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished).</span><span class="sxs-lookup"><span data-stu-id="16ed2-174">You can get the code for the finished tutorial from the [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="16ed2-175">Exécutez l'application terminée</span><span class="sxs-lookup"><span data-stu-id="16ed2-175">Run the finished application</span></span>

<span data-ttu-id="16ed2-176">Exécutez de nouveau l'application.</span><span class="sxs-lookup"><span data-stu-id="16ed2-176">Run the application again.</span></span> <span data-ttu-id="16ed2-177">Comparez son comportement avec le comportement de l’application de démarrage.</span><span class="sxs-lookup"><span data-stu-id="16ed2-177">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="16ed2-178">La première page de résultats est énumérée dès qu’elle est disponible.</span><span class="sxs-lookup"><span data-stu-id="16ed2-178">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="16ed2-179">Une pause peut être observée lorsque chaque nouvelle page est demandée et récupérée, puis les résultats de la page suivante sont rapidement énumérés.</span><span class="sxs-lookup"><span data-stu-id="16ed2-179">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="16ed2-180">Le bloc `try` / `catch` n’est pas nécessaire pour gérer l’annulation : l’appelant peut arrêter l’énumération de la collection.</span><span class="sxs-lookup"><span data-stu-id="16ed2-180">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="16ed2-181">Le rapport de progression est clair, car le flux asynchrone génère des résultats à mesure que chaque page est téléchargée.</span><span class="sxs-lookup"><span data-stu-id="16ed2-181">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span>

<span data-ttu-id="16ed2-182">Vous pouvez voir des améliorations lors de l’utilisation de mémoire en examinant le code.</span><span class="sxs-lookup"><span data-stu-id="16ed2-182">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="16ed2-183">Vous n’avez plus besoin d’allouer une collection pour stocker tous les résultats avant qu’ils ne soient énumérés.</span><span class="sxs-lookup"><span data-stu-id="16ed2-183">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="16ed2-184">L’appelant peut déterminer comment utiliser les résultats et si une collection de stockage est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="16ed2-184">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="16ed2-185">Exécutez les applications de démarrage et les applications terminées. Ceci vous permettra d’observer les différences entre les implémentations pour vous.</span><span class="sxs-lookup"><span data-stu-id="16ed2-185">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="16ed2-186">À la fin de ce tutoriel, vous pouvez supprimer le jeton d’accès GitHub que vous avez créé au début.</span><span class="sxs-lookup"><span data-stu-id="16ed2-186">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="16ed2-187">Si un attaquant arrive à accéder à ce jeton, il pourrait accéder aux API GitHub à l’aide de vos informations d’identification.</span><span class="sxs-lookup"><span data-stu-id="16ed2-187">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
