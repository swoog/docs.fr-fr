### YamlMime:Tutorial
title: <span data-ttu-id="2c840-101">Explorer C# 7.0 - Tutoriel C# interactif</span><span class="sxs-lookup"><span data-stu-id="2c840-101">Explore C# 7.0 - C# interactive tutorial</span></span>
metadata:
  title: Explorer C# 7.0 - Essayer les nouvelles fonctionnalités de C# 7.0 de manière interactive à l’aide d’un navigateur
  description: Dans ce tutoriel, vous allez utiliser votre navigateur pour explorer C# 7.0 de manière interactive. Vous allez découvrir les nouveaux idiomes que vous pouvez utiliser avec C# 7.0 pour créer du code plus concis et plus lisible.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 1b1de22769c86f75684f41635287a73558d1d15a
  ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
  ms.translationtype: HT
  ms.contentlocale: fr-FR
  ms.lasthandoff: 04/28/2019
  ms.locfileid: "64750383"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="2c840-105">Ce tutoriel vous permet d’explorer les fonctionnalités C# 7.0 de manière interactive, en utilisant votre navigateur pour écrire en C# et voir les résultats de la compilation et de l’exécution de votre code.</span><span class="sxs-lookup"><span data-stu-id="2c840-105">This tutorial lets you explore C# 7.0 features interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="2c840-106">Il contient une série de leçons qui modifient les pratiques antérieures propres à C# et mettent en avant les fonctionnalités plus récentes et plus concises de C# 7.0.</span><span class="sxs-lookup"><span data-stu-id="2c840-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 7.0 features.</span></span> <span data-ttu-id="2c840-107">La suite de cet article fournit une vue d’ensemble de ces fonctionnalités, avec des liens pour explorer chacune d’entre elles.</span><span class="sxs-lookup"><span data-stu-id="2c840-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="2c840-108">Déclarations de variable de sortie à l’emplacement de l’assignation</span><span class="sxs-lookup"><span data-stu-id="2c840-108">Out variable declarations at the assignment location</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"2c840-109\">La syntaxe existante qui prend en charge les paramètres `out` a été améliorée dans cette version.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-109\">The existing syntax that supports `out` parameters has been improved in this version.</span></span> <span data-ttu-id=\"2c840-110\">Cliquez sur le bouton *Entrer en mode focalisation* au bas de cette page, puis essayez le code suivant dans la fenêtre interactive :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-110\">Click the *Enter Focus Mode* button at the bottom of this page, then try the following code in the interactive window:</span></span> \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\n<span data-ttu-id=\"2c840-111\">Vous pouvez désormais déclarer des variables `out` dans la liste d’arguments d’un appel de méthode, au lieu d’écrire une instruction de déclaration distincte.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-111\">You can now declare `out` variables in the argument list of a method call, rather than writing a separate declaration statement.</span></span> <span data-ttu-id=\"2c840-112\">Vous pouvez déplacer la déclaration dans l’appel de méthode.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-112\">You can move the declaration into the method call.</span></span> <span data-ttu-id=\"2c840-113\">Ajoutez le code suivant au bas de la fenêtre interactive :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-113\">Add the following code to the bottom of the interactive window:</span></span>\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\n<span data-ttu-id=\"2c840-114\">Vous pouvez remplacer la déclaration `int` par une déclaration `var`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-114\">You can change the `int` declaration to a `var` declaration.</span></span> <span data-ttu-id=\"2c840-115\">Ajoutez le code suivant à la fenêtre interactive :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-115\">Add the following code to the interactive window:</span></span>\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n<span data-ttu-id=\"2c840-116\">La nouvelle syntaxe offre deux avantages importants par rapport à la syntaxe existante :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-116\">The new syntax provides two important advantages over the existing syntax:</span></span>\n\n* <span data-ttu-id=\"2c840-117\">Le code est plus facile à lire.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-117\">The code is easier to read.</span></span> \n    - <span data-ttu-id=\"2c840-118\">Vous déclarez la variable out à l’endroit où vous l’utilisez, et non pas sur une autre ligne au-dessus.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-118\">You declare the out variable where you use it, not on another line above.</span></span>\n* <span data-ttu-id=\"2c840-119\">Il n’est pas nécessaire d’assigner une valeur initiale.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-119\">No need to assign an initial value.</span></span>\n    - <span data-ttu-id=\"2c840-120\">En déclarant la variable `out` à l’endroit où elle est utilisée dans un appel de méthode, vous ne pouvez pas l’utiliser accidentellement avant qu’elle soit assignée.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-120\">By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.</span></span>\n\n<span data-ttu-id=\"2c840-121\">L’étendue de la variable déclarée correspond à l’étendue qui englobe l’instruction `if`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-121\">The declared variable's scope is the scope enclosing the `if` statement.</span></span> <span data-ttu-id=\"2c840-122\">Cela vous permet d’utiliser la variable par la suite.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-122\">This allows you to use the variable afterwards.</span></span> <span data-ttu-id=\"2c840-123\">Modifiez le dernier bloc `if` comme indiqué dans l’extrait de code suivant.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-123\">Modify the last `if` block as shown in the following snippet.</span></span>\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: <span data-ttu-id="2c840-124">Les tuples créent des structures de données légères.</span><span class="sxs-lookup"><span data-stu-id="2c840-124">Tuples create light-weight data structures</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"2c840-125\">Les tuples sont des structures de données légères contenant plusieurs champs pour représenter les membres de données.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-125\">Tuples are lightweight data structures that contain multiple fields to represent the data members.</span></span> <span data-ttu-id=\"2c840-126\">Les champs ne sont pas validés et vous ne pouvez pas définir vos propres méthodes.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-126\">The fields are not validated, and you cannot define your own methods.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"2c840-127\">Les tuples étaient disponibles avant C# 7.0, mais ils n’étaient pas efficaces et n’avaient aucune prise en charge du langage.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-127\">Tuples were available before C# 7.0, but they were inefficient and had no language support.</span></span> <span data-ttu-id=\"2c840-128\">Cela signifiait que les éléments tuples pouvaient uniquement être référencés comme `Item1`, `Item2`, et ainsi de suite.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-128\">This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on.</span></span> <span data-ttu-id=\"2c840-129\">C# 7.0 introduit la prise en charge du langage pour les tuples, ce qui permet d’utiliser des noms sémantiques pour les champs d’un tuple avec de nouveaux types tuple plus efficaces.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-129\">C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new more efficient tuple types.</span></span>\n\n<span data-ttu-id=\"2c840-130\">Vous pouvez créer un tuple en assignant une valeur à chaque membre nommé :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-130\">You can create a tuple by assigning a value to each named member:</span></span>\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n<span data-ttu-id=\"2c840-131\">Le tuple `namedLetters` contient des champs appelés `Alpha` et `Beta`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-131\">The `namedLetters` tuple contains fields referred to as `Alpha` and `Beta`.</span></span> <span data-ttu-id=\"2c840-132\">Ces noms existent uniquement au moment de la compilation et ne sont pas conservés au moment de l’exécution (lors de l’inspection du tuple par réflexion, par exemple).</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-132\">Those names exist only at compile time and are not preserved at runtime (when inspecting the tuple using reflection, for example).</span></span>\n\n<span data-ttu-id=\"2c840-133\">Dans une assignation de tuple, vous pouvez également spécifier les noms des champs dans la partie droite :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-133\">In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</span></span> \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\n<span data-ttu-id=\"2c840-134\">Vous pouvez spécifier des noms pour les champs à la fois sur le côté gauche et droit de l’assignation, mais les noms sur le côté droit sont ignorés.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-134\">You can specify names for the fields on both the left and right-hand side of the assignment, but the names on the right side are ignored.</span></span>\n\n<span data-ttu-id=\"2c840-135\">Ces derniers sont surtout utiles comme types de retour pour les méthodes `private` et `internal`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-135\">Tuples are most useful as return types for `private` and `internal` methods.</span></span> <span data-ttu-id=\"2c840-136\">Les tuples fournissent une syntaxe simple pour que ces méthodes retournent plusieurs valeurs discrètes.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-136\">Tuples provide a simple syntax for those methods to return multiple discrete values.</span></span>\n\n<span data-ttu-id=\"2c840-137\">La création d’un tuple est plus efficace et plus productive que celle d’une classe ou d’un struct.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-137\">Creating a tuple is more efficient and more productive that creating a class or struct.</span></span> <span data-ttu-id=\"2c840-138\">La syntaxe d’un typle est plus simple et légère pour définir une structure de données qui comporte plusieurs valeurs.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-138\">It has a simpler, lightweight syntax to define a data structure that carries more than one value.</span></span> <span data-ttu-id=\"2c840-139\">L’exemple de méthode ci-dessous retourne les valeurs minimale et maximale trouvées dans une séquence d’entiers.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-139\">The example method below returns the minimum and maximum values found in a sequence of integers.</span></span> <span data-ttu-id=\"2c840-140\">Ajoutez le code suivant dans votre navigateur pour l’essayer :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-140\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\n<span data-ttu-id=\"2c840-141\">Dans certains cas, vous pouvez souhaiter décompresser les membres d’un tuple qui ont été retournés à partir d’une méthode.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-141\">There may be times when you want to unpackage the members of a tuple that were returned from a method.</span></span>  <span data-ttu-id=\"2c840-142\">Pour ce faire, déclarez des variables distinctes pour chacune des valeurs dans le tuple.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-142\">You can do that by declaring separate variables for each of the values in the tuple.</span></span> <span data-ttu-id=\"2c840-143\">Cette opération est appelée *déconstruction* du tuple.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-143\">This is called *deconstructing* the tuple.</span></span> <span data-ttu-id=\"2c840-144\">Ajoutez le code suivant dans votre navigateur pour l’essayer :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-144\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<span data-ttu-id=\"2c840-145\">À l’usage, vous vous rendrez compte que vous n’utilisez pas tous les membres d’un résultat de tuple.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-145\">As you work with tuples, you'll often find that you don't use all of the members of a tuple result.</span></span> <span data-ttu-id=\"2c840-146\">Le cas échéant, vous pouvez ignorer une ou plusieurs des valeurs retournées à l’aide de `_` à la place d’une variable.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-146\">When that happens, you can discard one or more of the returned values by using `_` in place of a variable.</span></span> <span data-ttu-id=\"2c840-147\">Ajoutez le code suivant dans votre navigateur pour l’essayer :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-147\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\n<span data-ttu-id=\"2c840-148\">Vous pouvez approfondir vos connaissances sur les tuples avec [cet article](../../tuples.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-148\">You can learn more in depth about tuples in the [tuples article](../../tuples.md).</span></span>\n<span data-ttu-id=\"2c840-149\">Vous pouvez approfondir vos connaissances sur les éléments ignorés avec [cet article](../../discards.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-149\">You can learn more about discards in the [discards article](../../discards.md).</span></span>\n"
- title: <span data-ttu-id="2c840-150">Utiliser le modèle de type avec l’expression is</span><span class="sxs-lookup"><span data-stu-id="2c840-150">Use the type pattern with the is expression</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="2c840-151">L’expression de modèle `is` étend l’[opérateur `is`](../../language-reference/keywords/is.md#pattern-matching-with-is) classique pour interroger un objet au-delà de son type.</span><span class="sxs-lookup"><span data-stu-id="2c840-151">The `is` pattern expression extends the familiar [`is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) to query an object beyond its type.</span></span>


    <span data-ttu-id="2c840-152">Essayez le code suivant dans votre fenêtre de navigateur :</span><span class="sxs-lookup"><span data-stu-id="2c840-152">Try the following code in your browser window:</span></span>


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    <span data-ttu-id="2c840-153">Remplacez la déclaration de variable par une chaîne :</span><span class="sxs-lookup"><span data-stu-id="2c840-153">Change the variable declaration to a string instead:</span></span>


    ```csharp

    object count = "5";

    ```


    <span data-ttu-id="2c840-154">À présent, l’expression `is` a la valeur false, donc la branche `else` est exécutée.</span><span class="sxs-lookup"><span data-stu-id="2c840-154">Now, the `is` expression is false, so the `else` branch is executed.</span></span> <span data-ttu-id="2c840-155">Essayez de remplacer `count` par `number` dans la branche else :</span><span class="sxs-lookup"><span data-stu-id="2c840-155">Try to change `count` to `number` in the else branch:</span></span>


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    <span data-ttu-id="2c840-156">Le code ci-dessus n’est pas compilé, car `number` n’est pas assigné dans la branche `else`.</span><span class="sxs-lookup"><span data-stu-id="2c840-156">The above won't compile because `number` isn't assigned in the `else` branch.</span></span> <span data-ttu-id="2c840-157">Il est attribué uniquement dans la branche `true` de l’instruction `if`.</span><span class="sxs-lookup"><span data-stu-id="2c840-157">It's only assigned in the `true` branch of the `if` statement.</span></span>


    <span data-ttu-id="2c840-158">Le modèle de type d’expression `is` est utile quand vous avez un petit nombre de types pour le test.</span><span class="sxs-lookup"><span data-stu-id="2c840-158">The `is` expression type pattern is useful when you have a small number of types to test against.</span></span> <span data-ttu-id="2c840-159">Souvent, vous pouvez avoir besoin de tester plusieurs types.</span><span class="sxs-lookup"><span data-stu-id="2c840-159">Often, you may need to test multiple types.</span></span> <span data-ttu-id="2c840-160">Ce qui requiert l’instruction `switch` de critères spéciaux.</span><span class="sxs-lookup"><span data-stu-id="2c840-160">That requires the pattern matching `switch` statement.</span></span>
- title: <span data-ttu-id="2c840-161">Critères spéciaux dans l’instruction switch</span><span class="sxs-lookup"><span data-stu-id="2c840-161">Pattern matching in the switch statement</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="2c840-162">L’*expression de correspondance* a une syntaxe familière, basée sur l’instruction `switch` qui fait déjà partie du langage C#.</span><span class="sxs-lookup"><span data-stu-id="2c840-162">The *match expression* has a familiar syntax, based on the `switch` statement already part of the C# language.</span></span> <span data-ttu-id="2c840-163">Commençons par un petit exemple basé sur la syntaxe d’expression `is` que vous avez explorée à la page précédente :</span><span class="sxs-lookup"><span data-stu-id="2c840-163">Let's start with a small sample based on the `is` expression syntax you explored on the previous page:</span></span>


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    <span data-ttu-id="2c840-164">Le code précédent recherche un `int` ou `null`.</span><span class="sxs-lookup"><span data-stu-id="2c840-164">The preceding code checks for an `int` or `null`.</span></span> <span data-ttu-id="2c840-165">Un type sur deux a atteint le cas par défaut.</span><span class="sxs-lookup"><span data-stu-id="2c840-165">Every other type reached the default case.</span></span> <span data-ttu-id="2c840-166">Ajoutez les deux lignes suivantes pour vérifier le comportement :</span><span class="sxs-lookup"><span data-stu-id="2c840-166">Add the following two lines to verify the behavior:</span></span>


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    <span data-ttu-id="2c840-167">L’expression `switch` convertit un type nullable en son type correspondant.</span><span class="sxs-lookup"><span data-stu-id="2c840-167">The `switch` expression will convert a nullable type to its corresponding type.</span></span> <span data-ttu-id="2c840-168">Ajoutez le code suivant pour vérifier :</span><span class="sxs-lookup"><span data-stu-id="2c840-168">Add the following to verify:</span></span>


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    <span data-ttu-id="2c840-169">Vous pouvez ajouter autant d’autres expressions de modèle de type aux instructions switch.</span><span class="sxs-lookup"><span data-stu-id="2c840-169">You can add any number of other type pattern expressions to the switch statements.</span></span> <span data-ttu-id="2c840-170">Ajoutez-les avant le cas `null` :</span><span class="sxs-lookup"><span data-stu-id="2c840-170">Add these before the `null` case:</span></span>


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    <span data-ttu-id="2c840-171">Vérifiez qu’elles fonctionnent en ajoutant les tests suivants :</span><span class="sxs-lookup"><span data-stu-id="2c840-171">Make sure these work by adding the following tests:</span></span>


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    <span data-ttu-id="2c840-172">Les expressions de correspondance prennent également en charge les constantes.</span><span class="sxs-lookup"><span data-stu-id="2c840-172">The match expressions also support constants.</span></span> <span data-ttu-id="2c840-173">Cela peut faire gagner du temps en éliminant les cas simples :</span><span class="sxs-lookup"><span data-stu-id="2c840-173">This can save time by factoring out simple cases:</span></span>


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    <span data-ttu-id="2c840-174">Vous devez ajouter le cas précédent *avant* l’expression `case int:`.</span><span class="sxs-lookup"><span data-stu-id="2c840-174">You must add the preceding case *before* the `case int:` expression.</span></span> <span data-ttu-id="2c840-175">Si vous l’ajoutez après ce cas, le compilateur vous avertit qu’il a déjà été géré par un cas précédent.</span><span class="sxs-lookup"><span data-stu-id="2c840-175">If you add it after that case, the compiler warns you that it has already been handled by a previous case.</span></span>


    <span data-ttu-id="2c840-176">Vous pouvez ajouter une clause `when` à n’importe quel cas de modèle pour pouvoir tester d’autres conditions au-delà d’un type ou d’une valeur constante.</span><span class="sxs-lookup"><span data-stu-id="2c840-176">You can add a `when` clause to any pattern case so that you can test other conditions beyond a type or a constant value.</span></span> <span data-ttu-id="2c840-177">Essayez-la en ajoutant le cas suivant au-dessus du cas `string` général :</span><span class="sxs-lookup"><span data-stu-id="2c840-177">Try it by adding the following case above the general `string` case:</span></span>


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    <span data-ttu-id="2c840-178">Faites le test avec quelque chose comme le code suivant :</span><span class="sxs-lookup"><span data-stu-id="2c840-178">Test it with something like the following code:</span></span>


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    <span data-ttu-id="2c840-179">La nouvelle syntaxe des expressions de critères spéciaux facilite la création d’algorithmes de répartition en utilisant une syntaxe claire et concise basée sur le type ou d’autres propriétés d’un objet.</span><span class="sxs-lookup"><span data-stu-id="2c840-179">The new syntax for pattern matching expressions makes it easier to create dispatch algorithms using a clear and concise syntax based on an object's type or other properties.</span></span> <span data-ttu-id="2c840-180">Les expressions de critères spéciaux permettent ces constructions sur les types de données qui ne sont pas liés par héritage.</span><span class="sxs-lookup"><span data-stu-id="2c840-180">Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</span></span>


    <span data-ttu-id="2c840-181">Pour plus d’informations sur les critères spéciaux, consultez l’article dédié aux [critères spéciaux en C#](../../pattern-matching.md).</span><span class="sxs-lookup"><span data-stu-id="2c840-181">You can learn more about pattern matching in the article dedicated to [pattern matching in C#](../../pattern-matching.md).</span></span>
- title: <span data-ttu-id="2c840-182">Optimiser le stockage en mémoire à l’aide de variables locales et retours ref</span><span class="sxs-lookup"><span data-stu-id="2c840-182">Optimize memory storage using ref locals and returns</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="2c840-183">Cette fonctionnalité active les algorithmes qui utilisent et retournent des références à des variables définies ailleurs.</span><span class="sxs-lookup"><span data-stu-id="2c840-183">This feature enables algorithms that use and return references to variables defined elsewhere.</span></span> <span data-ttu-id="2c840-184">Un seul exemple fait intervenir des matrices de grande taille et la recherche d’un emplacement unique correspondant à certaines caractéristiques.</span><span class="sxs-lookup"><span data-stu-id="2c840-184">One example is with large matrices and finding a single location with certain characteristics.</span></span> <span data-ttu-id="2c840-185">Une seule méthode retournerait les deux index à un emplacement unique dans la matrice :</span><span class="sxs-lookup"><span data-stu-id="2c840-185">One method would return the two indices a single location in the matrix:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    <span data-ttu-id="2c840-186">Vous pouvez tester cette méthode en utilisant le code suivant :</span><span class="sxs-lookup"><span data-stu-id="2c840-186">You can test this method using the following code:</span></span>


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    <span data-ttu-id="2c840-187">Cette méthode `Find` retourne les index de l’élément dans la matrice.</span><span class="sxs-lookup"><span data-stu-id="2c840-187">This `Find` method returns the indices to the item in the matrix.</span></span> <span data-ttu-id="2c840-188">Cela conduit les appelants à écrire du code qui utilise ces index pour déréférencer la matrice et modifier un seul élément.</span><span class="sxs-lookup"><span data-stu-id="2c840-188">That leads callers to write code that uses those indices to dereference the matrix and modify a single element.</span></span> <span data-ttu-id="2c840-189">Il est préférable d’écrire une méthode qui retourne une *référence* à l’élément de la matrice que vous voulez changer.</span><span class="sxs-lookup"><span data-stu-id="2c840-189">You'd rather write a method that returns a *reference* to the element of the matrix that you want to change.</span></span>


    <span data-ttu-id="2c840-190">Examinons en détail une série de changements pour illustrer la fonctionnalité de variable locale de référence et montrer comment créer une méthode qui retourne une référence à un stockage interne.</span><span class="sxs-lookup"><span data-stu-id="2c840-190">Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</span></span> <span data-ttu-id="2c840-191">Tout au long du processus, vous allez apprendre les règles des fonctionnalités de variable locale de référence et de retour de référence qui vous protègent contre toute mauvaise utilisation accidentelle.</span><span class="sxs-lookup"><span data-stu-id="2c840-191">Along the way, you'll learn the rules of the ref return and ref local feature that protect you from accidentally misusing it.</span></span>


    <span data-ttu-id="2c840-192">Commencez par modifier la déclaration de méthode `Find` pour qu’elle retourne un `ref int` au lieu d’un tuple.</span><span class="sxs-lookup"><span data-stu-id="2c840-192">Start by modifying the `Find` method declaration so that it returns a `ref int` instead of a tuple.</span></span>


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    <span data-ttu-id="2c840-193">Modifiez l’instruction return pour retourner l’élément au niveau des index corrects :</span><span class="sxs-lookup"><span data-stu-id="2c840-193">Modify the return statement to return the item at the correct indices:</span></span>


    ```csharp

    return matrix[i,j];

    ```


    <span data-ttu-id="2c840-194">Modifiez le retour final pour lever plutôt une exception :</span><span class="sxs-lookup"><span data-stu-id="2c840-194">Change the final return to throw an exception instead:</span></span>


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    <span data-ttu-id="2c840-195">Notez que ce code ne se compile pas.</span><span class="sxs-lookup"><span data-stu-id="2c840-195">Note that this won't compile.</span></span> <span data-ttu-id="2c840-196">La déclaration de méthode indique un retour `ref`, alors que l’instruction return spécifie un retour de valeur.</span><span class="sxs-lookup"><span data-stu-id="2c840-196">The method declaration indicates a `ref` return, but the return statement specifies a value return.</span></span> <span data-ttu-id="2c840-197">Vous devez ajouter le mot clé `ref` à chaque instruction return.</span><span class="sxs-lookup"><span data-stu-id="2c840-197">You must add the `ref` keyword to each return statement.</span></span> <span data-ttu-id="2c840-198">Cela indique un retour par référence, et permet aux développeurs qui lisent le code ultérieurement de ne pas oublier que la méthode effectue un retour par référence :</span><span class="sxs-lookup"><span data-stu-id="2c840-198">That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</span></span>


    ```csharp

    return ref matrix[i,j];

    ```


    <span data-ttu-id="2c840-199">Maintenant que la méthode retourne une référence à la valeur entière dans la matrice, vous devez modifier l’emplacement où elle est appelée.</span><span class="sxs-lookup"><span data-stu-id="2c840-199">Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</span></span> <span data-ttu-id="2c840-200">La déclaration `var` signifie que `valItem` est désormais un `int` au lieu d’un tuple.</span><span class="sxs-lookup"><span data-stu-id="2c840-200">The `var` declaration means that `valItem` is now an `int` rather than a tuple.</span></span> <span data-ttu-id="2c840-201">Remplacez le code appelant par le suivant :</span><span class="sxs-lookup"><span data-stu-id="2c840-201">Change the calling code to the following:</span></span>


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    <span data-ttu-id="2c840-202">La deuxième instruction `WriteLine` dans l’exemple ci-dessus affiche la valeur `42`, et non la valeur `24`.</span><span class="sxs-lookup"><span data-stu-id="2c840-202">The second `WriteLine` statement in the example above prints out the value `42`, not `24`.</span></span> <span data-ttu-id="2c840-203">La variable `valItem` est un `int`, et non un `ref int`.</span><span class="sxs-lookup"><span data-stu-id="2c840-203">The variable `valItem` is an `int`, not a `ref int`.</span></span> <span data-ttu-id="2c840-204">Le mot clé `var` permet au compilateur de spécifier le type, mais il n’ajoutera pas implicitement le modificateur `ref`.</span><span class="sxs-lookup"><span data-stu-id="2c840-204">The `var` keyword enables the compiler to specify the type but will not implicitly add the `ref` modifier.</span></span> <span data-ttu-id="2c840-205">Au lieu de cela, la valeur référencée par `ref return` est *copiée* dans la variable dans la partie gauche de l’assignation.</span><span class="sxs-lookup"><span data-stu-id="2c840-205">Instead, the value referred to by the `ref return` is *copied* to the variable on the left-hand side of the assignment.</span></span> <span data-ttu-id="2c840-206">La variable n’est pas une variable `ref` locale.</span><span class="sxs-lookup"><span data-stu-id="2c840-206">The variable is not a `ref` local.</span></span>


    <span data-ttu-id="2c840-207">Afin de modifier la référence retournée, vous devez ajouter le modificateur `ref` à la déclaration de variable locale et avant l’appel à `Find` pour faire de la variable une référence quand la valeur de retour est une référence.</span><span class="sxs-lookup"><span data-stu-id="2c840-207">In order to modify the returned reference, you need to add the `ref` modifier to the local variable declaration and before the call to `Find` to make the variable a reference when the return value is a reference.</span></span> <span data-ttu-id="2c840-208">Modifiez le code de test dans votre navigateur pour qu’il corresponde au suivant :</span><span class="sxs-lookup"><span data-stu-id="2c840-208">Modify the test code in your browser to match the following:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return object by reference")]


    <span data-ttu-id="2c840-209">À présent, la seconde instruction `WriteLine` dans l’exemple ci-dessus imprime la valeur `24`, indiquant que le stockage dans la matrice a été modifié.</span><span class="sxs-lookup"><span data-stu-id="2c840-209">Now, the second `WriteLine` statement in the example above prints out the value `24`, indicating that the storage in the matrix has been modified.</span></span> <span data-ttu-id="2c840-210">La variable locale a été déclarée avec le modificateur `ref`, et elle prendra un retour `ref`.</span><span class="sxs-lookup"><span data-stu-id="2c840-210">The local variable has been declared with the `ref` modifier, and it will take a `ref` return.</span></span> <span data-ttu-id="2c840-211">Vous devez initialiser une variable `ref` au moment de sa déclaration ; vous ne pouvez pas séparer la déclaration et l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="2c840-211">You must initialize a `ref` variable when it is declared; you cannot split the declaration and the initialization.</span></span>


    <span data-ttu-id="2c840-212">Le langage C# a trois autres règles qui vous protègent contre une mauvaise utilisation des variables locales et des retours `ref` :</span><span class="sxs-lookup"><span data-stu-id="2c840-212">The C# language has three other rules that protect you from misusing the `ref` locals and returns:</span></span>


    * <span data-ttu-id="2c840-213">Vous ne pouvez pas affecter une valeur de retour de méthode standard à une variable locale `ref`.</span><span class="sxs-lookup"><span data-stu-id="2c840-213">You cannot assign a standard method return value to a `ref` local variable.</span></span>

    * <span data-ttu-id="2c840-214">Vous ne pouvez pas retourner un `ref` à une variable dont la durée de vie ne s’étend pas au-delà de l’exécution de la méthode.</span><span class="sxs-lookup"><span data-stu-id="2c840-214">You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.</span></span>

    * <span data-ttu-id="2c840-215">Les variables locales et les retours `ref` ne peuvent pas être utilisés avec les méthodes Async.</span><span class="sxs-lookup"><span data-stu-id="2c840-215">`ref` locals and returns can't be used with async methods.</span></span>


    <span data-ttu-id="2c840-216">L’ajout de variables locales ref et de retours ref permet d’utiliser des algorithmes qui sont plus efficaces en évitant la copie de valeurs ou d’effectuer plusieurs fois des opérations de déréférencement.</span><span class="sxs-lookup"><span data-stu-id="2c840-216">The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values or performing dereferencing operations multiple times.</span></span>


    <span data-ttu-id="2c840-217">Pour plus d'informations, voir l’article [ref, mot clé](../../language-reference/keywords/ref.md).</span><span class="sxs-lookup"><span data-stu-id="2c840-217">For more information, see the [ref keyword](../../language-reference/keywords/ref.md) article.</span></span>
- title: <span data-ttu-id="2c840-218">Réduire l’accès au code avec des fonctions locales</span><span class="sxs-lookup"><span data-stu-id="2c840-218">Minimize access to code with local functions</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"2c840-219\">Vous pouvez à présent déclarer des fonctions locales qui sont imbriquées dans d’autres fonctions.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-219\">You can now declare local functions that are nested inside other functions.</span></span> <span data-ttu-id=\"2c840-220\">Cela vous permet de réduire la visibilité de ces fonctions.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-220\">This enables you to minimize the visibility of these functions.</span></span> <span data-ttu-id=\"2c840-221\">Il existe trois cas d’usage évidents pour les fonctions locales :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-221\">There are three obvious use cases for local functions:</span></span>\n\n- <span data-ttu-id=\"2c840-222\">Fonctions récursives.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-222\">Recursive functions.</span></span>\n- <span data-ttu-id=\"2c840-223\">Méthodes d’itérateur.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-223\">Iterator methods.</span></span>\n- <span data-ttu-id=\"2c840-224\">Méthodes asynchrones.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-224\">Asynchronous methods.</span></span>\n\n<span data-ttu-id=\"2c840-225\">Commençons par les méthodes récursives.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-225\">Let's start with recursive methods.</span></span> <span data-ttu-id=\"2c840-226\">Essayez le code suivant dans le navigateur pour calculer `6!` (factorielle) :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-226\">Try the following code in the browser to calculate `6!` (factorial):</span></span>\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\n<span data-ttu-id=\"2c840-227\">Les fonctions locales sont un excellent moyen d’implémenter des algorithmes récursifs.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-227\">Local functions are a great way to implement recursive algorithms.</span></span> <span data-ttu-id=\"2c840-228\">D’autres utilisations courantes concernent les méthodes d’itérateur publiques et les méthodes asynchrones publiques.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-228\">Other common uses are for public iterator methods and public async methods.</span></span> <span data-ttu-id=\"2c840-229\">Ces deux types de méthodes génèrent du code qui signale les erreurs plus tard que ce qu’attendent les programmeurs.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-229\">Both types of methods generate     code that reports errors later than programmers might expect.</span></span> <span data-ttu-id=\"2c840-230\">Dans le cas des méthodes iterator, toute exception est observée uniquement lors de l’appel de code qui énumère la séquence retournée.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-230\">In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</span></span> <span data-ttu-id=\"2c840-231\">Dans le cas des méthodes async, toute exception est observée uniquement quand le `Task` retourné est attendu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-231\">In the case of async methods, any exceptions are only observed when the returned `Task` is awaited.</span></span>\n\n<span data-ttu-id=\"2c840-232\">Les méthodes d’itérateur sont plus faciles à explorer dans le navigateur, nous allons donc les utiliser dans cette exploration.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-232\">Iterator methods are easier to explore in the browser, so let's use those in this exploration.</span></span> <span data-ttu-id=\"2c840-233\">Essayez le code suivant qui appelle une méthode d’itérateur dans votre navigateur :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-233\">Try the following code that calls an iterator method in your browser:</span></span>\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\n<span data-ttu-id=\"2c840-234\">Exécutez le code.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-234\">Run the code.</span></span> <span data-ttu-id=\"2c840-235\">Remarquez que l’exception est levée quand le code commence à itérer le deuxième jeu de résultats.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-235\">Notice that the exception is thrown when the code begins iterating the second result set.</span></span> <span data-ttu-id=\"2c840-236\">Le code qui itère le premier jeu de résultats a déjà été exécuté.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-236\">The code that iterates the first result set has already run.</span></span> <span data-ttu-id=\"2c840-237\">Cet exemple est petit et ne change pas les structures de données, il est donc inoffensif et facile à corriger.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-237\">This sample is both small and doesn't change any data structures, so it's harmless and easy to fix.</span></span> <span data-ttu-id=\"2c840-238\">Mais, dans un programme plus important, où les deux objets itérateur peuvent être créés dans des méthodes enfants différentes, la cause racine peut être difficile à trouver.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-238\">But, in a larger program, where the two iterator objects may be created in different child methods the root cause could be hard to find.</span></span> <span data-ttu-id=\"2c840-239\">Si la première méthode d’itérateur a changé l’état des données, cela peut même entraîner une altération des données.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-239\">If the first iterator method changed data state, it could even cause data corruption.</span></span> <span data-ttu-id=\"2c840-240\">Vous préféreriez que l’exception soit immédiatement levée, avant qu’un travail quelconque soit effectué.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-240\">You'd prefer the exception was thrown immediately, before any work is done.</span></span> <span data-ttu-id=\"2c840-241\">Vous pouvez refactoriser le code afin que la méthode publique valide tous les arguments et qu’une fonction locale effectue l’énumération :</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-241\">You can refactor the code so that the public method validates all arguments, and a local function performs the enumeration:</span></span>\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\n<span data-ttu-id=\"2c840-242\">La version précédente indique clairement que la méthode locale est référencée uniquement dans le contexte de la méthode externe.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-242\">The preceding version makes it clear that the local method is referenced only in the context of the outer method.</span></span> <span data-ttu-id=\"2c840-243\">Les règles relatives aux fonctions locales peuvent également garantir qu’un développeur ne peut pas appeler accidentellement la fonction locale à partir d’un autre emplacement dans la classe et ignorer la validation d’argument.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-243\">The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</span></span>\n\n<span data-ttu-id=\"2c840-244\">Il est possible d’utiliser la même technique avec les méthodes `async` pour garantir que les exceptions résultant de la validation d’argument sont levées avant le début de la tâche asynchrone.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-244\">The same technique can be employed with `async` methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"2c840-245\">Certaines des conceptions prises en charge par les fonctions locales peuvent également être effectuées à l’aide d’*expressions lambda*.</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-245\">Some of the designs that are supported by local functions could also be accomplished using *lambda expressions*.</span></span> <span data-ttu-id=\"2c840-246\">Si cela vous intéresse, [reportez-vous aux informations supplémentaires décrivant ce qui différencie ces deux processus](../../local-functions-vs-lambdas.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"2c840-246\">Those interested can [read more about the differences](../../local-functions-vs-lambdas.md).</span></span>\n"
- content: >
    <span data-ttu-id="2c840-247">Vous avez terminé l’exploration des nouvelles fonctionnalités majeures en C# 7.</span><span class="sxs-lookup"><span data-stu-id="2c840-247">You've completed an exploration of the major new features in C# 7.</span></span> <span data-ttu-id="2c840-248">Essayez-les à présent par vous-même dans vos applications.</span><span class="sxs-lookup"><span data-stu-id="2c840-248">Now try them yourself in your applications.</span></span> <span data-ttu-id="2c840-249">Vous pouvez voir la liste complète dans l’article sur les [nouveautés de C# 7](../../whats-new/csharp-7.md).</span><span class="sxs-lookup"><span data-stu-id="2c840-249">You can see the full list in the [what's new in C# 7](../../whats-new/csharp-7.md) article.</span></span>
