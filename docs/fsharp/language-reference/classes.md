---
title: Classes (F#)
description: 'Découvrez comment F # Classes sont des types qui représentent des objets qui peuvent avoir des propriétés, méthodes et événements.'
ms.date: 05/16/2016
ms.openlocfilehash: 71cd713d192d28565e879b79b2fc9e0530e5f841
ms.sourcegitcommit: ba5c189bf44d44204a3e8838e59ec378a62d82f3
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/12/2018
ms.locfileid: "44705529"
---
# <a name="classes"></a><span data-ttu-id="0d064-103">Classes</span><span class="sxs-lookup"><span data-stu-id="0d064-103">Classes</span></span>

<span data-ttu-id="0d064-104">*Classes* sont des types qui représentent des objets qui peuvent avoir des propriétés, méthodes et événements.</span><span class="sxs-lookup"><span data-stu-id="0d064-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>

## <a name="syntax"></a><span data-ttu-id="0d064-105">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="0d064-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="0d064-106">Notes</span><span class="sxs-lookup"><span data-stu-id="0d064-106">Remarks</span></span>

<span data-ttu-id="0d064-107">Les classes représentent la description fondamentale des types d’objet .NET ; la classe est le concept de type principal qui prend en charge la programmation orientée objet en F #.</span><span class="sxs-lookup"><span data-stu-id="0d064-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="0d064-108">Dans la syntaxe précédente, le `type-name` est n’importe quel identificateur valid.</span><span class="sxs-lookup"><span data-stu-id="0d064-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="0d064-109">Le `type-params` décrit les paramètres de type générique facultatifs.</span><span class="sxs-lookup"><span data-stu-id="0d064-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="0d064-110">Il se compose des noms de paramètre de type et des contraintes placé entourés crochets pointus (`<` et `>`).</span><span class="sxs-lookup"><span data-stu-id="0d064-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="0d064-111">Pour plus d’informations, consultez [génériques](generics/index.md) et [contraintes](generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="0d064-111">For more information, see [Generics](generics/index.md) and [Constraints](generics/constraints.md).</span></span> <span data-ttu-id="0d064-112">Le `parameter-list` décrit les paramètres du constructeur.</span><span class="sxs-lookup"><span data-stu-id="0d064-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="0d064-113">Le modificateur d’accès associé au type ; le second se rapporte au constructeur principal.</span><span class="sxs-lookup"><span data-stu-id="0d064-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="0d064-114">Dans les deux cas, la valeur par défaut est `public`.</span><span class="sxs-lookup"><span data-stu-id="0d064-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="0d064-115">Vous spécifiez la classe de base pour une classe à l’aide de la `inherit` mot clé.</span><span class="sxs-lookup"><span data-stu-id="0d064-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="0d064-116">Vous devez fournir des arguments entre parenthèses, pour le constructeur de classe de base.</span><span class="sxs-lookup"><span data-stu-id="0d064-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="0d064-117">Vous déclarez des champs ou des valeurs qui sont locales à la classe à l’aide de fonction `let` liaisons et vous devez suivre les règles générales pour `let` liaisons.</span><span class="sxs-lookup"><span data-stu-id="0d064-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="0d064-118">Le `do-bindings` section comprend le code à exécuter après la construction de l’objet.</span><span class="sxs-lookup"><span data-stu-id="0d064-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="0d064-119">Le `member-list` se compose de constructeurs supplémentaires, instance déclarations de méthode statique, les déclarations d’interface, liaisons abstraites et des déclarations de propriété et d’événement.</span><span class="sxs-lookup"><span data-stu-id="0d064-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="0d064-120">Ceux-ci sont décrits dans [membres](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="0d064-120">These are described in [Members](members/index.md).</span></span>

<span data-ttu-id="0d064-121">Le `identifier` qui est utilisé avec le paramètre facultatif `as` mot clé donne un nom à la variable d’instance, ou auto-identificateur, qui peut être utilisé dans la définition de type pour faire référence à l’instance du type.</span><span class="sxs-lookup"><span data-stu-id="0d064-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="0d064-122">Pour plus d’informations, consultez la section auto-identificateurs plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="0d064-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="0d064-123">Les mots clés `class` et `end` qui marquent le début et fin de la définition sont facultatifs.</span><span class="sxs-lookup"><span data-stu-id="0d064-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="0d064-124">Types mutuellement récursifs, qui sont des types qui se référencent mutuellement, sont joints avec le `and` mot clé simplement comme mutuellement fonctions récursives.</span><span class="sxs-lookup"><span data-stu-id="0d064-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="0d064-125">Pour obtenir un exemple, consultez la section Types mutuellement récursifs.</span><span class="sxs-lookup"><span data-stu-id="0d064-125">For an example, see the section Mutually Recursive Types.</span></span>

## <a name="constructors"></a><span data-ttu-id="0d064-126">Constructeurs</span><span class="sxs-lookup"><span data-stu-id="0d064-126">Constructors</span></span>

<span data-ttu-id="0d064-127">Le constructeur est un code qui crée une instance du type classe.</span><span class="sxs-lookup"><span data-stu-id="0d064-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="0d064-128">Constructeurs des classes fonctionnent un peu différemment dans F # que dans d’autres langages .NET.</span><span class="sxs-lookup"><span data-stu-id="0d064-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="0d064-129">Dans une classe F #, il y a toujours un constructeur principal dont les arguments sont décrits dans le `parameter-list` qui suit le nom de type, et dont le corps se compose de la `let` (et `let rec`) liaisons au début de la déclaration de classe et le `do`liaisons qui suivent.</span><span class="sxs-lookup"><span data-stu-id="0d064-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="0d064-130">Les arguments du constructeur principal sont dans la portée dans l’ensemble de la déclaration de classe.</span><span class="sxs-lookup"><span data-stu-id="0d064-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="0d064-131">Vous pouvez ajouter des constructeurs supplémentaires en utilisant le `new` mot clé pour ajouter un membre, comme suit :</span><span class="sxs-lookup"><span data-stu-id="0d064-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="0d064-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="0d064-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="0d064-133">Le corps du nouveau constructeur doit appeler le constructeur principal qui est spécifié en haut de la déclaration de classe.</span><span class="sxs-lookup"><span data-stu-id="0d064-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="0d064-134">L’exemple suivant illustre ce concept.</span><span class="sxs-lookup"><span data-stu-id="0d064-134">The following example illustrates this concept.</span></span> <span data-ttu-id="0d064-135">Dans le code suivant, `MyClass` a deux constructeurs : un constructeur principal qui prend deux arguments et un autre constructeur qui n’accepte aucun argument.</span><span class="sxs-lookup"><span data-stu-id="0d064-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a><span data-ttu-id="0d064-136">Let et liaisons do</span><span class="sxs-lookup"><span data-stu-id="0d064-136">let and do Bindings</span></span>

<span data-ttu-id="0d064-137">Le `let` et `do` liaisons dans une définition de classe forment le corps du constructeur de classe principal, et par conséquent, elles s’exécutent chaque fois qu’une instance de classe est créée.</span><span class="sxs-lookup"><span data-stu-id="0d064-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="0d064-138">Si un `let` liaison est une fonction, il est compilé dans un membre.</span><span class="sxs-lookup"><span data-stu-id="0d064-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="0d064-139">Si le `let` liaison est une valeur qui n’est pas utilisée dans une fonction ou un membre, il est compilé dans une variable qui est locale au constructeur.</span><span class="sxs-lookup"><span data-stu-id="0d064-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="0d064-140">Sinon, il est compilé dans un champ de la classe.</span><span class="sxs-lookup"><span data-stu-id="0d064-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="0d064-141">Le `do` expressions qui suivent sont compilées dans le constructeur principal et d’exécuter du code d’initialisation pour chaque instance.</span><span class="sxs-lookup"><span data-stu-id="0d064-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="0d064-142">Étant donné que les constructeurs supplémentaires toujours appellent le constructeur principal, le `let` liaisons et `do` s’exécutent toujours quel que soit le constructeur est appelé.</span><span class="sxs-lookup"><span data-stu-id="0d064-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="0d064-143">Les champs qui sont créés par `let` liaisons sont accessibles dans les méthodes et propriétés de la classe ; Toutefois, ils ne sont pas accessibles à partir de méthodes statiques, même si les méthodes statiques prennent une variable d’instance en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="0d064-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="0d064-144">Ils ne sont pas accessibles à l’aide de l’auto-identificateur, s’il en existe.</span><span class="sxs-lookup"><span data-stu-id="0d064-144">They cannot be accessed by using the self identifier, if one exists.</span></span>

## <a name="self-identifiers"></a><span data-ttu-id="0d064-145">Auto-identificateurs</span><span class="sxs-lookup"><span data-stu-id="0d064-145">Self Identifiers</span></span>

<span data-ttu-id="0d064-146">Un *auto-identificateur* est un nom qui représente l’instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="0d064-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="0d064-147">Auto-identificateurs ressembler à la `this` mot clé en c# ou C++ ou `Me` dans Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="0d064-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="0d064-148">Vous pouvez définir un auto-identificateur de deux manières différentes, selon que vous souhaitez l’auto-identificateur pour être dans la portée pour la définition de classe entière ou simplement pour une méthode individuelle.</span><span class="sxs-lookup"><span data-stu-id="0d064-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="0d064-149">Pour définir un auto-identificateur pour la classe entière, utilisez le `as` mot clé après la parenthèse fermante du paramètre de constructeur de liste et spécifiez le nom d’identificateur.</span><span class="sxs-lookup"><span data-stu-id="0d064-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="0d064-150">Pour définir un auto-identificateur pour qu’une seule méthode, indiquez l’auto-identificateur dans la déclaration de membre, juste avant le nom de méthode et un point (.) comme séparateur.</span><span class="sxs-lookup"><span data-stu-id="0d064-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="0d064-151">L’exemple de code suivant illustre les deux façons de créer un identificateur personnel.</span><span class="sxs-lookup"><span data-stu-id="0d064-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="0d064-152">Dans la première ligne, le `as` mot clé est utilisé pour définir l’auto-identificateur.</span><span class="sxs-lookup"><span data-stu-id="0d064-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="0d064-153">Dans la cinquième ligne, l’identificateur `this` est utilisé pour définir un auto-identificateur dont la portée est limitée à la méthode `PrintMessage`.</span><span class="sxs-lookup"><span data-stu-id="0d064-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="0d064-154">Contrairement à d’autres langages .NET, vous pouvez nommer l’auto-identificateur comme vous le souhaitez ; vous n’êtes pas limité aux noms tels que `self`, `Me`, ou `this`.</span><span class="sxs-lookup"><span data-stu-id="0d064-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="0d064-155">L’auto-identificateur qui est déclaré avec le `as` mot clé n’est pas initialisée tant qu’après le `let` liaisons sont exécutées.</span><span class="sxs-lookup"><span data-stu-id="0d064-155">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="0d064-156">Par conséquent, il ne peut pas être utilisé dans le `let` liaisons.</span><span class="sxs-lookup"><span data-stu-id="0d064-156">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="0d064-157">Vous pouvez utiliser l’auto-identificateur dans la `do` section des liaisons.</span><span class="sxs-lookup"><span data-stu-id="0d064-157">You can use the self identifier in the `do` bindings section.</span></span>

## <a name="generic-type-parameters"></a><span data-ttu-id="0d064-158">Paramètres de type générique</span><span class="sxs-lookup"><span data-stu-id="0d064-158">Generic Type Parameters</span></span>

<span data-ttu-id="0d064-159">Paramètres de type générique sont spécifiés dans les crochets pointus (`<` et `>`), sous la forme d’un guillemet simple suivi d’un identificateur.</span><span class="sxs-lookup"><span data-stu-id="0d064-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="0d064-160">Plusieurs paramètres de type générique sont séparés par des virgules.</span><span class="sxs-lookup"><span data-stu-id="0d064-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="0d064-161">Le paramètre de type générique est dans l’étendue tout au long de la déclaration.</span><span class="sxs-lookup"><span data-stu-id="0d064-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="0d064-162">L’exemple de code suivant montre comment spécifier des paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="0d064-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="0d064-163">Arguments de type sont déduits lorsque le type est utilisé.</span><span class="sxs-lookup"><span data-stu-id="0d064-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="0d064-164">Dans le code suivant, le type déduit est une séquence de tuples.</span><span class="sxs-lookup"><span data-stu-id="0d064-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a><span data-ttu-id="0d064-165">Spécification de l’héritage</span><span class="sxs-lookup"><span data-stu-id="0d064-165">Specifying Inheritance</span></span>

<span data-ttu-id="0d064-166">Le `inherit` clause identifie la classe de base directe, le cas échéant.</span><span class="sxs-lookup"><span data-stu-id="0d064-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="0d064-167">En F #, qu’une seule classe de base directe est autorisée.</span><span class="sxs-lookup"><span data-stu-id="0d064-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="0d064-168">Les interfaces qu’une classe implémente ne sont pas considérés comme des classes de base.</span><span class="sxs-lookup"><span data-stu-id="0d064-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="0d064-169">Interfaces sont traitées dans le [Interfaces](Interfaces.md) rubrique.</span><span class="sxs-lookup"><span data-stu-id="0d064-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="0d064-170">Vous pouvez accéder aux méthodes et propriétés de la classe de base à partir de la classe dérivée à l’aide du mot clé du langage `base` comme identificateur, suivi par un point (.) et le nom du membre.</span><span class="sxs-lookup"><span data-stu-id="0d064-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="0d064-171">Pour plus d’informations, consultez [Héritage](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="0d064-171">For more information, see [Inheritance](inheritance.md).</span></span>

## <a name="members-section"></a><span data-ttu-id="0d064-172">Section de membres</span><span class="sxs-lookup"><span data-stu-id="0d064-172">Members Section</span></span>

<span data-ttu-id="0d064-173">Dans cette section, vous pouvez définir statique ou méthodes d’instance, propriétés, les implémentations d’interface, membres abstraits, déclarations d’événement et des constructeurs supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="0d064-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="0d064-174">Let et effectuent des liaisons ne peut pas apparaître dans cette section.</span><span class="sxs-lookup"><span data-stu-id="0d064-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="0d064-175">Étant donné que les membres peuvent être ajoutés à un large éventail de types F # en plus des classes, ils sont traités dans une rubrique distincte, [membres](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="0d064-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](members/index.md).</span></span>

## <a name="mutually-recursive-types"></a><span data-ttu-id="0d064-176">Types mutuellement récursifs</span><span class="sxs-lookup"><span data-stu-id="0d064-176">Mutually Recursive Types</span></span>

<span data-ttu-id="0d064-177">Lorsque vous définissez des types qui se référencent mutuellement de façon circulaire, vous associer les définitions de type à l’aide de la `and` mot clé.</span><span class="sxs-lookup"><span data-stu-id="0d064-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="0d064-178">Le `and` mot clé remplace le `type` mot clé sur tous sauf la première définition, comme suit.</span><span class="sxs-lookup"><span data-stu-id="0d064-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="0d064-179">La sortie est une liste de tous les fichiers dans le répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="0d064-179">The output is a list of all the files in the current directory.</span></span>

## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="0d064-180">Quand utiliser des Classes, des Unions, des enregistrements et des Structures</span><span class="sxs-lookup"><span data-stu-id="0d064-180">When to Use Classes, Unions, Records, and Structures</span></span>

<span data-ttu-id="0d064-181">Étant donné la diversité des types disponibles, vous devez avoir une bonne compréhension de ce que chaque type est conçu pour sélectionner le type approprié pour une situation particulière.</span><span class="sxs-lookup"><span data-stu-id="0d064-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="0d064-182">Classes sont conçues pour une utilisation dans des contextes de programmation orientée objet.</span><span class="sxs-lookup"><span data-stu-id="0d064-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="0d064-183">Programmation orientée objet est le paradigme dominant utilisé dans les applications écrites pour le .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="0d064-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="0d064-184">Si votre code F # doit travailler en étroite collaboration avec le .NET Framework ou une autre bibliothèque orientée objet, et en particulier si vous avez besoin d’étendre à partir d’un système type orienté objet tel qu’une bibliothèque d’interface utilisateur, les classes sont probablement appropriés.</span><span class="sxs-lookup"><span data-stu-id="0d064-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="0d064-185">Si vous n’interagissez pas étroitement avec code orienté objet, ou si vous écrivez du code qui est autonome et par conséquent protégés de l’interaction fréquente avec code orienté objet, vous devez envisager d’utiliser des enregistrements et des unions discriminées.</span><span class="sxs-lookup"><span data-stu-id="0d064-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="0d064-186">Un seul, bien pensée – hors union discriminée, ainsi que du code, de correspondance au modèle approprié peut souvent être utilisée comme une alternative plus simple à une hiérarchie d’objets.</span><span class="sxs-lookup"><span data-stu-id="0d064-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="0d064-187">Pour plus d’informations sur les unions discriminées, consultez [Unions discriminées](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="0d064-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="0d064-188">Enregistrements ont l’avantage d’être plus simple que les classes, mais les enregistrements ne sont pas appropriées lorsque les demandes d’un type dépassent ce qui peut être effectué avec leur simplicité.</span><span class="sxs-lookup"><span data-stu-id="0d064-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="0d064-189">Les enregistrements sont essentiellement des agrégats simples de valeurs, sans constructeurs distincts qui peuvent effectuer des actions personnalisées, sans champs masqués et sans implémentations d’héritage ou d’interface.</span><span class="sxs-lookup"><span data-stu-id="0d064-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="0d064-190">Bien que les membres tels que les propriétés et méthodes peuvent être ajoutés aux enregistrements pour rendre leur comportement plus complexe, les champs stockés dans un enregistrement existe toujours un agrégat simple de valeurs.</span><span class="sxs-lookup"><span data-stu-id="0d064-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="0d064-191">Pour plus d’informations à propos des enregistrements, consultez [enregistrements](records.md).</span><span class="sxs-lookup"><span data-stu-id="0d064-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="0d064-192">Structures sont également utiles pour les petits volumes de données, mais elles diffèrent à partir des classes et des enregistrements qu’elles sont des types valeur .NET.</span><span class="sxs-lookup"><span data-stu-id="0d064-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="0d064-193">Classes et les enregistrements sont des types référence.</span><span class="sxs-lookup"><span data-stu-id="0d064-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="0d064-194">La sémantique des types valeur et types référence est différente dans la mesure où les types valeur sont passés par valeur.</span><span class="sxs-lookup"><span data-stu-id="0d064-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="0d064-195">Cela signifie qu’ils sont copiés bit par bit lorsqu’ils sont passés en tant que paramètre ou retournés à partir d’une fonction.</span><span class="sxs-lookup"><span data-stu-id="0d064-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="0d064-196">Ils sont également stockés sur la pile ou, s’ils sont utilisés en tant que champ, incorporé à l’intérieur de l’objet parent au lieu de dans leur propre emplacement distinct sur le tas.</span><span class="sxs-lookup"><span data-stu-id="0d064-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="0d064-197">Par conséquent, les structures sont appropriées pour les données fréquemment utilisées lors de la surcharge de l’accès à du tas est un problème.</span><span class="sxs-lookup"><span data-stu-id="0d064-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="0d064-198">Pour plus d’informations sur les structures, consultez [Structures](structures.md).</span><span class="sxs-lookup"><span data-stu-id="0d064-198">For more information about structures, see [Structures](structures.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="0d064-199">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="0d064-199">See also</span></span>

- [<span data-ttu-id="0d064-200">Informations de référence du langage F#</span><span class="sxs-lookup"><span data-stu-id="0d064-200">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="0d064-201">Membres</span><span class="sxs-lookup"><span data-stu-id="0d064-201">Members</span></span>](members/index.md)
- [<span data-ttu-id="0d064-202">Héritage</span><span class="sxs-lookup"><span data-stu-id="0d064-202">Inheritance</span></span>](inheritance.md)
- [<span data-ttu-id="0d064-203">Interfaces</span><span class="sxs-lookup"><span data-stu-id="0d064-203">Interfaces</span></span>](interfaces.md)
